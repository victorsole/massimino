/**
 * Trainer Progress Reports API
 * Automated client progress reports and analytics for trainers
 */

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/core';
import {
  createProgressReport,
  getTrainerProgressReports,
  getTrainerAppointments
} from '@/core/database';
import { prisma } from '@/core/database';

// ============================================================================
// GET - Fetch trainer's progress reports
// ============================================================================

export async function GET(request: Request) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    if (session.user.role !== 'TRAINER') {
      return NextResponse.json({ error: 'Access denied - trainers only' }, { status: 403 });
    }

    const { searchParams } = new URL(request.url);
    const clientId = searchParams.get('clientId');
    const period = searchParams.get('period');
    const isShared = searchParams.get('isShared') === 'true';
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');

    // Get trainer profile
    const trainerProfile = await prisma.trainer_profiles.findUnique({
      where: { userId: session.user.id }
    });

    if (!trainerProfile) {
      return NextResponse.json({ error: 'Trainer profile not found' }, { status: 404 });
    }

    const reports = await getTrainerProgressReports(
      trainerProfile.id,
      {
        ...(clientId ? { clientId } : {}),
        ...(period ? { period } : {}),
        isShared,
        page,
        limit,
      }
    );

    return NextResponse.json({
      success: true,
      data: reports
    });

  } catch (error) {
    console.error('Progress reports fetch error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch progress reports' },
      { status: 500 }
    );
  }
}

// ============================================================================
// POST - Create new progress report
// ============================================================================

export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    if (session.user.role !== 'TRAINER') {
      return NextResponse.json({ error: 'Access denied - trainers only' }, { status: 403 });
    }

    const body = await request.json();
    const {
      clientId,
      title,
      summary,
      period = 'MONTHLY',
      goals = [],
      achievements = [],
      metrics = {},
      workoutStats = {},
      recommendations,
      nextGoals = [],
      autoGenerate = false
    } = body;

    // Validate required fields
    if (!clientId || !title || !summary) {
      return NextResponse.json({
        error: 'Missing required fields: clientId, title, summary'
      }, { status: 400 });
    }

    // Get trainer profile
    const trainerProfile = await prisma.trainer_profiles.findUnique({
      where: { userId: session.user.id }
    });

    if (!trainerProfile) {
      return NextResponse.json({ error: 'Trainer profile not found' }, { status: 404 });
    }

    // Verify trainer-client relationship
    const trainerClient = await prisma.trainer_clients.findUnique({
      where: {
        trainerId_clientId: {
          trainerId: trainerProfile.id,
          clientId
        }
      }
    });

    if (!trainerClient) {
      return NextResponse.json({
        error: 'Client not found or not associated with this trainer'
      }, { status: 404 });
    }

    let reportData = {
      trainerId: trainerProfile.id,
      clientId,
      trainerClientId: trainerClient.id,
      title,
      summary,
      period,
      goals,
      achievements,
      metrics,
      workoutStats,
      recommendations,
      nextGoals
    };

    // Auto-generate report content if requested
    if (autoGenerate) {
      const generatedData = await generateProgressReportData(trainerProfile.id, clientId, period);
      reportData = {
        ...reportData,
        ...generatedData
      };
    }

    const report = await createProgressReport(reportData);

    console.log('Progress report created:', {
      reportId: report.id,
      trainerId: trainerProfile.id,
      clientId,
      period,
      autoGenerated: autoGenerate
    });

    return NextResponse.json({
      success: true,
      data: report
    });

  } catch (error) {
    console.error('Progress report creation error:', error);
    return NextResponse.json(
      { error: 'Failed to create progress report' },
      { status: 500 }
    );
  }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Auto-generate progress report data based on client workout history
 */
async function generateProgressReportData(trainerId: string, clientId: string, period: string) {
  try {
    // Calculate date range based on period
    const now = new Date();
    let startDate: Date;

    switch (period) {
      case 'WEEKLY':
        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case 'QUARTERLY':
        startDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
        break;
      default: // MONTHLY
        startDate = new Date(now.getFullYear(), now.getMonth() - 1, now.getDate());
    }

    // Get workout sessions for the period
    const workoutSessions = await prisma.workout_sessions.findMany({
      where: {
        userId: clientId,
        coachId: trainerId,
        startTime: { gte: startDate },
        isComplete: true
      },
      // TODO: Fix relationship name - 'entries' doesn't exist on workout_sessions
      // include: {
      //   entries: {
      //     include: {
      //       exercise: {
      //         select: {
      //           name: true,
      //           category: true,
      //           muscleGroups: true
      //         }
      //       }
      //     }
      //   }
      // },
      orderBy: { startTime: 'desc' }
    });

    // Get appointments for the period
    const appointments = await getTrainerAppointments(trainerId, {
      clientId,
      dateRange: { start: startDate, end: now },
      status: ['COMPLETED']
    });

    // Generate metrics
    const metrics = {
      totalWorkouts: workoutSessions.length,
      totalDuration: workoutSessions.reduce((sum, session) =>
        sum + (session.duration || 0), 0),
      totalVolume: workoutSessions.reduce((sum, session) =>
        sum + (session.totalVolume || 0), 0),
      averageWorkoutDuration: workoutSessions.length > 0 ?
        workoutSessions.reduce((sum, session) => sum + (session.duration || 0), 0) / workoutSessions.length : 0,
      completedAppointments: appointments.appointments?.length || 0,
      consistency: calculateConsistency(workoutSessions, startDate, now)
    };

    // Generate workout stats
    const workoutStats = {
      exerciseBreakdown: generateExerciseBreakdown(workoutSessions),
      muscleGroupFocus: generateMuscleGroupBreakdown(workoutSessions),
      progressionTrends: generateProgressionTrends(workoutSessions),
      personalRecords: await getPersonalRecords(clientId, startDate)
    };

    // Generate achievements
    const achievements = generateAchievements(metrics, workoutStats);

    // Generate recommendations
    const recommendations = generateRecommendations(metrics, workoutStats);

    // Generate next goals
    const nextGoals = generateNextGoals(metrics, workoutStats);

    return {
      metrics,
      workoutStats,
      achievements,
      recommendations,
      nextGoals
    };

  } catch (error) {
    console.error('Error generating progress report data:', error);
    return {};
  }
}

/**
 * Calculate workout consistency percentage
 */
function calculateConsistency(sessions: any[], startDate: Date, endDate: Date): number {
  const totalDays = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
  const workoutDays = new Set(sessions.map(session =>
    session.startTime.toISOString().split('T')[0]
  )).size;

  return totalDays > 0 ? Math.round((workoutDays / totalDays) * 100) : 0;
}

/**
 * Generate exercise breakdown
 */
function generateExerciseBreakdown(sessions: any[]) {
  const exerciseCount: Record<string, number> = {};

  sessions.forEach(session => {
    session.entries?.forEach((entry: any) => {
      const exerciseName = entry.exercise?.name || 'Unknown';
      exerciseCount[exerciseName] = (exerciseCount[exerciseName] || 0) + 1;
    });
  });

  return Object.entries(exerciseCount)
    .sort(([, a], [, b]) => b - a)
    .slice(0, 10)
    .map(([exercise, count]) => ({ exercise, count }));
}

/**
 * Generate muscle group breakdown
 */
function generateMuscleGroupBreakdown(sessions: any[]) {
  const muscleGroupCount: Record<string, number> = {};

  sessions.forEach(session => {
    session.entries?.forEach((entry: any) => {
      const muscleGroup = entry.exercise?.muscleGroup || 'Unknown';
      muscleGroupCount[muscleGroup] = (muscleGroupCount[muscleGroup] || 0) + 1;
    });
  });

  return Object.entries(muscleGroupCount)
    .sort(([, a], [, b]) => b - a)
    .map(([muscleGroup, count]) => ({ muscleGroup, count }));
}

/**
 * Generate progression trends
 */
function generateProgressionTrends(sessions: any[]) {
  // This is a simplified version - could be enhanced with more sophisticated analysis
  const volumeTrend = sessions.reduce((
    _trend,
    session,
    index
  ) => {
    if (index === 0) return 'stable';
    const prevVolume = sessions[index - 1]?.totalVolume || 0;
    const currentVolume = session.totalVolume || 0;

    if (currentVolume > prevVolume * 1.1) return 'increasing';
    if (currentVolume < prevVolume * 0.9) return 'decreasing';
    return 'stable';
  }, 'stable');

  return {
    volumeTrend,
    sessionCount: sessions.length,
    averageSession: sessions.length > 0 ?
      sessions.reduce((sum, s) => sum + (s.totalVolume || 0), 0) / sessions.length : 0
  };
}

/**
 * Get personal records for the period
 */
async function getPersonalRecords(clientId: string, startDate: Date) {
  const personalRecords = await prisma.personal_records.findMany({
    where: {
      userId: clientId,
      achievedAt: { gte: startDate }
    },
    include: {
      exercises: {
        select: { name: true }
      }
    },
    orderBy: { achievedAt: 'desc' },
    take: 5
  });

  return personalRecords.map(pr => ({
    exercise: pr.exercises.name,
    type: pr.recordType,
    value: pr.value,
    unit: pr.unit,
    achievedAt: pr.achievedAt
  }));
}

/**
 * Generate achievements based on metrics
 */
function generateAchievements(metrics: any, workoutStats: any) {
  const achievements: any[] = [];

  if (metrics.totalWorkouts >= 12) {
    achievements.push({
      title: 'Consistency Champion',
      description: `Completed ${metrics.totalWorkouts} workouts this period`,
      type: 'consistency'
    });
  }

  if (metrics.consistency >= 80) {
    achievements.push({
      title: 'Workout Streak',
      description: `Maintained ${metrics.consistency}% workout consistency`,
      type: 'consistency'
    });
  }

  if (workoutStats.personalRecords?.length > 0) {
    achievements.push({
      title: 'Personal Best',
      description: `Set ${workoutStats.personalRecords.length} new personal records`,
      type: 'performance'
    });
  }

  return achievements;
}

/**
 * Generate recommendations
 */
function generateRecommendations(metrics: any, workoutStats: any) {
  const recommendations: any[] = [];

  if (metrics.consistency < 60) {
    recommendations.push('Focus on improving workout consistency. Aim for at least 3-4 sessions per week.');
  }

  if (metrics.averageWorkoutDuration < 30) {
    recommendations.push('Consider extending workout duration to maximize training benefits.');
  }

  const muscleGroups = workoutStats.muscleGroupFocus || [];
  if (muscleGroups.length < 4) {
    recommendations.push('Include more diverse muscle groups for balanced development.');
  }

  return recommendations.length > 0 ? recommendations.join(' ') :
    'Great progress! Continue with your current training approach.';
}

/**
 * Generate next goals
 */
function generateNextGoals(metrics: any, _workoutStats: any) {
  const goals: any[] = [];

  goals.push({
    category: 'consistency',
    target: Math.min(metrics.consistency + 10, 100),
    description: `Improve workout consistency to ${Math.min(metrics.consistency + 10, 100)}%`
  });

  if (metrics.totalVolume > 0) {
    goals.push({
      category: 'volume',
      target: metrics.totalVolume * 1.1,
      description: 'Increase total training volume by 10%'
    });
  }

  goals.push({
    category: 'strength',
    target: 3,
    description: 'Set 3 new personal records next period'
  });

  return goals;
}
