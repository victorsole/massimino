/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/socket.io";
exports.ids = ["vendor-chunks/socket.io"];
exports.modules = {

/***/ "(action-browser)/./node_modules/socket.io/dist/broadcast-operator.js":
/*!***********************************************************!*\
  !*** ./node_modules/socket.io/dist/broadcast-operator.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RemoteSocket = exports.BroadcastOperator = void 0;\nconst socket_types_1 = __webpack_require__(/*! ./socket-types */ \"(action-browser)/./node_modules/socket.io/dist/socket-types.js\");\nconst socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ \"(action-browser)/./node_modules/socket.io-parser/build/cjs/index.js\");\nclass BroadcastOperator {\n    constructor(adapter, rooms = new Set(), exceptRooms = new Set(), flags = {}) {\n        this.adapter = adapter;\n        this.rooms = rooms;\n        this.exceptRooms = exceptRooms;\n        this.flags = flags;\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @example\n     * // the “foo” event will be broadcast to all connected clients in the “room-101” room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms (a client will be notified at most once)\n     * io.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    to(room) {\n        const rooms = new Set(this.rooms);\n        if (Array.isArray(room)) {\n            room.forEach((r) => rooms.add(r));\n        }\n        else {\n            rooms.add(room);\n        }\n        return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);\n    }\n    /**\n     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * // disconnect all clients in the \"room-101\" room\n     * io.in(\"room-101\").disconnectSockets();\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    in(room) {\n        return this.to(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @example\n     * // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     * io.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms\n     * io.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    except(room) {\n        const exceptRooms = new Set(this.exceptRooms);\n        if (Array.isArray(room)) {\n            room.forEach((r) => exceptRooms.add(r));\n        }\n        else {\n            exceptRooms.add(room);\n        }\n        return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return a new BroadcastOperator instance\n     */\n    compress(compress) {\n        const flags = Object.assign({}, this.flags, { compress });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.volatile.emit(\"hello\"); // the clients may or may not receive it\n     *\n     * @return a new BroadcastOperator instance\n     */\n    get volatile() {\n        const flags = Object.assign({}, this.flags, { volatile: true });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * // the “foo” event will be broadcast to all connected clients on this node\n     * io.local.emit(\"foo\", \"bar\");\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    get local() {\n        const flags = Object.assign({}, this.flags, { local: true });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation\n     *\n     * @example\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @param timeout\n     */\n    timeout(timeout) {\n        const flags = Object.assign({}, this.flags, { timeout });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Emits to all clients.\n     *\n     * @example\n     * // the “foo” event will be broadcast to all connected clients\n     * io.emit(\"foo\", \"bar\");\n     *\n     * // the “foo” event will be broadcast to all connected clients in the “room-101” room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an acknowledgement expected from all connected clients\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @return Always true\n     */\n    emit(ev, ...args) {\n        if (socket_types_1.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${String(ev)}\" is a reserved event name`);\n        }\n        // set up packet object\n        const data = [ev, ...args];\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: data,\n        };\n        const withAck = typeof data[data.length - 1] === \"function\";\n        if (!withAck) {\n            this.adapter.broadcast(packet, {\n                rooms: this.rooms,\n                except: this.exceptRooms,\n                flags: this.flags,\n            });\n            return true;\n        }\n        const ack = data.pop();\n        let timedOut = false;\n        let responses = [];\n        const timer = setTimeout(() => {\n            timedOut = true;\n            ack.apply(this, [\n                new Error(\"operation has timed out\"),\n                this.flags.expectSingleResponse ? null : responses,\n            ]);\n        }, this.flags.timeout);\n        let expectedServerCount = -1;\n        let actualServerCount = 0;\n        let expectedClientCount = 0;\n        const checkCompleteness = () => {\n            if (!timedOut &&\n                expectedServerCount === actualServerCount &&\n                responses.length === expectedClientCount) {\n                clearTimeout(timer);\n                ack.apply(this, [\n                    null,\n                    this.flags.expectSingleResponse ? responses[0] : responses,\n                ]);\n            }\n        };\n        this.adapter.broadcastWithAck(packet, {\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        }, (clientCount) => {\n            // each Socket.IO server in the cluster sends the number of clients that were notified\n            expectedClientCount += clientCount;\n            actualServerCount++;\n            checkCompleteness();\n        }, (clientResponse) => {\n            // each client sends an acknowledgement\n            responses.push(clientResponse);\n            checkCompleteness();\n        });\n        this.adapter.serverCount().then((serverCount) => {\n            expectedServerCount = serverCount;\n            checkCompleteness();\n        });\n        return true;\n    }\n    /**\n     * Emits an event and waits for an acknowledgement from all clients.\n     *\n     * @example\n     * try {\n     *   const responses = await io.timeout(1000).emitWithAck(\"some-event\");\n     *   console.log(responses); // one response per client\n     * } catch (e) {\n     *   // some clients did not acknowledge the event in the given delay\n     * }\n     *\n     * @return a Promise that will be fulfilled when all clients have acknowledged the event\n     */\n    emitWithAck(ev, ...args) {\n        return new Promise((resolve, reject) => {\n            args.push((err, responses) => {\n                if (err) {\n                    err.responses = responses;\n                    return reject(err);\n                }\n                else {\n                    return resolve(responses);\n                }\n            });\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or\n     * {@link fetchSockets} instead.\n     */\n    allSockets() {\n        if (!this.adapter) {\n            throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n        }\n        return this.adapter.sockets(this.rooms);\n    }\n    /**\n     * Returns the matching socket instances. This method works across a cluster of several Socket.IO servers.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // return all Socket instances\n     * const sockets = await io.fetchSockets();\n     *\n     * // return all Socket instances in the \"room1\" room\n     * const sockets = await io.in(\"room1\").fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   console.log(socket.id);\n     *   console.log(socket.handshake);\n     *   console.log(socket.rooms);\n     *   console.log(socket.data);\n     *\n     *   socket.emit(\"hello\");\n     *   socket.join(\"room1\");\n     *   socket.leave(\"room2\");\n     *   socket.disconnect();\n     * }\n     */\n    fetchSockets() {\n        return this.adapter\n            .fetchSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        })\n            .then((sockets) => {\n            return sockets.map((socket) => {\n                if (socket.server) {\n                    return socket; // local instance\n                }\n                else {\n                    return new RemoteSocket(this.adapter, socket);\n                }\n            });\n        });\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     *\n     * // make all socket instances join the \"room1\" room\n     * io.socketsJoin(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room join the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsJoin([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */\n    socketsJoin(room) {\n        this.adapter.addSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        }, Array.isArray(room) ? room : [room]);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances leave the \"room1\" room\n     * io.socketsLeave(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room leave the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsLeave([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */\n    socketsLeave(room) {\n        this.adapter.delSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        }, Array.isArray(room) ? room : [room]);\n    }\n    /**\n     * Makes the matching socket instances disconnect.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)\n     * io.disconnectSockets();\n     *\n     * // make all socket instances in the \"room1\" room disconnect and close the underlying connections\n     * io.in(\"room1\").disconnectSockets(true);\n     *\n     * @param close - whether to close the underlying connection\n     */\n    disconnectSockets(close = false) {\n        this.adapter.disconnectSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        }, close);\n    }\n}\nexports.BroadcastOperator = BroadcastOperator;\n/**\n * Expose of subset of the attributes and methods of the Socket class\n */\nclass RemoteSocket {\n    constructor(adapter, details) {\n        this.id = details.id;\n        this.handshake = details.handshake;\n        this.rooms = new Set(details.rooms);\n        this.data = details.data;\n        this.operator = new BroadcastOperator(adapter, new Set([this.id]), new Set(), {\n            expectSingleResponse: true, // so that remoteSocket.emit() with acknowledgement behaves like socket.emit()\n        });\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation.\n     *\n     * @example\n     * const sockets = await io.fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   if (someCondition) {\n     *     socket.timeout(1000).emit(\"some-event\", (err) => {\n     *       if (err) {\n     *         // the client did not acknowledge the event in the given delay\n     *       }\n     *     });\n     *   }\n     * }\n     *\n     * // note: if possible, using a room instead of looping over all sockets is preferable\n     * io.timeout(1000).to(someConditionRoom).emit(\"some-event\", (err, responses) => {\n     *   // ...\n     * });\n     *\n     * @param timeout\n     */\n    timeout(timeout) {\n        return this.operator.timeout(timeout);\n    }\n    emit(ev, ...args) {\n        return this.operator.emit(ev, ...args);\n    }\n    /**\n     * Joins a room.\n     *\n     * @param {String|Array} room - room or array of rooms\n     */\n    join(room) {\n        return this.operator.socketsJoin(room);\n    }\n    /**\n     * Leaves a room.\n     *\n     * @param {String} room\n     */\n    leave(room) {\n        return this.operator.socketsLeave(room);\n    }\n    /**\n     * Disconnects this client.\n     *\n     * @param {Boolean} close - if `true`, closes the underlying connection\n     * @return {Socket} self\n     */\n    disconnect(close = false) {\n        this.operator.disconnectSockets(close);\n        return this;\n    }\n}\nexports.RemoteSocket = RemoteSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9icm9hZGNhc3Qtb3BlcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcseUJBQXlCO0FBQ2hELHVCQUF1QixtQkFBTyxDQUFDLHNGQUFnQjtBQUMvQywyQkFBMkIsbUJBQU8sQ0FBQyw2RkFBa0I7QUFDckQ7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0IsVUFBVTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQixnQkFBZ0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQixhQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxtQ0FBbUM7QUFDbkM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCLFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsbUNBQW1DO0FBQ25DO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRiw2QkFBNkI7QUFDbkgsUUFBUSxvQkFBb0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsY0FBYztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsY0FBYztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxjQUFjO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxjQUFjO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3Jzb2xlL0RvY3VtZW50cy9HaXRIdWIvbWFzc2ltaW5vL21hc3NpbWluby9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvYnJvYWRjYXN0LW9wZXJhdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZW1vdGVTb2NrZXQgPSBleHBvcnRzLkJyb2FkY2FzdE9wZXJhdG9yID0gdm9pZCAwO1xuY29uc3Qgc29ja2V0X3R5cGVzXzEgPSByZXF1aXJlKFwiLi9zb2NrZXQtdHlwZXNcIik7XG5jb25zdCBzb2NrZXRfaW9fcGFyc2VyXzEgPSByZXF1aXJlKFwic29ja2V0LmlvLXBhcnNlclwiKTtcbmNsYXNzIEJyb2FkY2FzdE9wZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihhZGFwdGVyLCByb29tcyA9IG5ldyBTZXQoKSwgZXhjZXB0Um9vbXMgPSBuZXcgU2V0KCksIGZsYWdzID0ge30pIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyID0gYWRhcHRlcjtcbiAgICAgICAgdGhpcy5yb29tcyA9IHJvb21zO1xuICAgICAgICB0aGlzLmV4Y2VwdFJvb21zID0gZXhjZXB0Um9vbXM7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBlbWl0dGluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gdGhlIOKAnGZvb+KAnSBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMgaW4gdGhlIOKAnHJvb20tMTAx4oCdIHJvb21cbiAgICAgKiBpby50byhcInJvb20tMTAxXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGFuIGFycmF5IG9mIHJvb21zIChhIGNsaWVudCB3aWxsIGJlIG5vdGlmaWVkIGF0IG1vc3Qgb25jZSlcbiAgICAgKiBpby50byhbXCJyb29tLTEwMVwiLCBcInJvb20tMTAyXCJdKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBtdWx0aXBsZSBjaGFpbmVkIGNhbGxzXG4gICAgICogaW8udG8oXCJyb29tLTEwMVwiKS50byhcInJvb20tMTAyXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgdG8ocm9vbSkge1xuICAgICAgICBjb25zdCByb29tcyA9IG5ldyBTZXQodGhpcy5yb29tcyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJvb20pKSB7XG4gICAgICAgICAgICByb29tLmZvckVhY2goKHIpID0+IHJvb21zLmFkZChyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb29tcy5hZGQocm9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCcm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIsIHJvb21zLCB0aGlzLmV4Y2VwdFJvb21zLCB0aGlzLmZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBlbWl0dGluZy4gU2ltaWxhciB0byBgdG8oKWAsIGJ1dCBtaWdodCBmZWVsIGNsZWFyZXIgaW4gc29tZSBjYXNlczpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZGlzY29ubmVjdCBhbGwgY2xpZW50cyBpbiB0aGUgXCJyb29tLTEwMVwiIHJvb21cbiAgICAgKiBpby5pbihcInJvb20tMTAxXCIpLmRpc2Nvbm5lY3RTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgaW4ocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy50byhyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhjbHVkZXMgYSByb29tIHdoZW4gZW1pdHRpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHRoZSBcImZvb1wiIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cywgZXhjZXB0IHRoZSBvbmVzIHRoYXQgYXJlIGluIHRoZSBcInJvb20tMTAxXCIgcm9vbVxuICAgICAqIGlvLmV4Y2VwdChcInJvb20tMTAxXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogaW8uZXhjZXB0KFtcInJvb20tMTAxXCIsIFwicm9vbS0xMDJcIl0pLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIG11bHRpcGxlIGNoYWluZWQgY2FsbHNcbiAgICAgKiBpby5leGNlcHQoXCJyb29tLTEwMVwiKS5leGNlcHQoXCJyb29tLTEwMlwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGV4Y2VwdChyb29tKSB7XG4gICAgICAgIGNvbnN0IGV4Y2VwdFJvb21zID0gbmV3IFNldCh0aGlzLmV4Y2VwdFJvb21zKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocm9vbSkpIHtcbiAgICAgICAgICAgIHJvb20uZm9yRWFjaCgocikgPT4gZXhjZXB0Um9vbXMuYWRkKHIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4Y2VwdFJvb21zLmFkZChyb29tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlciwgdGhpcy5yb29tcywgZXhjZXB0Um9vbXMsIHRoaXMuZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5jb21wcmVzcyhmYWxzZSkuZW1pdChcImhlbGxvXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIGNvbXByZXNzIC0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAgICAgKiBAcmV0dXJuIGEgbmV3IEJyb2FkY2FzdE9wZXJhdG9yIGluc3RhbmNlXG4gICAgICovXG4gICAgY29tcHJlc3MoY29tcHJlc3MpIHtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZsYWdzLCB7IGNvbXByZXNzIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlciwgdGhpcy5yb29tcywgdGhpcy5leGNlcHRSb29tcywgZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIG1heSBiZSBsb3N0IGlmIHRoZSBjbGllbnQgaXMgbm90IHJlYWR5IHRvXG4gICAgICogcmVjZWl2ZSBtZXNzYWdlcyAoYmVjYXVzZSBvZiBuZXR3b3JrIHNsb3duZXNzIG9yIG90aGVyIGlzc3Vlcywgb3IgYmVjYXVzZSB0aGV54oCZcmUgY29ubmVjdGVkIHRocm91Z2ggbG9uZyBwb2xsaW5nXG4gICAgICogYW5kIGlzIGluIHRoZSBtaWRkbGUgb2YgYSByZXF1ZXN0LXJlc3BvbnNlIGN5Y2xlKS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8udm9sYXRpbGUuZW1pdChcImhlbGxvXCIpOyAvLyB0aGUgY2xpZW50cyBtYXkgb3IgbWF5IG5vdCByZWNlaXZlIGl0XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgbmV3IEJyb2FkY2FzdE9wZXJhdG9yIGluc3RhbmNlXG4gICAgICovXG4gICAgZ2V0IHZvbGF0aWxlKCkge1xuICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZmxhZ3MsIHsgdm9sYXRpbGU6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyLCB0aGlzLnJvb21zLCB0aGlzLmV4Y2VwdFJvb21zLCBmbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IGRhdGEgd2lsbCBvbmx5IGJlIGJyb2FkY2FzdCB0byB0aGUgY3VycmVudCBub2RlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cyBvbiB0aGlzIG5vZGVcbiAgICAgKiBpby5sb2NhbC5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGdldCBsb2NhbCgpIHtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZsYWdzLCB7IGxvY2FsOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlciwgdGhpcy5yb29tcywgdGhpcy5leGNlcHRSb29tcywgZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSBuZXh0IG9wZXJhdGlvblxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby50aW1lb3V0KDEwMDApLmVtaXQoXCJzb21lLWV2ZW50XCIsIChlcnIsIHJlc3BvbnNlcykgPT4ge1xuICAgICAqICAgaWYgKGVycikge1xuICAgICAqICAgICAvLyBzb21lIGNsaWVudHMgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogICB9IGVsc2Uge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXNwb25zZXMpOyAvLyBvbmUgcmVzcG9uc2UgcGVyIGNsaWVudFxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHRpbWVvdXRcbiAgICAgKi9cbiAgICB0aW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZsYWdzLCB7IHRpbWVvdXQgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyLCB0aGlzLnJvb21zLCB0aGlzLmV4Y2VwdFJvb21zLCBmbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIHRvIGFsbCBjbGllbnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50c1xuICAgICAqIGlvLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cyBpbiB0aGUg4oCccm9vbS0xMDHigJ0gcm9vbVxuICAgICAqIGlvLnRvKFwicm9vbS0xMDFcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYW4gYWNrbm93bGVkZ2VtZW50IGV4cGVjdGVkIGZyb20gYWxsIGNvbm5lY3RlZCBjbGllbnRzXG4gICAgICogaW8udGltZW91dCgxMDAwKS5lbWl0KFwic29tZS1ldmVudFwiLCAoZXJyLCByZXNwb25zZXMpID0+IHtcbiAgICAgKiAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgLy8gc29tZSBjbGllbnRzIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgfSBlbHNlIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzcG9uc2VzKTsgLy8gb25lIHJlc3BvbnNlIHBlciBjbGllbnRcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gQWx3YXlzIHRydWVcbiAgICAgKi9cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIGlmIChzb2NrZXRfdHlwZXNfMS5SRVNFUlZFRF9FVkVOVFMuaGFzKGV2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7U3RyaW5nKGV2KX1cIiBpcyBhIHJlc2VydmVkIGV2ZW50IG5hbWVgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgdXAgcGFja2V0IG9iamVjdFxuICAgICAgICBjb25zdCBkYXRhID0gW2V2LCAuLi5hcmdzXTtcbiAgICAgICAgY29uc3QgcGFja2V0ID0ge1xuICAgICAgICAgICAgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRVZFTlQsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB3aXRoQWNrID0gdHlwZW9mIGRhdGFbZGF0YS5sZW5ndGggLSAxXSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICBpZiAoIXdpdGhBY2spIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci5icm9hZGNhc3QocGFja2V0LCB7XG4gICAgICAgICAgICAgICAgcm9vbXM6IHRoaXMucm9vbXMsXG4gICAgICAgICAgICAgICAgZXhjZXB0OiB0aGlzLmV4Y2VwdFJvb21zLFxuICAgICAgICAgICAgICAgIGZsYWdzOiB0aGlzLmZsYWdzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2sgPSBkYXRhLnBvcCgpO1xuICAgICAgICBsZXQgdGltZWRPdXQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlcyA9IFtdO1xuICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGltZWRPdXQgPSB0cnVlO1xuICAgICAgICAgICAgYWNrLmFwcGx5KHRoaXMsIFtcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3IoXCJvcGVyYXRpb24gaGFzIHRpbWVkIG91dFwiKSxcbiAgICAgICAgICAgICAgICB0aGlzLmZsYWdzLmV4cGVjdFNpbmdsZVJlc3BvbnNlID8gbnVsbCA6IHJlc3BvbnNlcyxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9LCB0aGlzLmZsYWdzLnRpbWVvdXQpO1xuICAgICAgICBsZXQgZXhwZWN0ZWRTZXJ2ZXJDb3VudCA9IC0xO1xuICAgICAgICBsZXQgYWN0dWFsU2VydmVyQ291bnQgPSAwO1xuICAgICAgICBsZXQgZXhwZWN0ZWRDbGllbnRDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IGNoZWNrQ29tcGxldGVuZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aW1lZE91dCAmJlxuICAgICAgICAgICAgICAgIGV4cGVjdGVkU2VydmVyQ291bnQgPT09IGFjdHVhbFNlcnZlckNvdW50ICYmXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VzLmxlbmd0aCA9PT0gZXhwZWN0ZWRDbGllbnRDb3VudCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgYWNrLmFwcGx5KHRoaXMsIFtcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGFncy5leHBlY3RTaW5nbGVSZXNwb25zZSA/IHJlc3BvbnNlc1swXSA6IHJlc3BvbnNlcyxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGFwdGVyLmJyb2FkY2FzdFdpdGhBY2socGFja2V0LCB7XG4gICAgICAgICAgICByb29tczogdGhpcy5yb29tcyxcbiAgICAgICAgICAgIGV4Y2VwdDogdGhpcy5leGNlcHRSb29tcyxcbiAgICAgICAgICAgIGZsYWdzOiB0aGlzLmZsYWdzLFxuICAgICAgICB9LCAoY2xpZW50Q291bnQpID0+IHtcbiAgICAgICAgICAgIC8vIGVhY2ggU29ja2V0LklPIHNlcnZlciBpbiB0aGUgY2x1c3RlciBzZW5kcyB0aGUgbnVtYmVyIG9mIGNsaWVudHMgdGhhdCB3ZXJlIG5vdGlmaWVkXG4gICAgICAgICAgICBleHBlY3RlZENsaWVudENvdW50ICs9IGNsaWVudENvdW50O1xuICAgICAgICAgICAgYWN0dWFsU2VydmVyQ291bnQrKztcbiAgICAgICAgICAgIGNoZWNrQ29tcGxldGVuZXNzKCk7XG4gICAgICAgIH0sIChjbGllbnRSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgLy8gZWFjaCBjbGllbnQgc2VuZHMgYW4gYWNrbm93bGVkZ2VtZW50XG4gICAgICAgICAgICByZXNwb25zZXMucHVzaChjbGllbnRSZXNwb25zZSk7XG4gICAgICAgICAgICBjaGVja0NvbXBsZXRlbmVzcygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGFwdGVyLnNlcnZlckNvdW50KCkudGhlbigoc2VydmVyQ291bnQpID0+IHtcbiAgICAgICAgICAgIGV4cGVjdGVkU2VydmVyQ291bnQgPSBzZXJ2ZXJDb3VudDtcbiAgICAgICAgICAgIGNoZWNrQ29tcGxldGVuZXNzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYW5kIHdhaXRzIGZvciBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSBhbGwgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdHJ5IHtcbiAgICAgKiAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IGlvLnRpbWVvdXQoMTAwMCkuZW1pdFdpdGhBY2soXCJzb21lLWV2ZW50XCIpO1xuICAgICAqICAgY29uc29sZS5sb2cocmVzcG9uc2VzKTsgLy8gb25lIHJlc3BvbnNlIHBlciBjbGllbnRcbiAgICAgKiB9IGNhdGNoIChlKSB7XG4gICAgICogICAvLyBzb21lIGNsaWVudHMgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogfVxuICAgICAqXG4gICAgICogQHJldHVybiBhIFByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIGFsbCBjbGllbnRzIGhhdmUgYWNrbm93bGVkZ2VkIHRoZSBldmVudFxuICAgICAqL1xuICAgIGVtaXRXaXRoQWNrKGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBhcmdzLnB1c2goKGVyciwgcmVzcG9uc2VzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBlcnIucmVzcG9uc2VzID0gcmVzcG9uc2VzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXNwb25zZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBsaXN0IG9mIGNsaWVudHMuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCB0aGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZSwgcGxlYXNlIHVzZSB7QGxpbmsgU2VydmVyI3NlcnZlclNpZGVFbWl0fSBvclxuICAgICAqIHtAbGluayBmZXRjaFNvY2tldHN9IGluc3RlYWQuXG4gICAgICovXG4gICAgYWxsU29ja2V0cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFkYXB0ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFkYXB0ZXIgZm9yIHRoaXMgbmFtZXNwYWNlLCBhcmUgeW91IHRyeWluZyB0byBnZXQgdGhlIGxpc3Qgb2YgY2xpZW50cyBvZiBhIGR5bmFtaWMgbmFtZXNwYWNlP1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdGVyLnNvY2tldHModGhpcy5yb29tcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMuIFRoaXMgbWV0aG9kIHdvcmtzIGFjcm9zcyBhIGNsdXN0ZXIgb2Ygc2V2ZXJhbCBTb2NrZXQuSU8gc2VydmVycy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyByZXR1cm4gYWxsIFNvY2tldCBpbnN0YW5jZXNcbiAgICAgKiBjb25zdCBzb2NrZXRzID0gYXdhaXQgaW8uZmV0Y2hTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm4gYWxsIFNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tXG4gICAgICogY29uc3Qgc29ja2V0cyA9IGF3YWl0IGlvLmluKFwicm9vbTFcIikuZmV0Y2hTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiBmb3IgKGNvbnN0IHNvY2tldCBvZiBzb2NrZXRzKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuaWQpO1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmhhbmRzaGFrZSk7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQucm9vbXMpO1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmRhdGEpO1xuICAgICAqXG4gICAgICogICBzb2NrZXQuZW1pdChcImhlbGxvXCIpO1xuICAgICAqICAgc29ja2V0LmpvaW4oXCJyb29tMVwiKTtcbiAgICAgKiAgIHNvY2tldC5sZWF2ZShcInJvb20yXCIpO1xuICAgICAqICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgZmV0Y2hTb2NrZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdGVyXG4gICAgICAgICAgICAuZmV0Y2hTb2NrZXRzKHtcbiAgICAgICAgICAgIHJvb21zOiB0aGlzLnJvb21zLFxuICAgICAgICAgICAgZXhjZXB0OiB0aGlzLmV4Y2VwdFJvb21zLFxuICAgICAgICAgICAgZmxhZ3M6IHRoaXMuZmxhZ3MsXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoc29ja2V0cykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHNvY2tldHMubWFwKChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc29ja2V0LnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ja2V0OyAvLyBsb2NhbCBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZW1vdGVTb2NrZXQodGhpcy5hZGFwdGVyLCBzb2NrZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgam9pbiB0aGUgc3BlY2lmaWVkIHJvb21zLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBqb2luIHRoZSBcInJvb20xXCIgcm9vbVxuICAgICAqIGlvLnNvY2tldHNKb2luKFwicm9vbTFcIik7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbSBqb2luIHRoZSBcInJvb20yXCIgYW5kIFwicm9vbTNcIiByb29tc1xuICAgICAqIGlvLmluKFwicm9vbTFcIikuc29ja2V0c0pvaW4oW1wicm9vbTJcIiwgXCJyb29tM1wiXSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKi9cbiAgICBzb2NrZXRzSm9pbihyb29tKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlci5hZGRTb2NrZXRzKHtcbiAgICAgICAgICAgIHJvb21zOiB0aGlzLnJvb21zLFxuICAgICAgICAgICAgZXhjZXB0OiB0aGlzLmV4Y2VwdFJvb21zLFxuICAgICAgICAgICAgZmxhZ3M6IHRoaXMuZmxhZ3MsXG4gICAgICAgIH0sIEFycmF5LmlzQXJyYXkocm9vbSkgPyByb29tIDogW3Jvb21dKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgbGVhdmUgdGhlIHNwZWNpZmllZCByb29tcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGxlYXZlIHRoZSBcInJvb20xXCIgcm9vbVxuICAgICAqIGlvLnNvY2tldHNMZWF2ZShcInJvb20xXCIpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBpbiB0aGUgXCJyb29tMVwiIHJvb20gbGVhdmUgdGhlIFwicm9vbTJcIiBhbmQgXCJyb29tM1wiIHJvb21zXG4gICAgICogaW8uaW4oXCJyb29tMVwiKS5zb2NrZXRzTGVhdmUoW1wicm9vbTJcIiwgXCJyb29tM1wiXSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKi9cbiAgICBzb2NrZXRzTGVhdmUocm9vbSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXIuZGVsU29ja2V0cyh7XG4gICAgICAgICAgICByb29tczogdGhpcy5yb29tcyxcbiAgICAgICAgICAgIGV4Y2VwdDogdGhpcy5leGNlcHRSb29tcyxcbiAgICAgICAgICAgIGZsYWdzOiB0aGlzLmZsYWdzLFxuICAgICAgICB9LCBBcnJheS5pc0FycmF5KHJvb20pID8gcm9vbSA6IFtyb29tXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGRpc2Nvbm5lY3QuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIHdpdGhpbiBhIGNsdXN0ZXIgb2YgbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBBZGFwdGVyfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBkaXNjb25uZWN0ICh0aGUgY29ubmVjdGlvbnMgbWlnaHQgYmUga2VwdCBhbGl2ZSBmb3Igb3RoZXIgbmFtZXNwYWNlcylcbiAgICAgKiBpby5kaXNjb25uZWN0U29ja2V0cygpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBpbiB0aGUgXCJyb29tMVwiIHJvb20gZGlzY29ubmVjdCBhbmQgY2xvc2UgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbnNcbiAgICAgKiBpby5pbihcInJvb20xXCIpLmRpc2Nvbm5lY3RTb2NrZXRzKHRydWUpO1xuICAgICAqXG4gICAgICogQHBhcmFtIGNsb3NlIC0gd2hldGhlciB0byBjbG9zZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uXG4gICAgICovXG4gICAgZGlzY29ubmVjdFNvY2tldHMoY2xvc2UgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXIuZGlzY29ubmVjdFNvY2tldHMoe1xuICAgICAgICAgICAgcm9vbXM6IHRoaXMucm9vbXMsXG4gICAgICAgICAgICBleGNlcHQ6IHRoaXMuZXhjZXB0Um9vbXMsXG4gICAgICAgICAgICBmbGFnczogdGhpcy5mbGFncyxcbiAgICAgICAgfSwgY2xvc2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuQnJvYWRjYXN0T3BlcmF0b3IgPSBCcm9hZGNhc3RPcGVyYXRvcjtcbi8qKlxuICogRXhwb3NlIG9mIHN1YnNldCBvZiB0aGUgYXR0cmlidXRlcyBhbmQgbWV0aG9kcyBvZiB0aGUgU29ja2V0IGNsYXNzXG4gKi9cbmNsYXNzIFJlbW90ZVNvY2tldCB7XG4gICAgY29uc3RydWN0b3IoYWRhcHRlciwgZGV0YWlscykge1xuICAgICAgICB0aGlzLmlkID0gZGV0YWlscy5pZDtcbiAgICAgICAgdGhpcy5oYW5kc2hha2UgPSBkZXRhaWxzLmhhbmRzaGFrZTtcbiAgICAgICAgdGhpcy5yb29tcyA9IG5ldyBTZXQoZGV0YWlscy5yb29tcyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRldGFpbHMuZGF0YTtcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IG5ldyBCcm9hZGNhc3RPcGVyYXRvcihhZGFwdGVyLCBuZXcgU2V0KFt0aGlzLmlkXSksIG5ldyBTZXQoKSwge1xuICAgICAgICAgICAgZXhwZWN0U2luZ2xlUmVzcG9uc2U6IHRydWUsIC8vIHNvIHRoYXQgcmVtb3RlU29ja2V0LmVtaXQoKSB3aXRoIGFja25vd2xlZGdlbWVudCBiZWhhdmVzIGxpa2Ugc29ja2V0LmVtaXQoKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgbmV4dCBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHNvY2tldHMgPSBhd2FpdCBpby5mZXRjaFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIGZvciAoY29uc3Qgc29ja2V0IG9mIHNvY2tldHMpIHtcbiAgICAgKiAgIGlmIChzb21lQ29uZGl0aW9uKSB7XG4gICAgICogICAgIHNvY2tldC50aW1lb3V0KDEwMDApLmVtaXQoXCJzb21lLWV2ZW50XCIsIChlcnIpID0+IHtcbiAgICAgKiAgICAgICBpZiAoZXJyKSB7XG4gICAgICogICAgICAgICAvLyB0aGUgY2xpZW50IGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgfSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gbm90ZTogaWYgcG9zc2libGUsIHVzaW5nIGEgcm9vbSBpbnN0ZWFkIG9mIGxvb3Bpbmcgb3ZlciBhbGwgc29ja2V0cyBpcyBwcmVmZXJhYmxlXG4gICAgICogaW8udGltZW91dCgxMDAwKS50byhzb21lQ29uZGl0aW9uUm9vbSkuZW1pdChcInNvbWUtZXZlbnRcIiwgKGVyciwgcmVzcG9uc2VzKSA9PiB7XG4gICAgICogICAvLyAuLi5cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lb3V0XG4gICAgICovXG4gICAgdGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdG9yLnRpbWVvdXQodGltZW91dCk7XG4gICAgfVxuICAgIGVtaXQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3IuZW1pdChldiwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpvaW5zIGEgcm9vbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSByb29tIC0gcm9vbSBvciBhcnJheSBvZiByb29tc1xuICAgICAqL1xuICAgIGpvaW4ocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvci5zb2NrZXRzSm9pbihyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGVhdmVzIGEgcm9vbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByb29tXG4gICAgICovXG4gICAgbGVhdmUocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvci5zb2NrZXRzTGVhdmUocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIHRoaXMgY2xpZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjbG9zZSAtIGlmIGB0cnVlYCwgY2xvc2VzIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KGNsb3NlID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5vcGVyYXRvci5kaXNjb25uZWN0U29ja2V0cyhjbG9zZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVtb3RlU29ja2V0ID0gUmVtb3RlU29ja2V0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/socket.io/dist/broadcast-operator.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/socket.io/dist/client.js":
/*!***********************************************!*\
  !*** ./node_modules/socket.io/dist/client.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Client = void 0;\nconst socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ \"(action-browser)/./node_modules/socket.io-parser/build/cjs/index.js\");\nconst debugModule = __webpack_require__(/*! debug */ \"(action-browser)/./node_modules/socket.io/node_modules/debug/src/index.js\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst debug = debugModule(\"socket.io:client\");\nclass Client {\n    /**\n     * Client constructor.\n     *\n     * @param server instance\n     * @param conn\n     * @package\n     */\n    constructor(server, conn) {\n        this.sockets = new Map();\n        this.nsps = new Map();\n        this.server = server;\n        this.conn = conn;\n        this.encoder = server.encoder;\n        this.decoder = new server._parser.Decoder();\n        this.id = conn.id;\n        this.setup();\n    }\n    /**\n     * @return the reference to the request that originated the Engine.IO connection\n     *\n     * @public\n     */\n    get request() {\n        return this.conn.request;\n    }\n    /**\n     * Sets up event listeners.\n     *\n     * @private\n     */\n    setup() {\n        this.onclose = this.onclose.bind(this);\n        this.ondata = this.ondata.bind(this);\n        this.onerror = this.onerror.bind(this);\n        this.ondecoded = this.ondecoded.bind(this);\n        // @ts-ignore\n        this.decoder.on(\"decoded\", this.ondecoded);\n        this.conn.on(\"data\", this.ondata);\n        this.conn.on(\"error\", this.onerror);\n        this.conn.on(\"close\", this.onclose);\n        this.connectTimeout = setTimeout(() => {\n            if (this.nsps.size === 0) {\n                debug(\"no namespace joined yet, close the client\");\n                this.close();\n            }\n            else {\n                debug(\"the client has already joined a namespace, nothing to do\");\n            }\n        }, this.server._connectTimeout);\n    }\n    /**\n     * Connects a client to a namespace.\n     *\n     * @param {String} name - the namespace\n     * @param {Object} auth - the auth parameters\n     * @private\n     */\n    connect(name, auth = {}) {\n        if (this.server._nsps.has(name)) {\n            debug(\"connecting to namespace %s\", name);\n            return this.doConnect(name, auth);\n        }\n        this.server._checkNamespace(name, auth, (dynamicNspName) => {\n            if (dynamicNspName) {\n                this.doConnect(name, auth);\n            }\n            else {\n                debug(\"creation of namespace %s was denied\", name);\n                this._packet({\n                    type: socket_io_parser_1.PacketType.CONNECT_ERROR,\n                    nsp: name,\n                    data: {\n                        message: \"Invalid namespace\",\n                    },\n                });\n            }\n        });\n    }\n    /**\n     * Connects a client to a namespace.\n     *\n     * @param name - the namespace\n     * @param {Object} auth - the auth parameters\n     *\n     * @private\n     */\n    doConnect(name, auth) {\n        const nsp = this.server.of(name);\n        nsp._add(this, auth, (socket) => {\n            this.sockets.set(socket.id, socket);\n            this.nsps.set(nsp.name, socket);\n            if (this.connectTimeout) {\n                clearTimeout(this.connectTimeout);\n                this.connectTimeout = undefined;\n            }\n        });\n    }\n    /**\n     * Disconnects from all namespaces and closes transport.\n     *\n     * @private\n     */\n    _disconnect() {\n        for (const socket of this.sockets.values()) {\n            socket.disconnect();\n        }\n        this.sockets.clear();\n        this.close();\n    }\n    /**\n     * Removes a socket. Called by each `Socket`.\n     *\n     * @private\n     */\n    _remove(socket) {\n        if (this.sockets.has(socket.id)) {\n            const nsp = this.sockets.get(socket.id).nsp.name;\n            this.sockets.delete(socket.id);\n            this.nsps.delete(nsp);\n        }\n        else {\n            debug(\"ignoring remove for %s\", socket.id);\n        }\n    }\n    /**\n     * Closes the underlying connection.\n     *\n     * @private\n     */\n    close() {\n        if (\"open\" === this.conn.readyState) {\n            debug(\"forcing transport close\");\n            this.conn.close();\n            this.onclose(\"forced server close\");\n        }\n    }\n    /**\n     * Writes a packet to the transport.\n     *\n     * @param {Object} packet object\n     * @param {Object} opts\n     * @private\n     */\n    _packet(packet, opts = {}) {\n        if (this.conn.readyState !== \"open\") {\n            debug(\"ignoring packet write %j\", packet);\n            return;\n        }\n        const encodedPackets = opts.preEncoded\n            ? packet // previous versions of the adapter incorrectly used socket.packet() instead of writeToEngine()\n            : this.encoder.encode(packet);\n        this.writeToEngine(encodedPackets, opts);\n    }\n    writeToEngine(encodedPackets, opts) {\n        if (opts.volatile && !this.conn.transport.writable) {\n            debug(\"volatile packet is discarded since the transport is not currently writable\");\n            return;\n        }\n        const packets = Array.isArray(encodedPackets)\n            ? encodedPackets\n            : [encodedPackets];\n        for (const encodedPacket of packets) {\n            this.conn.write(encodedPacket, opts);\n        }\n    }\n    /**\n     * Called with incoming transport data.\n     *\n     * @private\n     */\n    ondata(data) {\n        // try/catch is needed for protocol violations (GH-1880)\n        try {\n            this.decoder.add(data);\n        }\n        catch (e) {\n            debug(\"invalid packet format\");\n            this.onerror(e);\n        }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        let namespace;\n        let authPayload;\n        if (this.conn.protocol === 3) {\n            const parsed = url.parse(packet.nsp, true);\n            namespace = parsed.pathname;\n            authPayload = parsed.query;\n        }\n        else {\n            namespace = packet.nsp;\n            authPayload = packet.data;\n        }\n        const socket = this.nsps.get(namespace);\n        if (!socket && packet.type === socket_io_parser_1.PacketType.CONNECT) {\n            this.connect(namespace, authPayload);\n        }\n        else if (socket &&\n            packet.type !== socket_io_parser_1.PacketType.CONNECT &&\n            packet.type !== socket_io_parser_1.PacketType.CONNECT_ERROR) {\n            process.nextTick(function () {\n                socket._onpacket(packet);\n            });\n        }\n        else {\n            debug(\"invalid state (packet type: %s)\", packet.type);\n            this.close();\n        }\n    }\n    /**\n     * Handles an error.\n     *\n     * @param {Object} err object\n     * @private\n     */\n    onerror(err) {\n        for (const socket of this.sockets.values()) {\n            socket._onerror(err);\n        }\n        this.conn.close();\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @param reason\n     * @param description\n     * @private\n     */\n    onclose(reason, description) {\n        debug(\"client close with reason %s\", reason);\n        // ignore a potential subsequent `close` event\n        this.destroy();\n        // `nsps` and `sockets` are cleaned up seamlessly\n        for (const socket of this.sockets.values()) {\n            socket._onclose(reason, description);\n        }\n        this.sockets.clear();\n        this.decoder.destroy(); // clean up decoder\n    }\n    /**\n     * Cleans up event listeners.\n     * @private\n     */\n    destroy() {\n        this.conn.removeListener(\"data\", this.ondata);\n        this.conn.removeListener(\"error\", this.onerror);\n        this.conn.removeListener(\"close\", this.onclose);\n        // @ts-ignore\n        this.decoder.removeListener(\"decoded\", this.ondecoded);\n        if (this.connectTimeout) {\n            clearTimeout(this.connectTimeout);\n            this.connectTimeout = undefined;\n        }\n    }\n}\nexports.Client = Client;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLDJCQUEyQixtQkFBTyxDQUFDLDZGQUFrQjtBQUNyRCxvQkFBb0IsbUJBQU8sQ0FBQyx3RkFBTztBQUNuQyxZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcnNvbGUvRG9jdW1lbnRzL0dpdEh1Yi9tYXNzaW1pbm8vbWFzc2ltaW5vL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9jbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsaWVudCA9IHZvaWQgMDtcbmNvbnN0IHNvY2tldF9pb19wYXJzZXJfMSA9IHJlcXVpcmUoXCJzb2NrZXQuaW8tcGFyc2VyXCIpO1xuY29uc3QgZGVidWdNb2R1bGUgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCB1cmwgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcInNvY2tldC5pbzpjbGllbnRcIik7XG5jbGFzcyBDbGllbnQge1xuICAgIC8qKlxuICAgICAqIENsaWVudCBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXJ2ZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gY29ublxuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2VydmVyLCBjb25uKSB7XG4gICAgICAgIHRoaXMuc29ja2V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5uc3BzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgdGhpcy5jb25uID0gY29ubjtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gc2VydmVyLmVuY29kZXI7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBzZXJ2ZXIuX3BhcnNlci5EZWNvZGVyKCk7XG4gICAgICAgIHRoaXMuaWQgPSBjb25uLmlkO1xuICAgICAgICB0aGlzLnNldHVwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gdGhlIHJlZmVyZW5jZSB0byB0aGUgcmVxdWVzdCB0aGF0IG9yaWdpbmF0ZWQgdGhlIEVuZ2luZS5JTyBjb25uZWN0aW9uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0IHJlcXVlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm4ucmVxdWVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNldHVwKCkge1xuICAgICAgICB0aGlzLm9uY2xvc2UgPSB0aGlzLm9uY2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSB0aGlzLm9uZGF0YS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbmRlY29kZWQgPSB0aGlzLm9uZGVjb2RlZC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuZGVjb2Rlci5vbihcImRlY29kZWRcIiwgdGhpcy5vbmRlY29kZWQpO1xuICAgICAgICB0aGlzLmNvbm4ub24oXCJkYXRhXCIsIHRoaXMub25kYXRhKTtcbiAgICAgICAgdGhpcy5jb25uLm9uKFwiZXJyb3JcIiwgdGhpcy5vbmVycm9yKTtcbiAgICAgICAgdGhpcy5jb25uLm9uKFwiY2xvc2VcIiwgdGhpcy5vbmNsb3NlKTtcbiAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMubnNwcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJubyBuYW1lc3BhY2Ugam9pbmVkIHlldCwgY2xvc2UgdGhlIGNsaWVudFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInRoZSBjbGllbnQgaGFzIGFscmVhZHkgam9pbmVkIGEgbmFtZXNwYWNlLCBub3RoaW5nIHRvIGRvXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLnNlcnZlci5fY29ubmVjdFRpbWVvdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0cyBhIGNsaWVudCB0byBhIG5hbWVzcGFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gdGhlIG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdXRoIC0gdGhlIGF1dGggcGFyYW1ldGVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29ubmVjdChuYW1lLCBhdXRoID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyLl9uc3BzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgZGVidWcoXCJjb25uZWN0aW5nIHRvIG5hbWVzcGFjZSAlc1wiLCBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvQ29ubmVjdChuYW1lLCBhdXRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcnZlci5fY2hlY2tOYW1lc3BhY2UobmFtZSwgYXV0aCwgKGR5bmFtaWNOc3BOYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoZHluYW1pY05zcE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ29ubmVjdChuYW1lLCBhdXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiY3JlYXRpb24gb2YgbmFtZXNwYWNlICVzIHdhcyBkZW5pZWRcIiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFja2V0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQ09OTkVDVF9FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgbnNwOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgbmFtZXNwYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0cyBhIGNsaWVudCB0byBhIG5hbWVzcGFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdXRoIC0gdGhlIGF1dGggcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkb0Nvbm5lY3QobmFtZSwgYXV0aCkge1xuICAgICAgICBjb25zdCBuc3AgPSB0aGlzLnNlcnZlci5vZihuYW1lKTtcbiAgICAgICAgbnNwLl9hZGQodGhpcywgYXV0aCwgKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXRzLnNldChzb2NrZXQuaWQsIHNvY2tldCk7XG4gICAgICAgICAgICB0aGlzLm5zcHMuc2V0KG5zcC5uYW1lLCBzb2NrZXQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIGZyb20gYWxsIG5hbWVzcGFjZXMgYW5kIGNsb3NlcyB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kaXNjb25uZWN0KCkge1xuICAgICAgICBmb3IgKGNvbnN0IHNvY2tldCBvZiB0aGlzLnNvY2tldHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb2NrZXRzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHNvY2tldC4gQ2FsbGVkIGJ5IGVhY2ggYFNvY2tldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmUoc29ja2V0KSB7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldHMuaGFzKHNvY2tldC5pZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5zcCA9IHRoaXMuc29ja2V0cy5nZXQoc29ja2V0LmlkKS5uc3AubmFtZTtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0cy5kZWxldGUoc29ja2V0LmlkKTtcbiAgICAgICAgICAgIHRoaXMubnNwcy5kZWxldGUobnNwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKFwiaWdub3JpbmcgcmVtb3ZlIGZvciAlc1wiLCBzb2NrZXQuaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKFwib3BlblwiID09PSB0aGlzLmNvbm4ucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgZGVidWcoXCJmb3JjaW5nIHRyYW5zcG9ydCBjbG9zZVwiKTtcbiAgICAgICAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5vbmNsb3NlKFwiZm9yY2VkIHNlcnZlciBjbG9zZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBwYWNrZXQgdG8gdGhlIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wYWNrZXQocGFja2V0LCBvcHRzID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubi5yZWFkeVN0YXRlICE9PSBcIm9wZW5cIikge1xuICAgICAgICAgICAgZGVidWcoXCJpZ25vcmluZyBwYWNrZXQgd3JpdGUgJWpcIiwgcGFja2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmNvZGVkUGFja2V0cyA9IG9wdHMucHJlRW5jb2RlZFxuICAgICAgICAgICAgPyBwYWNrZXQgLy8gcHJldmlvdXMgdmVyc2lvbnMgb2YgdGhlIGFkYXB0ZXIgaW5jb3JyZWN0bHkgdXNlZCBzb2NrZXQucGFja2V0KCkgaW5zdGVhZCBvZiB3cml0ZVRvRW5naW5lKClcbiAgICAgICAgICAgIDogdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQpO1xuICAgICAgICB0aGlzLndyaXRlVG9FbmdpbmUoZW5jb2RlZFBhY2tldHMsIG9wdHMpO1xuICAgIH1cbiAgICB3cml0ZVRvRW5naW5lKGVuY29kZWRQYWNrZXRzLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzLnZvbGF0aWxlICYmICF0aGlzLmNvbm4udHJhbnNwb3J0LndyaXRhYmxlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInZvbGF0aWxlIHBhY2tldCBpcyBkaXNjYXJkZWQgc2luY2UgdGhlIHRyYW5zcG9ydCBpcyBub3QgY3VycmVudGx5IHdyaXRhYmxlXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhY2tldHMgPSBBcnJheS5pc0FycmF5KGVuY29kZWRQYWNrZXRzKVxuICAgICAgICAgICAgPyBlbmNvZGVkUGFja2V0c1xuICAgICAgICAgICAgOiBbZW5jb2RlZFBhY2tldHNdO1xuICAgICAgICBmb3IgKGNvbnN0IGVuY29kZWRQYWNrZXQgb2YgcGFja2V0cykge1xuICAgICAgICAgICAgdGhpcy5jb25uLndyaXRlKGVuY29kZWRQYWNrZXQsIG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIGluY29taW5nIHRyYW5zcG9ydCBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmRhdGEoZGF0YSkge1xuICAgICAgICAvLyB0cnkvY2F0Y2ggaXMgbmVlZGVkIGZvciBwcm90b2NvbCB2aW9sYXRpb25zIChHSC0xODgwKVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVyLmFkZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZGVidWcoXCJpbnZhbGlkIHBhY2tldCBmb3JtYXRcIik7XG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gcGFyc2VyIGZ1bGx5IGRlY29kZXMgYSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZGVjb2RlZChwYWNrZXQpIHtcbiAgICAgICAgbGV0IG5hbWVzcGFjZTtcbiAgICAgICAgbGV0IGF1dGhQYXlsb2FkO1xuICAgICAgICBpZiAodGhpcy5jb25uLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSB1cmwucGFyc2UocGFja2V0Lm5zcCwgdHJ1ZSk7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICBhdXRoUGF5bG9hZCA9IHBhcnNlZC5xdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IHBhY2tldC5uc3A7XG4gICAgICAgICAgICBhdXRoUGF5bG9hZCA9IHBhY2tldC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubnNwcy5nZXQobmFtZXNwYWNlKTtcbiAgICAgICAgaWYgKCFzb2NrZXQgJiYgcGFja2V0LnR5cGUgPT09IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkNPTk5FQ1QpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdChuYW1lc3BhY2UsIGF1dGhQYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzb2NrZXQgJiZcbiAgICAgICAgICAgIHBhY2tldC50eXBlICE9PSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNUICYmXG4gICAgICAgICAgICBwYWNrZXQudHlwZSAhPT0gc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQ09OTkVDVF9FUlJPUikge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0Ll9vbnBhY2tldChwYWNrZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImludmFsaWQgc3RhdGUgKHBhY2tldCB0eXBlOiAlcylcIiwgcGFja2V0LnR5cGUpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXJyIG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25lcnJvcihlcnIpIHtcbiAgICAgICAgZm9yIChjb25zdCBzb2NrZXQgb2YgdGhpcy5zb2NrZXRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBzb2NrZXQuX29uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm4uY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlYXNvblxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25jbG9zZShyZWFzb24sIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGRlYnVnKFwiY2xpZW50IGNsb3NlIHdpdGggcmVhc29uICVzXCIsIHJlYXNvbik7XG4gICAgICAgIC8vIGlnbm9yZSBhIHBvdGVudGlhbCBzdWJzZXF1ZW50IGBjbG9zZWAgZXZlbnRcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIC8vIGBuc3BzYCBhbmQgYHNvY2tldHNgIGFyZSBjbGVhbmVkIHVwIHNlYW1sZXNzbHlcbiAgICAgICAgZm9yIChjb25zdCBzb2NrZXQgb2YgdGhpcy5zb2NrZXRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBzb2NrZXQuX29uY2xvc2UocmVhc29uLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb2NrZXRzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7IC8vIGNsZWFuIHVwIGRlY29kZXJcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY29ubi5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIiwgdGhpcy5vbmRhdGEpO1xuICAgICAgICB0aGlzLmNvbm4ucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLm9uZXJyb3IpO1xuICAgICAgICB0aGlzLmNvbm4ucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCB0aGlzLm9uY2xvc2UpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuZGVjb2Rlci5yZW1vdmVMaXN0ZW5lcihcImRlY29kZWRcIiwgdGhpcy5vbmRlY29kZWQpO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0VGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50ID0gQ2xpZW50O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/socket.io/dist/client.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/socket.io/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/socket.io/dist/index.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Namespace = exports.Socket = exports.Server = void 0;\nconst http = __webpack_require__(/*! http */ \"http\");\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst zlib_1 = __webpack_require__(/*! zlib */ \"zlib\");\nconst accepts = __webpack_require__(/*! accepts */ \"(action-browser)/./node_modules/accepts/index.js\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst engine_io_1 = __webpack_require__(/*! engine.io */ \"(action-browser)/./node_modules/engine.io/build/engine.io.js\");\nconst client_1 = __webpack_require__(/*! ./client */ \"(action-browser)/./node_modules/socket.io/dist/client.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst namespace_1 = __webpack_require__(/*! ./namespace */ \"(action-browser)/./node_modules/socket.io/dist/namespace.js\");\nObject.defineProperty(exports, \"Namespace\", ({ enumerable: true, get: function () { return namespace_1.Namespace; } }));\nconst parent_namespace_1 = __webpack_require__(/*! ./parent-namespace */ \"(action-browser)/./node_modules/socket.io/dist/parent-namespace.js\");\nconst socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ \"(action-browser)/./node_modules/socket.io-adapter/dist/index.js\");\nconst parser = __importStar(__webpack_require__(/*! socket.io-parser */ \"(action-browser)/./node_modules/socket.io-parser/build/cjs/index.js\"));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(action-browser)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst socket_1 = __webpack_require__(/*! ./socket */ \"(action-browser)/./node_modules/socket.io/dist/socket.js\");\nObject.defineProperty(exports, \"Socket\", ({ enumerable: true, get: function () { return socket_1.Socket; } }));\nconst typed_events_1 = __webpack_require__(/*! ./typed-events */ \"(action-browser)/./node_modules/socket.io/dist/typed-events.js\");\nconst uws_1 = __webpack_require__(/*! ./uws */ \"(action-browser)/./node_modules/socket.io/dist/uws.js\");\nconst cors_1 = __importDefault(__webpack_require__(/*! cors */ \"(action-browser)/./node_modules/cors/lib/index.js\"));\nconst debug = (0, debug_1.default)(\"socket.io:server\");\nconst clientVersion = (__webpack_require__(/*! ../package.json */ \"(action-browser)/./node_modules/socket.io/package.json\").version);\nconst dotMapRegex = /\\.map/;\n/**\n * Represents a Socket.IO server.\n *\n * @example\n * import { Server } from \"socket.io\";\n *\n * const io = new Server();\n *\n * io.on(\"connection\", (socket) => {\n *   console.log(`socket ${socket.id} connected`);\n *\n *   // send an event to the client\n *   socket.emit(\"foo\", \"bar\");\n *\n *   socket.on(\"foobar\", () => {\n *     // an event was received from the client\n *   });\n *\n *   // upon disconnection\n *   socket.on(\"disconnect\", (reason) => {\n *     console.log(`socket ${socket.id} disconnected due to ${reason}`);\n *   });\n * });\n *\n * io.listen(3000);\n */\nclass Server extends typed_events_1.StrictEventEmitter {\n    constructor(srv, opts = {}) {\n        super();\n        /**\n         * @private\n         */\n        this._nsps = new Map();\n        this.parentNsps = new Map();\n        /**\n         * A subset of the {@link parentNsps} map, only containing {@link ParentNamespace} which are based on a regular\n         * expression.\n         *\n         * @private\n         */\n        this.parentNamespacesFromRegExp = new Map();\n        if (\"object\" === typeof srv &&\n            srv instanceof Object &&\n            !srv.listen) {\n            opts = srv;\n            srv = undefined;\n        }\n        this.path(opts.path || \"/socket.io\");\n        this.connectTimeout(opts.connectTimeout || 45000);\n        this.serveClient(false !== opts.serveClient);\n        this._parser = opts.parser || parser;\n        this.encoder = new this._parser.Encoder();\n        this.opts = opts;\n        if (opts.connectionStateRecovery) {\n            opts.connectionStateRecovery = Object.assign({\n                maxDisconnectionDuration: 2 * 60 * 1000,\n                skipMiddlewares: true,\n            }, opts.connectionStateRecovery);\n            this.adapter(opts.adapter || socket_io_adapter_1.SessionAwareAdapter);\n        }\n        else {\n            this.adapter(opts.adapter || socket_io_adapter_1.Adapter);\n        }\n        opts.cleanupEmptyChildNamespaces = !!opts.cleanupEmptyChildNamespaces;\n        this.sockets = this.of(\"/\");\n        if (srv || typeof srv == \"number\")\n            this.attach(srv);\n        if (this.opts.cors) {\n            this._corsMiddleware = (0, cors_1.default)(this.opts.cors);\n        }\n    }\n    get _opts() {\n        return this.opts;\n    }\n    serveClient(v) {\n        if (!arguments.length)\n            return this._serveClient;\n        this._serveClient = v;\n        return this;\n    }\n    /**\n     * Executes the middleware for an incoming namespace not already created on the server.\n     *\n     * @param name - name of incoming namespace\n     * @param auth - the auth parameters\n     * @param fn - callback\n     *\n     * @private\n     */\n    _checkNamespace(name, auth, fn) {\n        if (this.parentNsps.size === 0)\n            return fn(false);\n        const keysIterator = this.parentNsps.keys();\n        const run = () => {\n            const nextFn = keysIterator.next();\n            if (nextFn.done) {\n                return fn(false);\n            }\n            nextFn.value(name, auth, (err, allow) => {\n                if (err || !allow) {\n                    return run();\n                }\n                if (this._nsps.has(name)) {\n                    // the namespace was created in the meantime\n                    debug(\"dynamic namespace %s already exists\", name);\n                    return fn(this._nsps.get(name));\n                }\n                const namespace = this.parentNsps.get(nextFn.value).createChild(name);\n                debug(\"dynamic namespace %s was created\", name);\n                fn(namespace);\n            });\n        };\n        run();\n    }\n    path(v) {\n        if (!arguments.length)\n            return this._path;\n        this._path = v.replace(/\\/$/, \"\");\n        const escapedPath = this._path.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n        this.clientPathRegex = new RegExp(\"^\" +\n            escapedPath +\n            \"/socket\\\\.io(\\\\.msgpack|\\\\.esm)?(\\\\.min)?\\\\.js(\\\\.map)?(?:\\\\?|$)\");\n        return this;\n    }\n    connectTimeout(v) {\n        if (v === undefined)\n            return this._connectTimeout;\n        this._connectTimeout = v;\n        return this;\n    }\n    adapter(v) {\n        if (!arguments.length)\n            return this._adapter;\n        this._adapter = v;\n        for (const nsp of this._nsps.values()) {\n            nsp._initAdapter();\n        }\n        return this;\n    }\n    /**\n     * Attaches socket.io to a server or port.\n     *\n     * @param srv - server or port\n     * @param opts - options passed to engine.io\n     * @return self\n     */\n    listen(srv, opts = {}) {\n        return this.attach(srv, opts);\n    }\n    /**\n     * Attaches socket.io to a server or port.\n     *\n     * @param srv - server or port\n     * @param opts - options passed to engine.io\n     * @return self\n     */\n    attach(srv, opts = {}) {\n        if (\"function\" == typeof srv) {\n            const msg = \"You are trying to attach socket.io to an express \" +\n                \"request handler function. Please pass a http.Server instance.\";\n            throw new Error(msg);\n        }\n        // handle a port as a string\n        if (Number(srv) == srv) {\n            srv = Number(srv);\n        }\n        if (\"number\" == typeof srv) {\n            debug(\"creating http server and binding to %d\", srv);\n            const port = srv;\n            srv = http.createServer((req, res) => {\n                res.writeHead(404);\n                res.end();\n            });\n            srv.listen(port);\n        }\n        // merge the options passed to the Socket.IO server\n        Object.assign(opts, this.opts);\n        // set engine.io path to `/socket.io`\n        opts.path = opts.path || this._path;\n        this.initEngine(srv, opts);\n        return this;\n    }\n    attachApp(app /*: TemplatedApp */, opts = {}) {\n        // merge the options passed to the Socket.IO server\n        Object.assign(opts, this.opts);\n        // set engine.io path to `/socket.io`\n        opts.path = opts.path || this._path;\n        // initialize engine\n        debug(\"creating uWebSockets.js-based engine with opts %j\", opts);\n        const engine = new engine_io_1.uServer(opts);\n        engine.attach(app, opts);\n        // bind to engine events\n        this.bind(engine);\n        if (this._serveClient) {\n            // attach static file serving\n            app.get(`${this._path}/*`, (res, req) => {\n                if (!this.clientPathRegex.test(req.getUrl())) {\n                    req.setYield(true);\n                    return;\n                }\n                const filename = req\n                    .getUrl()\n                    .replace(this._path, \"\")\n                    .replace(/\\?.*$/, \"\")\n                    .replace(/^\\//, \"\");\n                const isMap = dotMapRegex.test(filename);\n                const type = isMap ? \"map\" : \"source\";\n                // Per the standard, ETags must be quoted:\n                // https://tools.ietf.org/html/rfc7232#section-2.3\n                const expectedEtag = '\"' + clientVersion + '\"';\n                const weakEtag = \"W/\" + expectedEtag;\n                const etag = req.getHeader(\"if-none-match\");\n                if (etag) {\n                    if (expectedEtag === etag || weakEtag === etag) {\n                        debug(\"serve client %s 304\", type);\n                        res.writeStatus(\"304 Not Modified\");\n                        res.end();\n                        return;\n                    }\n                }\n                debug(\"serve client %s\", type);\n                res.writeHeader(\"cache-control\", \"public, max-age=0\");\n                res.writeHeader(\"content-type\", \"application/\" + (isMap ? \"json\" : \"javascript\") + \"; charset=utf-8\");\n                res.writeHeader(\"etag\", expectedEtag);\n                const filepath = path.join(__dirname, \"../client-dist/\", filename);\n                (0, uws_1.serveFile)(res, filepath);\n            });\n        }\n        (0, uws_1.patchAdapter)(app);\n    }\n    /**\n     * Initialize engine\n     *\n     * @param srv - the server to attach to\n     * @param opts - options passed to engine.io\n     * @private\n     */\n    initEngine(srv, opts) {\n        // initialize engine\n        debug(\"creating engine.io instance with opts %j\", opts);\n        this.eio = (0, engine_io_1.attach)(srv, opts);\n        // attach static file serving\n        if (this._serveClient)\n            this.attachServe(srv);\n        // Export http server\n        this.httpServer = srv;\n        // bind to engine events\n        this.bind(this.eio);\n    }\n    /**\n     * Attaches the static file serving.\n     *\n     * @param srv http server\n     * @private\n     */\n    attachServe(srv) {\n        debug(\"attaching client serving req handler\");\n        const evs = srv.listeners(\"request\").slice(0);\n        srv.removeAllListeners(\"request\");\n        srv.on(\"request\", (req, res) => {\n            if (this.clientPathRegex.test(req.url)) {\n                if (this._corsMiddleware) {\n                    this._corsMiddleware(req, res, () => {\n                        this.serve(req, res);\n                    });\n                }\n                else {\n                    this.serve(req, res);\n                }\n            }\n            else {\n                for (let i = 0; i < evs.length; i++) {\n                    evs[i].call(srv, req, res);\n                }\n            }\n        });\n    }\n    /**\n     * Handles a request serving of client source and map\n     *\n     * @param req\n     * @param res\n     * @private\n     */\n    serve(req, res) {\n        const filename = req.url.replace(this._path, \"\").replace(/\\?.*$/, \"\");\n        const isMap = dotMapRegex.test(filename);\n        const type = isMap ? \"map\" : \"source\";\n        // Per the standard, ETags must be quoted:\n        // https://tools.ietf.org/html/rfc7232#section-2.3\n        const expectedEtag = '\"' + clientVersion + '\"';\n        const weakEtag = \"W/\" + expectedEtag;\n        const etag = req.headers[\"if-none-match\"];\n        if (etag) {\n            if (expectedEtag === etag || weakEtag === etag) {\n                debug(\"serve client %s 304\", type);\n                res.writeHead(304);\n                res.end();\n                return;\n            }\n        }\n        debug(\"serve client %s\", type);\n        res.setHeader(\"Cache-Control\", \"public, max-age=0\");\n        res.setHeader(\"Content-Type\", \"application/\" + (isMap ? \"json\" : \"javascript\") + \"; charset=utf-8\");\n        res.setHeader(\"ETag\", expectedEtag);\n        Server.sendFile(filename, req, res);\n    }\n    /**\n     * @param filename\n     * @param req\n     * @param res\n     * @private\n     */\n    static sendFile(filename, req, res) {\n        const readStream = (0, fs_1.createReadStream)(path.join(__dirname, \"../client-dist/\", filename));\n        const encoding = accepts(req).encodings([\"br\", \"gzip\", \"deflate\"]);\n        const onError = (err) => {\n            if (err) {\n                res.end();\n            }\n        };\n        switch (encoding) {\n            case \"br\":\n                res.writeHead(200, { \"content-encoding\": \"br\" });\n                (0, stream_1.pipeline)(readStream, (0, zlib_1.createBrotliCompress)(), res, onError);\n                break;\n            case \"gzip\":\n                res.writeHead(200, { \"content-encoding\": \"gzip\" });\n                (0, stream_1.pipeline)(readStream, (0, zlib_1.createGzip)(), res, onError);\n                break;\n            case \"deflate\":\n                res.writeHead(200, { \"content-encoding\": \"deflate\" });\n                (0, stream_1.pipeline)(readStream, (0, zlib_1.createDeflate)(), res, onError);\n                break;\n            default:\n                res.writeHead(200);\n                (0, stream_1.pipeline)(readStream, res, onError);\n        }\n    }\n    /**\n     * Binds socket.io to an engine.io instance.\n     *\n     * @param engine engine.io (or compatible) server\n     * @return self\n     */\n    bind(engine) {\n        // TODO apply strict types to the engine: \"connection\" event, `close()` and a method to serve static content\n        //  this would allow to provide any custom engine, like one based on Deno or Bun built-in HTTP server\n        this.engine = engine;\n        this.engine.on(\"connection\", this.onconnection.bind(this));\n        return this;\n    }\n    /**\n     * Called with each incoming transport connection.\n     *\n     * @param {engine.Socket} conn\n     * @return self\n     * @private\n     */\n    onconnection(conn) {\n        debug(\"incoming connection with id %s\", conn.id);\n        const client = new client_1.Client(this, conn);\n        if (conn.protocol === 3) {\n            // @ts-ignore\n            client.connect(\"/\");\n        }\n        return this;\n    }\n    /**\n     * Looks up a namespace.\n     *\n     * @example\n     * // with a simple string\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // with a regex\n     * const dynamicNsp = io.of(/^\\/dynamic-\\d+$/).on(\"connection\", (socket) => {\n     *   const namespace = socket.nsp; // newNamespace.name === \"/dynamic-101\"\n     *\n     *   // broadcast to all clients in the given sub-namespace\n     *   namespace.emit(\"hello\");\n     * });\n     *\n     * @param name - nsp name\n     * @param fn optional, nsp `connection` ev handler\n     */\n    of(name, fn) {\n        if (typeof name === \"function\" || name instanceof RegExp) {\n            const parentNsp = new parent_namespace_1.ParentNamespace(this);\n            debug(\"initializing parent namespace %s\", parentNsp.name);\n            if (typeof name === \"function\") {\n                this.parentNsps.set(name, parentNsp);\n            }\n            else {\n                this.parentNsps.set((nsp, conn, next) => next(null, name.test(nsp)), parentNsp);\n                this.parentNamespacesFromRegExp.set(name, parentNsp);\n            }\n            if (fn) {\n                // @ts-ignore\n                parentNsp.on(\"connect\", fn);\n            }\n            return parentNsp;\n        }\n        if (String(name)[0] !== \"/\")\n            name = \"/\" + name;\n        let nsp = this._nsps.get(name);\n        if (!nsp) {\n            for (const [regex, parentNamespace] of this.parentNamespacesFromRegExp) {\n                if (regex.test(name)) {\n                    debug(\"attaching namespace %s to parent namespace %s\", name, regex);\n                    return parentNamespace.createChild(name);\n                }\n            }\n            debug(\"initializing namespace %s\", name);\n            nsp = new namespace_1.Namespace(this, name);\n            this._nsps.set(name, nsp);\n            if (name !== \"/\") {\n                // @ts-ignore\n                this.sockets.emitReserved(\"new_namespace\", nsp);\n            }\n        }\n        if (fn)\n            nsp.on(\"connect\", fn);\n        return nsp;\n    }\n    /**\n     * Closes server connection\n     *\n     * @param [fn] optional, called as `fn([err])` on error OR all conns closed\n     */\n    async close(fn) {\n        await Promise.allSettled([...this._nsps.values()].map(async (nsp) => {\n            nsp.sockets.forEach((socket) => {\n                socket._onclose(\"server shutting down\");\n            });\n            await nsp.adapter.close();\n        }));\n        this.engine.close();\n        // restore the Adapter prototype, when the Socket.IO server was attached to a uWebSockets.js server\n        (0, uws_1.restoreAdapter)();\n        if (this.httpServer) {\n            this.httpServer.close(fn);\n        }\n        else {\n            fn && fn();\n        }\n    }\n    /**\n     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.\n     *\n     * @example\n     * io.use((socket, next) => {\n     *   // ...\n     *   next();\n     * });\n     *\n     * @param fn - the middleware function\n     */\n    use(fn) {\n        this.sockets.use(fn);\n        return this;\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @example\n     * // the “foo” event will be broadcast to all connected clients in the “room-101” room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms (a client will be notified at most once)\n     * io.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    to(room) {\n        return this.sockets.to(room);\n    }\n    /**\n     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * // disconnect all clients in the \"room-101\" room\n     * io.in(\"room-101\").disconnectSockets();\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    in(room) {\n        return this.sockets.in(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @example\n     * // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     * io.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms\n     * io.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    except(room) {\n        return this.sockets.except(room);\n    }\n    /**\n     * Sends a `message` event to all clients.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * io.send(\"hello\");\n     *\n     * // this is equivalent to\n     * io.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */\n    send(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.sockets.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a `message` event to all clients. Alias of {@link send}.\n     *\n     * @return self\n     */\n    write(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.sockets.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a message to the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * io.serverSideEmit(\"hello\", \"world\");\n     *\n     * io.on(\"hello\", (arg1) => {\n     *   console.log(arg1); // prints \"world\"\n     * });\n     *\n     * // acknowledgements (without binary content) are supported too:\n     * io.serverSideEmit(\"ping\", (err, responses) => {\n     *  if (err) {\n     *     // some servers did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per server (except the current one)\n     *   }\n     * });\n     *\n     * io.on(\"ping\", (cb) => {\n     *   cb(\"pong\");\n     * });\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments, which may include an acknowledgement callback at the end\n     */\n    serverSideEmit(ev, ...args) {\n        return this.sockets.serverSideEmit(ev, ...args);\n    }\n    /**\n     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * try {\n     *   const responses = await io.serverSideEmitWithAck(\"ping\");\n     *   console.log(responses); // one response per server (except the current one)\n     * } catch (e) {\n     *   // some servers did not acknowledge the event in the given delay\n     * }\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments\n     *\n     * @return a Promise that will be fulfilled when all servers have acknowledged the event\n     */\n    serverSideEmitWithAck(ev, ...args) {\n        return this.sockets.serverSideEmitWithAck(ev, ...args);\n    }\n    /**\n     * Gets a list of socket ids.\n     *\n     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or\n     * {@link Server#fetchSockets} instead.\n     */\n    allSockets() {\n        return this.sockets.allSockets();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    compress(compress) {\n        return this.sockets.compress(compress);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.volatile.emit(\"hello\"); // the clients may or may not receive it\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    get volatile() {\n        return this.sockets.volatile;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * // the “foo” event will be broadcast to all connected clients on this node\n     * io.local.emit(\"foo\", \"bar\");\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    get local() {\n        return this.sockets.local;\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation.\n     *\n     * @example\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @param timeout\n     */\n    timeout(timeout) {\n        return this.sockets.timeout(timeout);\n    }\n    /**\n     * Returns the matching socket instances.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // return all Socket instances\n     * const sockets = await io.fetchSockets();\n     *\n     * // return all Socket instances in the \"room1\" room\n     * const sockets = await io.in(\"room1\").fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   console.log(socket.id);\n     *   console.log(socket.handshake);\n     *   console.log(socket.rooms);\n     *   console.log(socket.data);\n     *\n     *   socket.emit(\"hello\");\n     *   socket.join(\"room1\");\n     *   socket.leave(\"room2\");\n     *   socket.disconnect();\n     * }\n     */\n    fetchSockets() {\n        return this.sockets.fetchSockets();\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     *\n     * // make all socket instances join the \"room1\" room\n     * io.socketsJoin(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room join the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsJoin([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */\n    socketsJoin(room) {\n        return this.sockets.socketsJoin(room);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances leave the \"room1\" room\n     * io.socketsLeave(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room leave the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsLeave([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */\n    socketsLeave(room) {\n        return this.sockets.socketsLeave(room);\n    }\n    /**\n     * Makes the matching socket instances disconnect.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)\n     * io.disconnectSockets();\n     *\n     * // make all socket instances in the \"room1\" room disconnect and close the underlying connections\n     * io.in(\"room1\").disconnectSockets(true);\n     *\n     * @param close - whether to close the underlying connection\n     */\n    disconnectSockets(close = false) {\n        return this.sockets.disconnectSockets(close);\n    }\n}\nexports.Server = Server;\n/**\n * Expose main namespace (/).\n */\nconst emitterMethods = Object.keys(events_1.EventEmitter.prototype).filter(function (key) {\n    return typeof events_1.EventEmitter.prototype[key] === \"function\";\n});\nemitterMethods.forEach(function (fn) {\n    Server.prototype[fn] = function () {\n        return this.sockets[fn].apply(this.sockets, arguments);\n    };\n});\nmodule.exports = (srv, opts) => new Server(srv, opts);\nmodule.exports.Server = Server;\nmodule.exports.Namespace = namespace_1.Namespace;\nmodule.exports.Socket = socket_1.Socket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxjQUFjLEdBQUcsY0FBYztBQUNuRCxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsYUFBYSxtQkFBTyxDQUFDLGNBQUk7QUFDekIsZUFBZSxtQkFBTyxDQUFDLGtCQUFNO0FBQzdCLGdCQUFnQixtQkFBTyxDQUFDLGlFQUFTO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixvQkFBb0IsbUJBQU8sQ0FBQywrRUFBVztBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBVTtBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBYTtBQUN6Qyw2Q0FBNEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDckgsMkJBQTJCLG1CQUFPLENBQUMsOEZBQW9CO0FBQ3ZELDRCQUE0QixtQkFBTyxDQUFDLDBGQUFtQjtBQUN2RCw0QkFBNEIsbUJBQU8sQ0FBQyw2RkFBa0I7QUFDdEQsZ0NBQWdDLG1CQUFPLENBQUMsd0ZBQU87QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMsMEVBQVU7QUFDbkMsMENBQXlDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzVHLHVCQUF1QixtQkFBTyxDQUFDLHNGQUFnQjtBQUMvQyxjQUFjLG1CQUFPLENBQUMsb0VBQU87QUFDN0IsK0JBQStCLG1CQUFPLENBQUMsK0RBQU07QUFDN0M7QUFDQSxzQkFBc0IsOEdBQWtDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVcsc0JBQXNCLE9BQU87QUFDckUsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0Isc0JBQXNCLHVCQUF1QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwQkFBMEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDRCQUE0QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsK0JBQStCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFdBQVc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsbUNBQW1DO0FBQ25DO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRiw2QkFBNkI7QUFDbkgsUUFBUSwyQkFBMkI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsbUNBQW1DO0FBQ25DO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxjQUFjO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsY0FBYztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHLGNBQWM7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsY0FBYztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLHFCQUFxQiIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcnNvbGUvRG9jdW1lbnRzL0dpdEh1Yi9tYXNzaW1pbm8vbWFzc2ltaW5vL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OYW1lc3BhY2UgPSBleHBvcnRzLlNvY2tldCA9IGV4cG9ydHMuU2VydmVyID0gdm9pZCAwO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHpsaWJfMSA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuY29uc3QgYWNjZXB0cyA9IHJlcXVpcmUoXCJhY2NlcHRzXCIpO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgZW5naW5lX2lvXzEgPSByZXF1aXJlKFwiZW5naW5lLmlvXCIpO1xuY29uc3QgY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jbGllbnRcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBuYW1lc3BhY2VfMSA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVzcGFjZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmFtZXNwYWNlXzEuTmFtZXNwYWNlOyB9IH0pO1xuY29uc3QgcGFyZW50X25hbWVzcGFjZV8xID0gcmVxdWlyZShcIi4vcGFyZW50LW5hbWVzcGFjZVwiKTtcbmNvbnN0IHNvY2tldF9pb19hZGFwdGVyXzEgPSByZXF1aXJlKFwic29ja2V0LmlvLWFkYXB0ZXJcIik7XG5jb25zdCBwYXJzZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInNvY2tldC5pby1wYXJzZXJcIikpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3Qgc29ja2V0XzEgPSByZXF1aXJlKFwiLi9zb2NrZXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTb2NrZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvY2tldF8xLlNvY2tldDsgfSB9KTtcbmNvbnN0IHR5cGVkX2V2ZW50c18xID0gcmVxdWlyZShcIi4vdHlwZWQtZXZlbnRzXCIpO1xuY29uc3QgdXdzXzEgPSByZXF1aXJlKFwiLi91d3NcIik7XG5jb25zdCBjb3JzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNvcnNcIikpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcInNvY2tldC5pbzpzZXJ2ZXJcIik7XG5jb25zdCBjbGllbnRWZXJzaW9uID0gcmVxdWlyZShcIi4uL3BhY2thZ2UuanNvblwiKS52ZXJzaW9uO1xuY29uc3QgZG90TWFwUmVnZXggPSAvXFwubWFwLztcbi8qKlxuICogUmVwcmVzZW50cyBhIFNvY2tldC5JTyBzZXJ2ZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IFNlcnZlciB9IGZyb20gXCJzb2NrZXQuaW9cIjtcbiAqXG4gKiBjb25zdCBpbyA9IG5ldyBTZXJ2ZXIoKTtcbiAqXG4gKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICogICBjb25zb2xlLmxvZyhgc29ja2V0ICR7c29ja2V0LmlkfSBjb25uZWN0ZWRgKTtcbiAqXG4gKiAgIC8vIHNlbmQgYW4gZXZlbnQgdG8gdGhlIGNsaWVudFxuICogICBzb2NrZXQuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAqXG4gKiAgIHNvY2tldC5vbihcImZvb2JhclwiLCAoKSA9PiB7XG4gKiAgICAgLy8gYW4gZXZlbnQgd2FzIHJlY2VpdmVkIGZyb20gdGhlIGNsaWVudFxuICogICB9KTtcbiAqXG4gKiAgIC8vIHVwb24gZGlzY29ubmVjdGlvblxuICogICBzb2NrZXQub24oXCJkaXNjb25uZWN0XCIsIChyZWFzb24pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhgc29ja2V0ICR7c29ja2V0LmlkfSBkaXNjb25uZWN0ZWQgZHVlIHRvICR7cmVhc29ufWApO1xuICogICB9KTtcbiAqIH0pO1xuICpcbiAqIGlvLmxpc3RlbigzMDAwKTtcbiAqL1xuY2xhc3MgU2VydmVyIGV4dGVuZHMgdHlwZWRfZXZlbnRzXzEuU3RyaWN0RXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzcnYsIG9wdHMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX25zcHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGFyZW50TnNwcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc3Vic2V0IG9mIHRoZSB7QGxpbmsgcGFyZW50TnNwc30gbWFwLCBvbmx5IGNvbnRhaW5pbmcge0BsaW5rIFBhcmVudE5hbWVzcGFjZX0gd2hpY2ggYXJlIGJhc2VkIG9uIGEgcmVndWxhclxuICAgICAgICAgKiBleHByZXNzaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXJlbnROYW1lc3BhY2VzRnJvbVJlZ0V4cCA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBzcnYgJiZcbiAgICAgICAgICAgIHNydiBpbnN0YW5jZW9mIE9iamVjdCAmJlxuICAgICAgICAgICAgIXNydi5saXN0ZW4pIHtcbiAgICAgICAgICAgIG9wdHMgPSBzcnY7XG4gICAgICAgICAgICBzcnYgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXRoKG9wdHMucGF0aCB8fCBcIi9zb2NrZXQuaW9cIik7XG4gICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXQob3B0cy5jb25uZWN0VGltZW91dCB8fCA0NTAwMCk7XG4gICAgICAgIHRoaXMuc2VydmVDbGllbnQoZmFsc2UgIT09IG9wdHMuc2VydmVDbGllbnQpO1xuICAgICAgICB0aGlzLl9wYXJzZXIgPSBvcHRzLnBhcnNlciB8fCBwYXJzZXI7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IG5ldyB0aGlzLl9wYXJzZXIuRW5jb2RlcigpO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICBpZiAob3B0cy5jb25uZWN0aW9uU3RhdGVSZWNvdmVyeSkge1xuICAgICAgICAgICAgb3B0cy5jb25uZWN0aW9uU3RhdGVSZWNvdmVyeSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIG1heERpc2Nvbm5lY3Rpb25EdXJhdGlvbjogMiAqIDYwICogMTAwMCxcbiAgICAgICAgICAgICAgICBza2lwTWlkZGxld2FyZXM6IHRydWUsXG4gICAgICAgICAgICB9LCBvcHRzLmNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5KTtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlcihvcHRzLmFkYXB0ZXIgfHwgc29ja2V0X2lvX2FkYXB0ZXJfMS5TZXNzaW9uQXdhcmVBZGFwdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlcihvcHRzLmFkYXB0ZXIgfHwgc29ja2V0X2lvX2FkYXB0ZXJfMS5BZGFwdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRzLmNsZWFudXBFbXB0eUNoaWxkTmFtZXNwYWNlcyA9ICEhb3B0cy5jbGVhbnVwRW1wdHlDaGlsZE5hbWVzcGFjZXM7XG4gICAgICAgIHRoaXMuc29ja2V0cyA9IHRoaXMub2YoXCIvXCIpO1xuICAgICAgICBpZiAoc3J2IHx8IHR5cGVvZiBzcnYgPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoKHNydik7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuY29ycykge1xuICAgICAgICAgICAgdGhpcy5fY29yc01pZGRsZXdhcmUgPSAoMCwgY29yc18xLmRlZmF1bHQpKHRoaXMub3B0cy5jb3JzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgX29wdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdHM7XG4gICAgfVxuICAgIHNlcnZlQ2xpZW50KHYpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZlQ2xpZW50O1xuICAgICAgICB0aGlzLl9zZXJ2ZUNsaWVudCA9IHY7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgbWlkZGxld2FyZSBmb3IgYW4gaW5jb21pbmcgbmFtZXNwYWNlIG5vdCBhbHJlYWR5IGNyZWF0ZWQgb24gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gbmFtZSBvZiBpbmNvbWluZyBuYW1lc3BhY2VcbiAgICAgKiBAcGFyYW0gYXV0aCAtIHRoZSBhdXRoIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gZm4gLSBjYWxsYmFja1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hlY2tOYW1lc3BhY2UobmFtZSwgYXV0aCwgZm4pIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50TnNwcy5zaXplID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZuKGZhbHNlKTtcbiAgICAgICAgY29uc3Qga2V5c0l0ZXJhdG9yID0gdGhpcy5wYXJlbnROc3BzLmtleXMoKTtcbiAgICAgICAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV4dEZuID0ga2V5c0l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChuZXh0Rm4uZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0Rm4udmFsdWUobmFtZSwgYXV0aCwgKGVyciwgYWxsb3cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyIHx8ICFhbGxvdykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uc3BzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbmFtZXNwYWNlIHdhcyBjcmVhdGVkIGluIHRoZSBtZWFudGltZVxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImR5bmFtaWMgbmFtZXNwYWNlICVzIGFscmVhZHkgZXhpc3RzXCIsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4odGhpcy5fbnNwcy5nZXQobmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lc3BhY2UgPSB0aGlzLnBhcmVudE5zcHMuZ2V0KG5leHRGbi52YWx1ZSkuY3JlYXRlQ2hpbGQobmFtZSk7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJkeW5hbWljIG5hbWVzcGFjZSAlcyB3YXMgY3JlYXRlZFwiLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBmbihuYW1lc3BhY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJ1bigpO1xuICAgIH1cbiAgICBwYXRoKHYpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhdGg7XG4gICAgICAgIHRoaXMuX3BhdGggPSB2LnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgICAgICAgY29uc3QgZXNjYXBlZFBhdGggPSB0aGlzLl9wYXRoLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgXCJcXFxcJCZcIik7XG4gICAgICAgIHRoaXMuY2xpZW50UGF0aFJlZ2V4ID0gbmV3IFJlZ0V4cChcIl5cIiArXG4gICAgICAgICAgICBlc2NhcGVkUGF0aCArXG4gICAgICAgICAgICBcIi9zb2NrZXRcXFxcLmlvKFxcXFwubXNncGFja3xcXFxcLmVzbSk/KFxcXFwubWluKT9cXFxcLmpzKFxcXFwubWFwKT8oPzpcXFxcP3wkKVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbm5lY3RUaW1lb3V0KHYpIHtcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0VGltZW91dDtcbiAgICAgICAgdGhpcy5fY29ubmVjdFRpbWVvdXQgPSB2O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRhcHRlcih2KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGFwdGVyO1xuICAgICAgICB0aGlzLl9hZGFwdGVyID0gdjtcbiAgICAgICAgZm9yIChjb25zdCBuc3Agb2YgdGhpcy5fbnNwcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgbnNwLl9pbml0QWRhcHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBzb2NrZXQuaW8gdG8gYSBzZXJ2ZXIgb3IgcG9ydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzcnYgLSBzZXJ2ZXIgb3IgcG9ydFxuICAgICAqIEBwYXJhbSBvcHRzIC0gb3B0aW9ucyBwYXNzZWQgdG8gZW5naW5lLmlvXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgbGlzdGVuKHNydiwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dGFjaChzcnYsIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBzb2NrZXQuaW8gdG8gYSBzZXJ2ZXIgb3IgcG9ydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzcnYgLSBzZXJ2ZXIgb3IgcG9ydFxuICAgICAqIEBwYXJhbSBvcHRzIC0gb3B0aW9ucyBwYXNzZWQgdG8gZW5naW5lLmlvXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgYXR0YWNoKHNydiwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHNydikge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gXCJZb3UgYXJlIHRyeWluZyB0byBhdHRhY2ggc29ja2V0LmlvIHRvIGFuIGV4cHJlc3MgXCIgK1xuICAgICAgICAgICAgICAgIFwicmVxdWVzdCBoYW5kbGVyIGZ1bmN0aW9uLiBQbGVhc2UgcGFzcyBhIGh0dHAuU2VydmVyIGluc3RhbmNlLlwiO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIGEgcG9ydCBhcyBhIHN0cmluZ1xuICAgICAgICBpZiAoTnVtYmVyKHNydikgPT0gc3J2KSB7XG4gICAgICAgICAgICBzcnYgPSBOdW1iZXIoc3J2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2Ygc3J2KSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImNyZWF0aW5nIGh0dHAgc2VydmVyIGFuZCBiaW5kaW5nIHRvICVkXCIsIHNydik7XG4gICAgICAgICAgICBjb25zdCBwb3J0ID0gc3J2O1xuICAgICAgICAgICAgc3J2ID0gaHR0cC5jcmVhdGVTZXJ2ZXIoKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZCg0MDQpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3J2Lmxpc3Rlbihwb3J0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSB0aGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIFNvY2tldC5JTyBzZXJ2ZXJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLCB0aGlzLm9wdHMpO1xuICAgICAgICAvLyBzZXQgZW5naW5lLmlvIHBhdGggdG8gYC9zb2NrZXQuaW9gXG4gICAgICAgIG9wdHMucGF0aCA9IG9wdHMucGF0aCB8fCB0aGlzLl9wYXRoO1xuICAgICAgICB0aGlzLmluaXRFbmdpbmUoc3J2LCBvcHRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGF0dGFjaEFwcChhcHAgLyo6IFRlbXBsYXRlZEFwcCAqLywgb3B0cyA9IHt9KSB7XG4gICAgICAgIC8vIG1lcmdlIHRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgU29ja2V0LklPIHNlcnZlclxuICAgICAgICBPYmplY3QuYXNzaWduKG9wdHMsIHRoaXMub3B0cyk7XG4gICAgICAgIC8vIHNldCBlbmdpbmUuaW8gcGF0aCB0byBgL3NvY2tldC5pb2BcbiAgICAgICAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8IHRoaXMuX3BhdGg7XG4gICAgICAgIC8vIGluaXRpYWxpemUgZW5naW5lXG4gICAgICAgIGRlYnVnKFwiY3JlYXRpbmcgdVdlYlNvY2tldHMuanMtYmFzZWQgZW5naW5lIHdpdGggb3B0cyAlalwiLCBvcHRzKTtcbiAgICAgICAgY29uc3QgZW5naW5lID0gbmV3IGVuZ2luZV9pb18xLnVTZXJ2ZXIob3B0cyk7XG4gICAgICAgIGVuZ2luZS5hdHRhY2goYXBwLCBvcHRzKTtcbiAgICAgICAgLy8gYmluZCB0byBlbmdpbmUgZXZlbnRzXG4gICAgICAgIHRoaXMuYmluZChlbmdpbmUpO1xuICAgICAgICBpZiAodGhpcy5fc2VydmVDbGllbnQpIHtcbiAgICAgICAgICAgIC8vIGF0dGFjaCBzdGF0aWMgZmlsZSBzZXJ2aW5nXG4gICAgICAgICAgICBhcHAuZ2V0KGAke3RoaXMuX3BhdGh9LypgLCAocmVzLCByZXEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2xpZW50UGF0aFJlZ2V4LnRlc3QocmVxLmdldFVybCgpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXEuc2V0WWllbGQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSByZXFcbiAgICAgICAgICAgICAgICAgICAgLmdldFVybCgpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHRoaXMuX3BhdGgsIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXlxcLy8sIFwiXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzTWFwID0gZG90TWFwUmVnZXgudGVzdChmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGlzTWFwID8gXCJtYXBcIiA6IFwic291cmNlXCI7XG4gICAgICAgICAgICAgICAgLy8gUGVyIHRoZSBzdGFuZGFyZCwgRVRhZ3MgbXVzdCBiZSBxdW90ZWQ6XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzIjc2VjdGlvbi0yLjNcbiAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZEV0YWcgPSAnXCInICsgY2xpZW50VmVyc2lvbiArICdcIic7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2Vha0V0YWcgPSBcIlcvXCIgKyBleHBlY3RlZEV0YWc7XG4gICAgICAgICAgICAgICAgY29uc3QgZXRhZyA9IHJlcS5nZXRIZWFkZXIoXCJpZi1ub25lLW1hdGNoXCIpO1xuICAgICAgICAgICAgICAgIGlmIChldGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBlY3RlZEV0YWcgPT09IGV0YWcgfHwgd2Vha0V0YWcgPT09IGV0YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwic2VydmUgY2xpZW50ICVzIDMwNFwiLCB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy53cml0ZVN0YXR1cyhcIjMwNCBOb3QgTW9kaWZpZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVidWcoXCJzZXJ2ZSBjbGllbnQgJXNcIiwgdHlwZSk7XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZGVyKFwiY2FjaGUtY29udHJvbFwiLCBcInB1YmxpYywgbWF4LWFnZT0wXCIpO1xuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWRlcihcImNvbnRlbnQtdHlwZVwiLCBcImFwcGxpY2F0aW9uL1wiICsgKGlzTWFwID8gXCJqc29uXCIgOiBcImphdmFzY3JpcHRcIikgKyBcIjsgY2hhcnNldD11dGYtOFwiKTtcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkZXIoXCJldGFnXCIsIGV4cGVjdGVkRXRhZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZXBhdGggPSBwYXRoLmpvaW4oX19kaXJuYW1lLCBcIi4uL2NsaWVudC1kaXN0L1wiLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgKDAsIHV3c18xLnNlcnZlRmlsZSkocmVzLCBmaWxlcGF0aCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgdXdzXzEucGF0Y2hBZGFwdGVyKShhcHApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGVuZ2luZVxuICAgICAqXG4gICAgICogQHBhcmFtIHNydiAtIHRoZSBzZXJ2ZXIgdG8gYXR0YWNoIHRvXG4gICAgICogQHBhcmFtIG9wdHMgLSBvcHRpb25zIHBhc3NlZCB0byBlbmdpbmUuaW9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXRFbmdpbmUoc3J2LCBvcHRzKSB7XG4gICAgICAgIC8vIGluaXRpYWxpemUgZW5naW5lXG4gICAgICAgIGRlYnVnKFwiY3JlYXRpbmcgZW5naW5lLmlvIGluc3RhbmNlIHdpdGggb3B0cyAlalwiLCBvcHRzKTtcbiAgICAgICAgdGhpcy5laW8gPSAoMCwgZW5naW5lX2lvXzEuYXR0YWNoKShzcnYsIG9wdHMpO1xuICAgICAgICAvLyBhdHRhY2ggc3RhdGljIGZpbGUgc2VydmluZ1xuICAgICAgICBpZiAodGhpcy5fc2VydmVDbGllbnQpXG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNlcnZlKHNydik7XG4gICAgICAgIC8vIEV4cG9ydCBodHRwIHNlcnZlclxuICAgICAgICB0aGlzLmh0dHBTZXJ2ZXIgPSBzcnY7XG4gICAgICAgIC8vIGJpbmQgdG8gZW5naW5lIGV2ZW50c1xuICAgICAgICB0aGlzLmJpbmQodGhpcy5laW8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyB0aGUgc3RhdGljIGZpbGUgc2VydmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzcnYgaHR0cCBzZXJ2ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGF0dGFjaFNlcnZlKHNydikge1xuICAgICAgICBkZWJ1ZyhcImF0dGFjaGluZyBjbGllbnQgc2VydmluZyByZXEgaGFuZGxlclwiKTtcbiAgICAgICAgY29uc3QgZXZzID0gc3J2Lmxpc3RlbmVycyhcInJlcXVlc3RcIikuc2xpY2UoMCk7XG4gICAgICAgIHNydi5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJyZXF1ZXN0XCIpO1xuICAgICAgICBzcnYub24oXCJyZXF1ZXN0XCIsIChyZXEsIHJlcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xpZW50UGF0aFJlZ2V4LnRlc3QocmVxLnVybCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29yc01pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29yc01pZGRsZXdhcmUocmVxLCByZXMsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmUocmVxLCByZXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmUocmVxLCByZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2c1tpXS5jYWxsKHNydiwgcmVxLCByZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYSByZXF1ZXN0IHNlcnZpbmcgb2YgY2xpZW50IHNvdXJjZSBhbmQgbWFwXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxXG4gICAgICogQHBhcmFtIHJlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc2VydmUocmVxLCByZXMpIHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSByZXEudXJsLnJlcGxhY2UodGhpcy5fcGF0aCwgXCJcIikucmVwbGFjZSgvXFw/LiokLywgXCJcIik7XG4gICAgICAgIGNvbnN0IGlzTWFwID0gZG90TWFwUmVnZXgudGVzdChmaWxlbmFtZSk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBpc01hcCA/IFwibWFwXCIgOiBcInNvdXJjZVwiO1xuICAgICAgICAvLyBQZXIgdGhlIHN0YW5kYXJkLCBFVGFncyBtdXN0IGJlIHF1b3RlZDpcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzIjc2VjdGlvbi0yLjNcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRFdGFnID0gJ1wiJyArIGNsaWVudFZlcnNpb24gKyAnXCInO1xuICAgICAgICBjb25zdCB3ZWFrRXRhZyA9IFwiVy9cIiArIGV4cGVjdGVkRXRhZztcbiAgICAgICAgY29uc3QgZXRhZyA9IHJlcS5oZWFkZXJzW1wiaWYtbm9uZS1tYXRjaFwiXTtcbiAgICAgICAgaWYgKGV0YWcpIHtcbiAgICAgICAgICAgIGlmIChleHBlY3RlZEV0YWcgPT09IGV0YWcgfHwgd2Vha0V0YWcgPT09IGV0YWcpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInNlcnZlIGNsaWVudCAlcyAzMDRcIiwgdHlwZSk7XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZCgzMDQpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoXCJzZXJ2ZSBjbGllbnQgJXNcIiwgdHlwZSk7XG4gICAgICAgIHJlcy5zZXRIZWFkZXIoXCJDYWNoZS1Db250cm9sXCIsIFwicHVibGljLCBtYXgtYWdlPTBcIik7XG4gICAgICAgIHJlcy5zZXRIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9cIiArIChpc01hcCA/IFwianNvblwiIDogXCJqYXZhc2NyaXB0XCIpICsgXCI7IGNoYXJzZXQ9dXRmLThcIik7XG4gICAgICAgIHJlcy5zZXRIZWFkZXIoXCJFVGFnXCIsIGV4cGVjdGVkRXRhZyk7XG4gICAgICAgIFNlcnZlci5zZW5kRmlsZShmaWxlbmFtZSwgcmVxLCByZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWVcbiAgICAgKiBAcGFyYW0gcmVxXG4gICAgICogQHBhcmFtIHJlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIHNlbmRGaWxlKGZpbGVuYW1lLCByZXEsIHJlcykge1xuICAgICAgICBjb25zdCByZWFkU3RyZWFtID0gKDAsIGZzXzEuY3JlYXRlUmVhZFN0cmVhbSkocGF0aC5qb2luKF9fZGlybmFtZSwgXCIuLi9jbGllbnQtZGlzdC9cIiwgZmlsZW5hbWUpKTtcbiAgICAgICAgY29uc3QgZW5jb2RpbmcgPSBhY2NlcHRzKHJlcSkuZW5jb2RpbmdzKFtcImJyXCIsIFwiZ3ppcFwiLCBcImRlZmxhdGVcIl0pO1xuICAgICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgICAgICAgY2FzZSBcImJyXCI6XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZCgyMDAsIHsgXCJjb250ZW50LWVuY29kaW5nXCI6IFwiYnJcIiB9KTtcbiAgICAgICAgICAgICAgICAoMCwgc3RyZWFtXzEucGlwZWxpbmUpKHJlYWRTdHJlYW0sICgwLCB6bGliXzEuY3JlYXRlQnJvdGxpQ29tcHJlc3MpKCksIHJlcywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZ3ppcFwiOlxuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoMjAwLCB7IFwiY29udGVudC1lbmNvZGluZ1wiOiBcImd6aXBcIiB9KTtcbiAgICAgICAgICAgICAgICAoMCwgc3RyZWFtXzEucGlwZWxpbmUpKHJlYWRTdHJlYW0sICgwLCB6bGliXzEuY3JlYXRlR3ppcCkoKSwgcmVzLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkZWZsYXRlXCI6XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZCgyMDAsIHsgXCJjb250ZW50LWVuY29kaW5nXCI6IFwiZGVmbGF0ZVwiIH0pO1xuICAgICAgICAgICAgICAgICgwLCBzdHJlYW1fMS5waXBlbGluZSkocmVhZFN0cmVhbSwgKDAsIHpsaWJfMS5jcmVhdGVEZWZsYXRlKSgpLCByZXMsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkKDIwMCk7XG4gICAgICAgICAgICAgICAgKDAsIHN0cmVhbV8xLnBpcGVsaW5lKShyZWFkU3RyZWFtLCByZXMsIG9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmRzIHNvY2tldC5pbyB0byBhbiBlbmdpbmUuaW8gaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5naW5lIGVuZ2luZS5pbyAob3IgY29tcGF0aWJsZSkgc2VydmVyXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgYmluZChlbmdpbmUpIHtcbiAgICAgICAgLy8gVE9ETyBhcHBseSBzdHJpY3QgdHlwZXMgdG8gdGhlIGVuZ2luZTogXCJjb25uZWN0aW9uXCIgZXZlbnQsIGBjbG9zZSgpYCBhbmQgYSBtZXRob2QgdG8gc2VydmUgc3RhdGljIGNvbnRlbnRcbiAgICAgICAgLy8gIHRoaXMgd291bGQgYWxsb3cgdG8gcHJvdmlkZSBhbnkgY3VzdG9tIGVuZ2luZSwgbGlrZSBvbmUgYmFzZWQgb24gRGVubyBvciBCdW4gYnVpbHQtaW4gSFRUUCBzZXJ2ZXJcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgIHRoaXMuZW5naW5lLm9uKFwiY29ubmVjdGlvblwiLCB0aGlzLm9uY29ubmVjdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIGVhY2ggaW5jb21pbmcgdHJhbnNwb3J0IGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2VuZ2luZS5Tb2NrZXR9IGNvbm5cbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uY29ubmVjdGlvbihjb25uKSB7XG4gICAgICAgIGRlYnVnKFwiaW5jb21pbmcgY29ubmVjdGlvbiB3aXRoIGlkICVzXCIsIGNvbm4uaWQpO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBuZXcgY2xpZW50XzEuQ2xpZW50KHRoaXMsIGNvbm4pO1xuICAgICAgICBpZiAoY29ubi5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY2xpZW50LmNvbm5lY3QoXCIvXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rcyB1cCBhIG5hbWVzcGFjZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gd2l0aCBhIHNpbXBsZSBzdHJpbmdcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYSByZWdleFxuICAgICAqIGNvbnN0IGR5bmFtaWNOc3AgPSBpby5vZigvXlxcL2R5bmFtaWMtXFxkKyQvKS5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgY29uc3QgbmFtZXNwYWNlID0gc29ja2V0Lm5zcDsgLy8gbmV3TmFtZXNwYWNlLm5hbWUgPT09IFwiL2R5bmFtaWMtMTAxXCJcbiAgICAgKlxuICAgICAqICAgLy8gYnJvYWRjYXN0IHRvIGFsbCBjbGllbnRzIGluIHRoZSBnaXZlbiBzdWItbmFtZXNwYWNlXG4gICAgICogICBuYW1lc3BhY2UuZW1pdChcImhlbGxvXCIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgLSBuc3AgbmFtZVxuICAgICAqIEBwYXJhbSBmbiBvcHRpb25hbCwgbnNwIGBjb25uZWN0aW9uYCBldiBoYW5kbGVyXG4gICAgICovXG4gICAgb2YobmFtZSwgZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgfHwgbmFtZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50TnNwID0gbmV3IHBhcmVudF9uYW1lc3BhY2VfMS5QYXJlbnROYW1lc3BhY2UodGhpcyk7XG4gICAgICAgICAgICBkZWJ1ZyhcImluaXRpYWxpemluZyBwYXJlbnQgbmFtZXNwYWNlICVzXCIsIHBhcmVudE5zcC5uYW1lKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROc3BzLnNldChuYW1lLCBwYXJlbnROc3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROc3BzLnNldCgobnNwLCBjb25uLCBuZXh0KSA9PiBuZXh0KG51bGwsIG5hbWUudGVzdChuc3ApKSwgcGFyZW50TnNwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5hbWVzcGFjZXNGcm9tUmVnRXhwLnNldChuYW1lLCBwYXJlbnROc3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHBhcmVudE5zcC5vbihcImNvbm5lY3RcIiwgZm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudE5zcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU3RyaW5nKG5hbWUpWzBdICE9PSBcIi9cIilcbiAgICAgICAgICAgIG5hbWUgPSBcIi9cIiArIG5hbWU7XG4gICAgICAgIGxldCBuc3AgPSB0aGlzLl9uc3BzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKCFuc3ApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3JlZ2V4LCBwYXJlbnROYW1lc3BhY2VdIG9mIHRoaXMucGFyZW50TmFtZXNwYWNlc0Zyb21SZWdFeHApIHtcbiAgICAgICAgICAgICAgICBpZiAocmVnZXgudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImF0dGFjaGluZyBuYW1lc3BhY2UgJXMgdG8gcGFyZW50IG5hbWVzcGFjZSAlc1wiLCBuYW1lLCByZWdleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnROYW1lc3BhY2UuY3JlYXRlQ2hpbGQobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVidWcoXCJpbml0aWFsaXppbmcgbmFtZXNwYWNlICVzXCIsIG5hbWUpO1xuICAgICAgICAgICAgbnNwID0gbmV3IG5hbWVzcGFjZV8xLk5hbWVzcGFjZSh0aGlzLCBuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX25zcHMuc2V0KG5hbWUsIG5zcCk7XG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXRzLmVtaXRSZXNlcnZlZChcIm5ld19uYW1lc3BhY2VcIiwgbnNwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm4pXG4gICAgICAgICAgICBuc3Aub24oXCJjb25uZWN0XCIsIGZuKTtcbiAgICAgICAgcmV0dXJuIG5zcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHNlcnZlciBjb25uZWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gW2ZuXSBvcHRpb25hbCwgY2FsbGVkIGFzIGBmbihbZXJyXSlgIG9uIGVycm9yIE9SIGFsbCBjb25ucyBjbG9zZWRcbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZShmbikge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoWy4uLnRoaXMuX25zcHMudmFsdWVzKCldLm1hcChhc3luYyAobnNwKSA9PiB7XG4gICAgICAgICAgICBuc3Auc29ja2V0cy5mb3JFYWNoKChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgICAgICBzb2NrZXQuX29uY2xvc2UoXCJzZXJ2ZXIgc2h1dHRpbmcgZG93blwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgbnNwLmFkYXB0ZXIuY2xvc2UoKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmVuZ2luZS5jbG9zZSgpO1xuICAgICAgICAvLyByZXN0b3JlIHRoZSBBZGFwdGVyIHByb3RvdHlwZSwgd2hlbiB0aGUgU29ja2V0LklPIHNlcnZlciB3YXMgYXR0YWNoZWQgdG8gYSB1V2ViU29ja2V0cy5qcyBzZXJ2ZXJcbiAgICAgICAgKDAsIHV3c18xLnJlc3RvcmVBZGFwdGVyKSgpO1xuICAgICAgICBpZiAodGhpcy5odHRwU2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmh0dHBTZXJ2ZXIuY2xvc2UoZm4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm4gJiYgZm4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBtaWRkbGV3YXJlLCB3aGljaCBpcyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCBmb3IgZXZlcnkgaW5jb21pbmcge0BsaW5rIFNvY2tldH0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLnVzZSgoc29ja2V0LCBuZXh0KSA9PiB7XG4gICAgICogICAvLyAuLi5cbiAgICAgKiAgIG5leHQoKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiAtIHRoZSBtaWRkbGV3YXJlIGZ1bmN0aW9uXG4gICAgICovXG4gICAgdXNlKGZuKSB7XG4gICAgICAgIHRoaXMuc29ja2V0cy51c2UoZm4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBlbWl0dGluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gdGhlIOKAnGZvb+KAnSBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMgaW4gdGhlIOKAnHJvb20tMTAx4oCdIHJvb21cbiAgICAgKiBpby50byhcInJvb20tMTAxXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGFuIGFycmF5IG9mIHJvb21zIChhIGNsaWVudCB3aWxsIGJlIG5vdGlmaWVkIGF0IG1vc3Qgb25jZSlcbiAgICAgKiBpby50byhbXCJyb29tLTEwMVwiLCBcInJvb20tMTAyXCJdKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBtdWx0aXBsZSBjaGFpbmVkIGNhbGxzXG4gICAgICogaW8udG8oXCJyb29tLTEwMVwiKS50byhcInJvb20tMTAyXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgdG8ocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLnRvKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYXJnZXRzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLiBTaW1pbGFyIHRvIGB0bygpYCwgYnV0IG1pZ2h0IGZlZWwgY2xlYXJlciBpbiBzb21lIGNhc2VzOlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBkaXNjb25uZWN0IGFsbCBjbGllbnRzIGluIHRoZSBcInJvb20tMTAxXCIgcm9vbVxuICAgICAqIGlvLmluKFwicm9vbS0xMDFcIikuZGlzY29ubmVjdFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBpbihyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuaW4ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4Y2x1ZGVzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB0aGUgXCJmb29cIiBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMsIGV4Y2VwdCB0aGUgb25lcyB0aGF0IGFyZSBpbiB0aGUgXCJyb29tLTEwMVwiIHJvb21cbiAgICAgKiBpby5leGNlcHQoXCJyb29tLTEwMVwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIGlvLmV4Y2VwdChbXCJyb29tLTEwMVwiLCBcInJvb20tMTAyXCJdKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBtdWx0aXBsZSBjaGFpbmVkIGNhbGxzXG4gICAgICogaW8uZXhjZXB0KFwicm9vbS0xMDFcIikuZXhjZXB0KFwicm9vbS0xMDJcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBleGNlcHQocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLmV4Y2VwdChyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQgdG8gYWxsIGNsaWVudHMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtaW1pY3MgdGhlIFdlYlNvY2tldC5zZW5kKCkgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViU29ja2V0L3NlbmRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8uc2VuZChcImhlbGxvXCIpO1xuICAgICAqXG4gICAgICogLy8gdGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICogaW8uZW1pdChcIm1lc3NhZ2VcIiwgXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIHNlbmQoLi4uYXJncykge1xuICAgICAgICAvLyBUaGlzIHR5cGUtY2FzdCBpcyBuZWVkZWQgYmVjYXVzZSBFbWl0RXZlbnRzIGxpa2VseSBkb2Vzbid0IGhhdmUgYG1lc3NhZ2VgIGFzIGEga2V5LlxuICAgICAgICAvLyBpZiB5b3Ugc3BlY2lmeSB0aGUgRW1pdEV2ZW50cywgdGhlIHR5cGUgb2YgYXJncyB3aWxsIGJlIG5ldmVyLlxuICAgICAgICB0aGlzLnNvY2tldHMuZW1pdChcIm1lc3NhZ2VcIiwgLi4uYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudCB0byBhbGwgY2xpZW50cy4gQWxpYXMgb2Yge0BsaW5rIHNlbmR9LlxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgd3JpdGUoLi4uYXJncykge1xuICAgICAgICAvLyBUaGlzIHR5cGUtY2FzdCBpcyBuZWVkZWQgYmVjYXVzZSBFbWl0RXZlbnRzIGxpa2VseSBkb2Vzbid0IGhhdmUgYG1lc3NhZ2VgIGFzIGEga2V5LlxuICAgICAgICAvLyBpZiB5b3Ugc3BlY2lmeSB0aGUgRW1pdEV2ZW50cywgdGhlIHR5cGUgb2YgYXJncyB3aWxsIGJlIG5ldmVyLlxuICAgICAgICB0aGlzLnNvY2tldHMuZW1pdChcIm1lc3NhZ2VcIiwgLi4uYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIG90aGVyIFNvY2tldC5JTyBzZXJ2ZXJzIG9mIHRoZSBjbHVzdGVyLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5zZXJ2ZXJTaWRlRW1pdChcImhlbGxvXCIsIFwid29ybGRcIik7XG4gICAgICpcbiAgICAgKiBpby5vbihcImhlbGxvXCIsIChhcmcxKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhhcmcxKTsgLy8gcHJpbnRzIFwid29ybGRcIlxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gYWNrbm93bGVkZ2VtZW50cyAod2l0aG91dCBiaW5hcnkgY29udGVudCkgYXJlIHN1cHBvcnRlZCB0b286XG4gICAgICogaW8uc2VydmVyU2lkZUVtaXQoXCJwaW5nXCIsIChlcnIsIHJlc3BvbnNlcykgPT4ge1xuICAgICAqICBpZiAoZXJyKSB7XG4gICAgICogICAgIC8vIHNvbWUgc2VydmVycyBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiAgIH0gZWxzZSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlcyk7IC8vIG9uZSByZXNwb25zZSBwZXIgc2VydmVyIChleGNlcHQgdGhlIGN1cnJlbnQgb25lKVxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogaW8ub24oXCJwaW5nXCIsIChjYikgPT4ge1xuICAgICAqICAgY2IoXCJwb25nXCIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGV2IC0gdGhlIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0gYXJncyAtIGFuIGFycmF5IG9mIGFyZ3VtZW50cywgd2hpY2ggbWF5IGluY2x1ZGUgYW4gYWNrbm93bGVkZ2VtZW50IGNhbGxiYWNrIGF0IHRoZSBlbmRcbiAgICAgKi9cbiAgICBzZXJ2ZXJTaWRlRW1pdChldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLnNlcnZlclNpZGVFbWl0KGV2LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIGFuZCBleHBlY3QgYW4gYWNrbm93bGVkZ2VtZW50IGZyb20gdGhlIG90aGVyIFNvY2tldC5JTyBzZXJ2ZXJzIG9mIHRoZSBjbHVzdGVyLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB0cnkge1xuICAgICAqICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgaW8uc2VydmVyU2lkZUVtaXRXaXRoQWNrKFwicGluZ1wiKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHJlc3BvbnNlcyk7IC8vIG9uZSByZXNwb25zZSBwZXIgc2VydmVyIChleGNlcHQgdGhlIGN1cnJlbnQgb25lKVxuICAgICAqIH0gY2F0Y2ggKGUpIHtcbiAgICAgKiAgIC8vIHNvbWUgc2VydmVycyBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgLSB0aGUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIC0gYW4gYXJyYXkgb2YgYXJndW1lbnRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gYWxsIHNlcnZlcnMgaGF2ZSBhY2tub3dsZWRnZWQgdGhlIGV2ZW50XG4gICAgICovXG4gICAgc2VydmVyU2lkZUVtaXRXaXRoQWNrKGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuc2VydmVyU2lkZUVtaXRXaXRoQWNrKGV2LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2Ygc29ja2V0IGlkcy5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIHRoaXMgbWV0aG9kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLCBwbGVhc2UgdXNlIHtAbGluayBTZXJ2ZXIjc2VydmVyU2lkZUVtaXR9IG9yXG4gICAgICoge0BsaW5rIFNlcnZlciNmZXRjaFNvY2tldHN9IGluc3RlYWQuXG4gICAgICovXG4gICAgYWxsU29ja2V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5hbGxTb2NrZXRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLmNvbXByZXNzKGZhbHNlKS5lbWl0KFwiaGVsbG9cIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tcHJlc3MgLSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBjb21wcmVzcyhjb21wcmVzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLmNvbXByZXNzKGNvbXByZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSBtYXkgYmUgbG9zdCBpZiB0aGUgY2xpZW50IGlzIG5vdCByZWFkeSB0b1xuICAgICAqIHJlY2VpdmUgbWVzc2FnZXMgKGJlY2F1c2Ugb2YgbmV0d29yayBzbG93bmVzcyBvciBvdGhlciBpc3N1ZXMsIG9yIGJlY2F1c2UgdGhleeKAmXJlIGNvbm5lY3RlZCB0aHJvdWdoIGxvbmcgcG9sbGluZ1xuICAgICAqIGFuZCBpcyBpbiB0aGUgbWlkZGxlIG9mIGEgcmVxdWVzdC1yZXNwb25zZSBjeWNsZSkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLnZvbGF0aWxlLmVtaXQoXCJoZWxsb1wiKTsgLy8gdGhlIGNsaWVudHMgbWF5IG9yIG1heSBub3QgcmVjZWl2ZSBpdFxuICAgICAqXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGdldCB2b2xhdGlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy52b2xhdGlsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSB3aWxsIG9ubHkgYmUgYnJvYWRjYXN0IHRvIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHRoZSDigJxmb2/igJ0gZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzIG9uIHRoaXMgbm9kZVxuICAgICAqIGlvLmxvY2FsLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZ2V0IGxvY2FsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLmxvY2FsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSBuZXh0IG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8udGltZW91dCgxMDAwKS5lbWl0KFwic29tZS1ldmVudFwiLCAoZXJyLCByZXNwb25zZXMpID0+IHtcbiAgICAgKiAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgLy8gc29tZSBjbGllbnRzIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgfSBlbHNlIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzcG9uc2VzKTsgLy8gb25lIHJlc3BvbnNlIHBlciBjbGllbnRcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lb3V0XG4gICAgICovXG4gICAgdGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMudGltZW91dCh0aW1lb3V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyByZXR1cm4gYWxsIFNvY2tldCBpbnN0YW5jZXNcbiAgICAgKiBjb25zdCBzb2NrZXRzID0gYXdhaXQgaW8uZmV0Y2hTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm4gYWxsIFNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tXG4gICAgICogY29uc3Qgc29ja2V0cyA9IGF3YWl0IGlvLmluKFwicm9vbTFcIikuZmV0Y2hTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiBmb3IgKGNvbnN0IHNvY2tldCBvZiBzb2NrZXRzKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuaWQpO1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmhhbmRzaGFrZSk7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQucm9vbXMpO1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmRhdGEpO1xuICAgICAqXG4gICAgICogICBzb2NrZXQuZW1pdChcImhlbGxvXCIpO1xuICAgICAqICAgc29ja2V0LmpvaW4oXCJyb29tMVwiKTtcbiAgICAgKiAgIHNvY2tldC5sZWF2ZShcInJvb20yXCIpO1xuICAgICAqICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgZmV0Y2hTb2NrZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLmZldGNoU29ja2V0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBqb2luIHRoZSBzcGVjaWZpZWQgcm9vbXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIHdpdGhpbiBhIGNsdXN0ZXIgb2YgbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBBZGFwdGVyfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGpvaW4gdGhlIFwicm9vbTFcIiByb29tXG4gICAgICogaW8uc29ja2V0c0pvaW4oXCJyb29tMVwiKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tIGpvaW4gdGhlIFwicm9vbTJcIiBhbmQgXCJyb29tM1wiIHJvb21zXG4gICAgICogaW8uaW4oXCJyb29tMVwiKS5zb2NrZXRzSm9pbihbXCJyb29tMlwiLCBcInJvb20zXCJdKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqL1xuICAgIHNvY2tldHNKb2luKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5zb2NrZXRzSm9pbihyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgbGVhdmUgdGhlIHNwZWNpZmllZCByb29tcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGxlYXZlIHRoZSBcInJvb20xXCIgcm9vbVxuICAgICAqIGlvLnNvY2tldHNMZWF2ZShcInJvb20xXCIpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBpbiB0aGUgXCJyb29tMVwiIHJvb20gbGVhdmUgdGhlIFwicm9vbTJcIiBhbmQgXCJyb29tM1wiIHJvb21zXG4gICAgICogaW8uaW4oXCJyb29tMVwiKS5zb2NrZXRzTGVhdmUoW1wicm9vbTJcIiwgXCJyb29tM1wiXSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKi9cbiAgICBzb2NrZXRzTGVhdmUocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLnNvY2tldHNMZWF2ZShyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgZGlzY29ubmVjdC5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGRpc2Nvbm5lY3QgKHRoZSBjb25uZWN0aW9ucyBtaWdodCBiZSBrZXB0IGFsaXZlIGZvciBvdGhlciBuYW1lc3BhY2VzKVxuICAgICAqIGlvLmRpc2Nvbm5lY3RTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbSBkaXNjb25uZWN0IGFuZCBjbG9zZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uc1xuICAgICAqIGlvLmluKFwicm9vbTFcIikuZGlzY29ubmVjdFNvY2tldHModHJ1ZSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xvc2UgLSB3aGV0aGVyIHRvIGNsb3NlIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0U29ja2V0cyhjbG9zZSA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuZGlzY29ubmVjdFNvY2tldHMoY2xvc2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyID0gU2VydmVyO1xuLyoqXG4gKiBFeHBvc2UgbWFpbiBuYW1lc3BhY2UgKC8pLlxuICovXG5jb25zdCBlbWl0dGVyTWV0aG9kcyA9IE9iamVjdC5rZXlzKGV2ZW50c18xLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBldmVudHNfMS5FdmVudEVtaXR0ZXIucHJvdG90eXBlW2tleV0gPT09IFwiZnVuY3Rpb25cIjtcbn0pO1xuZW1pdHRlck1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICBTZXJ2ZXIucHJvdG90eXBlW2ZuXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0c1tmbl0uYXBwbHkodGhpcy5zb2NrZXRzLCBhcmd1bWVudHMpO1xuICAgIH07XG59KTtcbm1vZHVsZS5leHBvcnRzID0gKHNydiwgb3B0cykgPT4gbmV3IFNlcnZlcihzcnYsIG9wdHMpO1xubW9kdWxlLmV4cG9ydHMuU2VydmVyID0gU2VydmVyO1xubW9kdWxlLmV4cG9ydHMuTmFtZXNwYWNlID0gbmFtZXNwYWNlXzEuTmFtZXNwYWNlO1xubW9kdWxlLmV4cG9ydHMuU29ja2V0ID0gc29ja2V0XzEuU29ja2V0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/socket.io/dist/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/socket.io/dist/namespace.js":
/*!**************************************************!*\
  !*** ./node_modules/socket.io/dist/namespace.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Namespace = exports.RESERVED_EVENTS = void 0;\nconst socket_1 = __webpack_require__(/*! ./socket */ \"(action-browser)/./node_modules/socket.io/dist/socket.js\");\nconst typed_events_1 = __webpack_require__(/*! ./typed-events */ \"(action-browser)/./node_modules/socket.io/dist/typed-events.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(action-browser)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst broadcast_operator_1 = __webpack_require__(/*! ./broadcast-operator */ \"(action-browser)/./node_modules/socket.io/dist/broadcast-operator.js\");\nconst debug = (0, debug_1.default)(\"socket.io:namespace\");\nexports.RESERVED_EVENTS = new Set([\"connect\", \"connection\", \"new_namespace\"]);\n/**\n * A Namespace is a communication channel that allows you to split the logic of your application over a single shared\n * connection.\n *\n * Each namespace has its own:\n *\n * - event handlers\n *\n * ```\n * io.of(\"/orders\").on(\"connection\", (socket) => {\n *   socket.on(\"order:list\", () => {});\n *   socket.on(\"order:create\", () => {});\n * });\n *\n * io.of(\"/users\").on(\"connection\", (socket) => {\n *   socket.on(\"user:list\", () => {});\n * });\n * ```\n *\n * - rooms\n *\n * ```\n * const orderNamespace = io.of(\"/orders\");\n *\n * orderNamespace.on(\"connection\", (socket) => {\n *   socket.join(\"room1\");\n *   orderNamespace.to(\"room1\").emit(\"hello\");\n * });\n *\n * const userNamespace = io.of(\"/users\");\n *\n * userNamespace.on(\"connection\", (socket) => {\n *   socket.join(\"room1\"); // distinct from the room in the \"orders\" namespace\n *   userNamespace.to(\"room1\").emit(\"holà\");\n * });\n * ```\n *\n * - middlewares\n *\n * ```\n * const orderNamespace = io.of(\"/orders\");\n *\n * orderNamespace.use((socket, next) => {\n *   // ensure the socket has access to the \"orders\" namespace\n * });\n *\n * const userNamespace = io.of(\"/users\");\n *\n * userNamespace.use((socket, next) => {\n *   // ensure the socket has access to the \"users\" namespace\n * });\n * ```\n */\nclass Namespace extends typed_events_1.StrictEventEmitter {\n    /**\n     * Namespace constructor.\n     *\n     * @param server instance\n     * @param name\n     */\n    constructor(server, name) {\n        super();\n        /**\n         * A map of currently connected sockets.\n         */\n        this.sockets = new Map();\n        /**\n         * A map of currently connecting sockets.\n         */\n        this._preConnectSockets = new Map();\n        this._fns = [];\n        /** @private */\n        this._ids = 0;\n        this.server = server;\n        this.name = name;\n        this._initAdapter();\n    }\n    /**\n     * Initializes the `Adapter` for this nsp.\n     * Run upon changing adapter by `Server#adapter`\n     * in addition to the constructor.\n     *\n     * @private\n     */\n    _initAdapter() {\n        // @ts-ignore\n        this.adapter = new (this.server.adapter())(this);\n    }\n    /**\n     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.use((socket, next) => {\n     *   // ...\n     *   next();\n     * });\n     *\n     * @param fn - the middleware function\n     */\n    use(fn) {\n        this._fns.push(fn);\n        return this;\n    }\n    /**\n     * Executes the middleware for an incoming client.\n     *\n     * @param socket - the socket that will get added\n     * @param fn - last fn call in the middleware\n     * @private\n     */\n    run(socket, fn) {\n        if (!this._fns.length)\n            return fn();\n        const fns = this._fns.slice(0);\n        function run(i) {\n            fns[i](socket, (err) => {\n                // upon error, short-circuit\n                if (err)\n                    return fn(err);\n                // if no middleware left, summon callback\n                if (!fns[i + 1])\n                    return fn();\n                // go on to next\n                run(i + 1);\n            });\n        }\n        run(0);\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // the “foo” event will be broadcast to all connected clients in the “room-101” room\n     * myNamespace.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms (a client will be notified at most once)\n     * myNamespace.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * myNamespace.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    to(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).to(room);\n    }\n    /**\n     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // disconnect all clients in the \"room-101\" room\n     * myNamespace.in(\"room-101\").disconnectSockets();\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    in(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).in(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     * myNamespace.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms\n     * myNamespace.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * myNamespace.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    except(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).except(room);\n    }\n    /**\n     * Adds a new client.\n     *\n     * @return {Socket}\n     * @private\n     */\n    async _add(client, auth, fn) {\n        var _a;\n        debug(\"adding socket to nsp %s\", this.name);\n        const socket = await this._createSocket(client, auth);\n        this._preConnectSockets.set(socket.id, socket);\n        if (\n        // @ts-ignore\n        ((_a = this.server.opts.connectionStateRecovery) === null || _a === void 0 ? void 0 : _a.skipMiddlewares) &&\n            socket.recovered &&\n            client.conn.readyState === \"open\") {\n            return this._doConnect(socket, fn);\n        }\n        this.run(socket, (err) => {\n            process.nextTick(() => {\n                if (\"open\" !== client.conn.readyState) {\n                    debug(\"next called after client was closed - ignoring socket\");\n                    socket._cleanup();\n                    return;\n                }\n                if (err) {\n                    debug(\"middleware error, sending CONNECT_ERROR packet to the client\");\n                    socket._cleanup();\n                    if (client.conn.protocol === 3) {\n                        return socket._error(err.data || err.message);\n                    }\n                    else {\n                        return socket._error({\n                            message: err.message,\n                            data: err.data,\n                        });\n                    }\n                }\n                this._doConnect(socket, fn);\n            });\n        });\n    }\n    async _createSocket(client, auth) {\n        const sessionId = auth.pid;\n        const offset = auth.offset;\n        if (\n        // @ts-ignore\n        this.server.opts.connectionStateRecovery &&\n            typeof sessionId === \"string\" &&\n            typeof offset === \"string\") {\n            let session;\n            try {\n                session = await this.adapter.restoreSession(sessionId, offset);\n            }\n            catch (e) {\n                debug(\"error while restoring session: %s\", e);\n            }\n            if (session) {\n                debug(\"connection state recovered for sid %s\", session.sid);\n                return new socket_1.Socket(this, client, auth, session);\n            }\n        }\n        return new socket_1.Socket(this, client, auth);\n    }\n    _doConnect(socket, fn) {\n        this._preConnectSockets.delete(socket.id);\n        this.sockets.set(socket.id, socket);\n        // it's paramount that the internal `onconnect` logic\n        // fires before user-set events to prevent state order\n        // violations (such as a disconnection before the connection\n        // logic is complete)\n        socket._onconnect();\n        if (fn)\n            fn(socket);\n        // fire user-set events\n        this.emitReserved(\"connect\", socket);\n        this.emitReserved(\"connection\", socket);\n    }\n    /**\n     * Removes a client. Called by each `Socket`.\n     *\n     * @private\n     */\n    _remove(socket) {\n        this.sockets.delete(socket.id) || this._preConnectSockets.delete(socket.id);\n    }\n    /**\n     * Emits to all connected clients.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.emit(\"hello\", \"world\");\n     *\n     * // all serializable datastructures are supported (no need to call JSON.stringify)\n     * myNamespace.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n     *\n     * // with an acknowledgement from the clients\n     * myNamespace.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @return Always true\n     */\n    emit(ev, ...args) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).emit(ev, ...args);\n    }\n    /**\n     * Sends a `message` event to all clients.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.send(\"hello\");\n     *\n     * // this is equivalent to\n     * myNamespace.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */\n    send(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a `message` event to all clients. Sends a `message` event. Alias of {@link send}.\n     *\n     * @return self\n     */\n    write(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a message to the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.serverSideEmit(\"hello\", \"world\");\n     *\n     * myNamespace.on(\"hello\", (arg1) => {\n     *   console.log(arg1); // prints \"world\"\n     * });\n     *\n     * // acknowledgements (without binary content) are supported too:\n     * myNamespace.serverSideEmit(\"ping\", (err, responses) => {\n     *  if (err) {\n     *     // some servers did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per server (except the current one)\n     *   }\n     * });\n     *\n     * myNamespace.on(\"ping\", (cb) => {\n     *   cb(\"pong\");\n     * });\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments, which may include an acknowledgement callback at the end\n     */\n    serverSideEmit(ev, ...args) {\n        if (exports.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${String(ev)}\" is a reserved event name`);\n        }\n        args.unshift(ev);\n        this.adapter.serverSideEmit(args);\n        return true;\n    }\n    /**\n     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * try {\n     *   const responses = await myNamespace.serverSideEmitWithAck(\"ping\");\n     *   console.log(responses); // one response per server (except the current one)\n     * } catch (e) {\n     *   // some servers did not acknowledge the event in the given delay\n     * }\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments\n     *\n     * @return a Promise that will be fulfilled when all servers have acknowledged the event\n     */\n    serverSideEmitWithAck(ev, ...args) {\n        return new Promise((resolve, reject) => {\n            args.push((err, responses) => {\n                if (err) {\n                    err.responses = responses;\n                    return reject(err);\n                }\n                else {\n                    return resolve(responses);\n                }\n            });\n            this.serverSideEmit(ev, ...args);\n        });\n    }\n    /**\n     * Called when a packet is received from another Socket.IO server\n     *\n     * @param args - an array of arguments, which may include an acknowledgement callback at the end\n     *\n     * @private\n     */\n    _onServerSideEmit(args) {\n        super.emitUntyped.apply(this, args);\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @deprecated this method will be removed in the next major release, please use {@link Namespace#serverSideEmit} or\n     * {@link Namespace#fetchSockets} instead.\n     */\n    allSockets() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).allSockets();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     */\n    compress(compress) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).compress(compress);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.volatile.emit(\"hello\"); // the clients may or may not receive it\n     *\n     * @return self\n     */\n    get volatile() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).volatile;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // the “foo” event will be broadcast to all connected clients on this node\n     * myNamespace.local.emit(\"foo\", \"bar\");\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    get local() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).local;\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @param timeout\n     */\n    timeout(timeout) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).timeout(timeout);\n    }\n    /**\n     * Returns the matching socket instances.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // return all Socket instances\n     * const sockets = await myNamespace.fetchSockets();\n     *\n     * // return all Socket instances in the \"room1\" room\n     * const sockets = await myNamespace.in(\"room1\").fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   console.log(socket.id);\n     *   console.log(socket.handshake);\n     *   console.log(socket.rooms);\n     *   console.log(socket.data);\n     *\n     *   socket.emit(\"hello\");\n     *   socket.join(\"room1\");\n     *   socket.leave(\"room2\");\n     *   socket.disconnect();\n     * }\n     */\n    fetchSockets() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).fetchSockets();\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // make all socket instances join the \"room1\" room\n     * myNamespace.socketsJoin(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room join the \"room2\" and \"room3\" rooms\n     * myNamespace.in(\"room1\").socketsJoin([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */\n    socketsJoin(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsJoin(room);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // make all socket instances leave the \"room1\" room\n     * myNamespace.socketsLeave(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room leave the \"room2\" and \"room3\" rooms\n     * myNamespace.in(\"room1\").socketsLeave([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */\n    socketsLeave(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsLeave(room);\n    }\n    /**\n     * Makes the matching socket instances disconnect.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)\n     * myNamespace.disconnectSockets();\n     *\n     * // make all socket instances in the \"room1\" room disconnect and close the underlying connections\n     * myNamespace.in(\"room1\").disconnectSockets(true);\n     *\n     * @param close - whether to close the underlying connection\n     */\n    disconnectSockets(close = false) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).disconnectSockets(close);\n    }\n}\nexports.Namespace = Namespace;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9uYW1lc3BhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyx1QkFBdUI7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsMEVBQVU7QUFDbkMsdUJBQXVCLG1CQUFPLENBQUMsc0ZBQWdCO0FBQy9DLGdDQUFnQyxtQkFBTyxDQUFDLHdGQUFPO0FBQy9DLDZCQUE2QixtQkFBTyxDQUFDLGtHQUFzQjtBQUMzRDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyx1Q0FBdUM7QUFDdkMsSUFBSTtBQUNKO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsYUFBYTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsbUNBQW1DO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsbUNBQW1DO0FBQ25DO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixXQUFXO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxtQ0FBbUM7QUFDbkM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixnQ0FBZ0M7QUFDdEgsUUFBUSw4QkFBOEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLG1DQUFtQztBQUNuQztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsY0FBYztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxjQUFjO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxjQUFjO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxjQUFjO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yc29sZS9Eb2N1bWVudHMvR2l0SHViL21hc3NpbWluby9tYXNzaW1pbm8vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9kaXN0L25hbWVzcGFjZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTmFtZXNwYWNlID0gZXhwb3J0cy5SRVNFUlZFRF9FVkVOVFMgPSB2b2lkIDA7XG5jb25zdCBzb2NrZXRfMSA9IHJlcXVpcmUoXCIuL3NvY2tldFwiKTtcbmNvbnN0IHR5cGVkX2V2ZW50c18xID0gcmVxdWlyZShcIi4vdHlwZWQtZXZlbnRzXCIpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgYnJvYWRjYXN0X29wZXJhdG9yXzEgPSByZXF1aXJlKFwiLi9icm9hZGNhc3Qtb3BlcmF0b3JcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwic29ja2V0LmlvOm5hbWVzcGFjZVwiKTtcbmV4cG9ydHMuUkVTRVJWRURfRVZFTlRTID0gbmV3IFNldChbXCJjb25uZWN0XCIsIFwiY29ubmVjdGlvblwiLCBcIm5ld19uYW1lc3BhY2VcIl0pO1xuLyoqXG4gKiBBIE5hbWVzcGFjZSBpcyBhIGNvbW11bmljYXRpb24gY2hhbm5lbCB0aGF0IGFsbG93cyB5b3UgdG8gc3BsaXQgdGhlIGxvZ2ljIG9mIHlvdXIgYXBwbGljYXRpb24gb3ZlciBhIHNpbmdsZSBzaGFyZWRcbiAqIGNvbm5lY3Rpb24uXG4gKlxuICogRWFjaCBuYW1lc3BhY2UgaGFzIGl0cyBvd246XG4gKlxuICogLSBldmVudCBoYW5kbGVyc1xuICpcbiAqIGBgYFxuICogaW8ub2YoXCIvb3JkZXJzXCIpLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gKiAgIHNvY2tldC5vbihcIm9yZGVyOmxpc3RcIiwgKCkgPT4ge30pO1xuICogICBzb2NrZXQub24oXCJvcmRlcjpjcmVhdGVcIiwgKCkgPT4ge30pO1xuICogfSk7XG4gKlxuICogaW8ub2YoXCIvdXNlcnNcIikub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAqICAgc29ja2V0Lm9uKFwidXNlcjpsaXN0XCIsICgpID0+IHt9KTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogLSByb29tc1xuICpcbiAqIGBgYFxuICogY29uc3Qgb3JkZXJOYW1lc3BhY2UgPSBpby5vZihcIi9vcmRlcnNcIik7XG4gKlxuICogb3JkZXJOYW1lc3BhY2Uub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAqICAgc29ja2V0LmpvaW4oXCJyb29tMVwiKTtcbiAqICAgb3JkZXJOYW1lc3BhY2UudG8oXCJyb29tMVwiKS5lbWl0KFwiaGVsbG9cIik7XG4gKiB9KTtcbiAqXG4gKiBjb25zdCB1c2VyTmFtZXNwYWNlID0gaW8ub2YoXCIvdXNlcnNcIik7XG4gKlxuICogdXNlck5hbWVzcGFjZS5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICogICBzb2NrZXQuam9pbihcInJvb20xXCIpOyAvLyBkaXN0aW5jdCBmcm9tIHRoZSByb29tIGluIHRoZSBcIm9yZGVyc1wiIG5hbWVzcGFjZVxuICogICB1c2VyTmFtZXNwYWNlLnRvKFwicm9vbTFcIikuZW1pdChcImhvbMOgXCIpO1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiAtIG1pZGRsZXdhcmVzXG4gKlxuICogYGBgXG4gKiBjb25zdCBvcmRlck5hbWVzcGFjZSA9IGlvLm9mKFwiL29yZGVyc1wiKTtcbiAqXG4gKiBvcmRlck5hbWVzcGFjZS51c2UoKHNvY2tldCwgbmV4dCkgPT4ge1xuICogICAvLyBlbnN1cmUgdGhlIHNvY2tldCBoYXMgYWNjZXNzIHRvIHRoZSBcIm9yZGVyc1wiIG5hbWVzcGFjZVxuICogfSk7XG4gKlxuICogY29uc3QgdXNlck5hbWVzcGFjZSA9IGlvLm9mKFwiL3VzZXJzXCIpO1xuICpcbiAqIHVzZXJOYW1lc3BhY2UudXNlKChzb2NrZXQsIG5leHQpID0+IHtcbiAqICAgLy8gZW5zdXJlIHRoZSBzb2NrZXQgaGFzIGFjY2VzcyB0byB0aGUgXCJ1c2Vyc1wiIG5hbWVzcGFjZVxuICogfSk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgTmFtZXNwYWNlIGV4dGVuZHMgdHlwZWRfZXZlbnRzXzEuU3RyaWN0RXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBOYW1lc3BhY2UgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VydmVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIG5hbWVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXIsIG5hbWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIG9mIGN1cnJlbnRseSBjb25uZWN0ZWQgc29ja2V0cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc29ja2V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIG9mIGN1cnJlbnRseSBjb25uZWN0aW5nIHNvY2tldHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wcmVDb25uZWN0U29ja2V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fZm5zID0gW107XG4gICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgICB0aGlzLl9pZHMgPSAwO1xuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5faW5pdEFkYXB0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGBBZGFwdGVyYCBmb3IgdGhpcyBuc3AuXG4gICAgICogUnVuIHVwb24gY2hhbmdpbmcgYWRhcHRlciBieSBgU2VydmVyI2FkYXB0ZXJgXG4gICAgICogaW4gYWRkaXRpb24gdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEFkYXB0ZXIoKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5hZGFwdGVyID0gbmV3ICh0aGlzLnNlcnZlci5hZGFwdGVyKCkpKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBtaWRkbGV3YXJlLCB3aGljaCBpcyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCBmb3IgZXZlcnkgaW5jb21pbmcge0BsaW5rIFNvY2tldH0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogbXlOYW1lc3BhY2UudXNlKChzb2NrZXQsIG5leHQpID0+IHtcbiAgICAgKiAgIC8vIC4uLlxuICAgICAqICAgbmV4dCgpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGZuIC0gdGhlIG1pZGRsZXdhcmUgZnVuY3Rpb25cbiAgICAgKi9cbiAgICB1c2UoZm4pIHtcbiAgICAgICAgdGhpcy5fZm5zLnB1c2goZm4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIG1pZGRsZXdhcmUgZm9yIGFuIGluY29taW5nIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb2NrZXQgLSB0aGUgc29ja2V0IHRoYXQgd2lsbCBnZXQgYWRkZWRcbiAgICAgKiBAcGFyYW0gZm4gLSBsYXN0IGZuIGNhbGwgaW4gdGhlIG1pZGRsZXdhcmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJ1bihzb2NrZXQsIGZuKSB7XG4gICAgICAgIGlmICghdGhpcy5fZm5zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICBjb25zdCBmbnMgPSB0aGlzLl9mbnMuc2xpY2UoMCk7XG4gICAgICAgIGZ1bmN0aW9uIHJ1bihpKSB7XG4gICAgICAgICAgICBmbnNbaV0oc29ja2V0LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdXBvbiBlcnJvciwgc2hvcnQtY2lyY3VpdFxuICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihlcnIpO1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vIG1pZGRsZXdhcmUgbGVmdCwgc3VtbW9uIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgaWYgKCFmbnNbaSArIDFdKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgICAgICAgICAvLyBnbyBvbiB0byBuZXh0XG4gICAgICAgICAgICAgICAgcnVuKGkgKyAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJ1bigwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBlbWl0dGluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cyBpbiB0aGUg4oCccm9vbS0xMDHigJ0gcm9vbVxuICAgICAqIG15TmFtZXNwYWNlLnRvKFwicm9vbS0xMDFcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYW4gYXJyYXkgb2Ygcm9vbXMgKGEgY2xpZW50IHdpbGwgYmUgbm90aWZpZWQgYXQgbW9zdCBvbmNlKVxuICAgICAqIG15TmFtZXNwYWNlLnRvKFtcInJvb20tMTAxXCIsIFwicm9vbS0xMDJcIl0pLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIG11bHRpcGxlIGNoYWluZWQgY2FsbHNcbiAgICAgKiBteU5hbWVzcGFjZS50byhcInJvb20tMTAxXCIpLnRvKFwicm9vbS0xMDJcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICB0byhyb29tKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS50byhyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBlbWl0dGluZy4gU2ltaWxhciB0byBgdG8oKWAsIGJ1dCBtaWdodCBmZWVsIGNsZWFyZXIgaW4gc29tZSBjYXNlczpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiAvLyBkaXNjb25uZWN0IGFsbCBjbGllbnRzIGluIHRoZSBcInJvb20tMTAxXCIgcm9vbVxuICAgICAqIG15TmFtZXNwYWNlLmluKFwicm9vbS0xMDFcIikuZGlzY29ubmVjdFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBpbihyb29tKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5pbihyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhjbHVkZXMgYSByb29tIHdoZW4gZW1pdHRpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogLy8gdGhlIFwiZm9vXCIgZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzLCBleGNlcHQgdGhlIG9uZXMgdGhhdCBhcmUgaW4gdGhlIFwicm9vbS0xMDFcIiByb29tXG4gICAgICogbXlOYW1lc3BhY2UuZXhjZXB0KFwicm9vbS0xMDFcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBteU5hbWVzcGFjZS5leGNlcHQoW1wicm9vbS0xMDFcIiwgXCJyb29tLTEwMlwiXSkuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggbXVsdGlwbGUgY2hhaW5lZCBjYWxsc1xuICAgICAqIG15TmFtZXNwYWNlLmV4Y2VwdChcInJvb20tMTAxXCIpLmV4Y2VwdChcInJvb20tMTAyXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZXhjZXB0KHJvb20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLmV4Y2VwdChyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBfYWRkKGNsaWVudCwgYXV0aCwgZm4pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBkZWJ1ZyhcImFkZGluZyBzb2NrZXQgdG8gbnNwICVzXCIsIHRoaXMubmFtZSk7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IGF3YWl0IHRoaXMuX2NyZWF0ZVNvY2tldChjbGllbnQsIGF1dGgpO1xuICAgICAgICB0aGlzLl9wcmVDb25uZWN0U29ja2V0cy5zZXQoc29ja2V0LmlkLCBzb2NrZXQpO1xuICAgICAgICBpZiAoXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgKChfYSA9IHRoaXMuc2VydmVyLm9wdHMuY29ubmVjdGlvblN0YXRlUmVjb3ZlcnkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5za2lwTWlkZGxld2FyZXMpICYmXG4gICAgICAgICAgICBzb2NrZXQucmVjb3ZlcmVkICYmXG4gICAgICAgICAgICBjbGllbnQuY29ubi5yZWFkeVN0YXRlID09PSBcIm9wZW5cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvQ29ubmVjdChzb2NrZXQsIGZuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJ1bihzb2NrZXQsIChlcnIpID0+IHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChcIm9wZW5cIiAhPT0gY2xpZW50LmNvbm4ucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcIm5leHQgY2FsbGVkIGFmdGVyIGNsaWVudCB3YXMgY2xvc2VkIC0gaWdub3Jpbmcgc29ja2V0XCIpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuX2NsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwibWlkZGxld2FyZSBlcnJvciwgc2VuZGluZyBDT05ORUNUX0VSUk9SIHBhY2tldCB0byB0aGUgY2xpZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuX2NsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsaWVudC5jb25uLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ja2V0Ll9lcnJvcihlcnIuZGF0YSB8fCBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ja2V0Ll9lcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZXJyLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kb0Nvbm5lY3Qoc29ja2V0LCBmbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9jcmVhdGVTb2NrZXQoY2xpZW50LCBhdXRoKSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb25JZCA9IGF1dGgucGlkO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBhdXRoLm9mZnNldDtcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuc2VydmVyLm9wdHMuY29ubmVjdGlvblN0YXRlUmVjb3ZlcnkgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzZXNzaW9uSWQgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvZmZzZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxldCBzZXNzaW9uO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uID0gYXdhaXQgdGhpcy5hZGFwdGVyLnJlc3RvcmVTZXNzaW9uKHNlc3Npb25JZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJlcnJvciB3aGlsZSByZXN0b3Jpbmcgc2Vzc2lvbjogJXNcIiwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiBzdGF0ZSByZWNvdmVyZWQgZm9yIHNpZCAlc1wiLCBzZXNzaW9uLnNpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzb2NrZXRfMS5Tb2NrZXQodGhpcywgY2xpZW50LCBhdXRoLCBzZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHNvY2tldF8xLlNvY2tldCh0aGlzLCBjbGllbnQsIGF1dGgpO1xuICAgIH1cbiAgICBfZG9Db25uZWN0KHNvY2tldCwgZm4pIHtcbiAgICAgICAgdGhpcy5fcHJlQ29ubmVjdFNvY2tldHMuZGVsZXRlKHNvY2tldC5pZCk7XG4gICAgICAgIHRoaXMuc29ja2V0cy5zZXQoc29ja2V0LmlkLCBzb2NrZXQpO1xuICAgICAgICAvLyBpdCdzIHBhcmFtb3VudCB0aGF0IHRoZSBpbnRlcm5hbCBgb25jb25uZWN0YCBsb2dpY1xuICAgICAgICAvLyBmaXJlcyBiZWZvcmUgdXNlci1zZXQgZXZlbnRzIHRvIHByZXZlbnQgc3RhdGUgb3JkZXJcbiAgICAgICAgLy8gdmlvbGF0aW9ucyAoc3VjaCBhcyBhIGRpc2Nvbm5lY3Rpb24gYmVmb3JlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgIC8vIGxvZ2ljIGlzIGNvbXBsZXRlKVxuICAgICAgICBzb2NrZXQuX29uY29ubmVjdCgpO1xuICAgICAgICBpZiAoZm4pXG4gICAgICAgICAgICBmbihzb2NrZXQpO1xuICAgICAgICAvLyBmaXJlIHVzZXItc2V0IGV2ZW50c1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImNvbm5lY3RcIiwgc29ja2V0KTtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJjb25uZWN0aW9uXCIsIHNvY2tldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjbGllbnQuIENhbGxlZCBieSBlYWNoIGBTb2NrZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlKHNvY2tldCkge1xuICAgICAgICB0aGlzLnNvY2tldHMuZGVsZXRlKHNvY2tldC5pZCkgfHwgdGhpcy5fcHJlQ29ubmVjdFNvY2tldHMuZGVsZXRlKHNvY2tldC5pZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiBteU5hbWVzcGFjZS5lbWl0KFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAgICAgKlxuICAgICAqIC8vIGFsbCBzZXJpYWxpemFibGUgZGF0YXN0cnVjdHVyZXMgYXJlIHN1cHBvcnRlZCAobm8gbmVlZCB0byBjYWxsIEpTT04uc3RyaW5naWZ5KVxuICAgICAqIG15TmFtZXNwYWNlLmVtaXQoXCJoZWxsb1wiLCAxLCBcIjJcIiwgeyAzOiBbXCI0XCJdLCA1OiBVaW50OEFycmF5LmZyb20oWzZdKSB9KTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYW4gYWNrbm93bGVkZ2VtZW50IGZyb20gdGhlIGNsaWVudHNcbiAgICAgKiBteU5hbWVzcGFjZS50aW1lb3V0KDEwMDApLmVtaXQoXCJzb21lLWV2ZW50XCIsIChlcnIsIHJlc3BvbnNlcykgPT4ge1xuICAgICAqICAgaWYgKGVycikge1xuICAgICAqICAgICAvLyBzb21lIGNsaWVudHMgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogICB9IGVsc2Uge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXNwb25zZXMpOyAvLyBvbmUgcmVzcG9uc2UgcGVyIGNsaWVudFxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHJldHVybiBBbHdheXMgdHJ1ZVxuICAgICAqL1xuICAgIGVtaXQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudCB0byBhbGwgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1pbWljcyB0aGUgV2ViU29ja2V0LnNlbmQoKSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJTb2NrZXQvc2VuZFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIG15TmFtZXNwYWNlLnNlbmQoXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqIC8vIHRoaXMgaXMgZXF1aXZhbGVudCB0b1xuICAgICAqIG15TmFtZXNwYWNlLmVtaXQoXCJtZXNzYWdlXCIsIFwiaGVsbG9cIik7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBzZW5kKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gVGhpcyB0eXBlLWNhc3QgaXMgbmVlZGVkIGJlY2F1c2UgRW1pdEV2ZW50cyBsaWtlbHkgZG9lc24ndCBoYXZlIGBtZXNzYWdlYCBhcyBhIGtleS5cbiAgICAgICAgLy8gaWYgeW91IHNwZWNpZnkgdGhlIEVtaXRFdmVudHMsIHRoZSB0eXBlIG9mIGFyZ3Mgd2lsbCBiZSBuZXZlci5cbiAgICAgICAgdGhpcy5lbWl0KFwibWVzc2FnZVwiLCAuLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50IHRvIGFsbCBjbGllbnRzLiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC4gQWxpYXMgb2Yge0BsaW5rIHNlbmR9LlxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgd3JpdGUoLi4uYXJncykge1xuICAgICAgICAvLyBUaGlzIHR5cGUtY2FzdCBpcyBuZWVkZWQgYmVjYXVzZSBFbWl0RXZlbnRzIGxpa2VseSBkb2Vzbid0IGhhdmUgYG1lc3NhZ2VgIGFzIGEga2V5LlxuICAgICAgICAvLyBpZiB5b3Ugc3BlY2lmeSB0aGUgRW1pdEV2ZW50cywgdGhlIHR5cGUgb2YgYXJncyB3aWxsIGJlIG5ldmVyLlxuICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBvdGhlciBTb2NrZXQuSU8gc2VydmVycyBvZiB0aGUgY2x1c3Rlci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiBteU5hbWVzcGFjZS5zZXJ2ZXJTaWRlRW1pdChcImhlbGxvXCIsIFwid29ybGRcIik7XG4gICAgICpcbiAgICAgKiBteU5hbWVzcGFjZS5vbihcImhlbGxvXCIsIChhcmcxKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhhcmcxKTsgLy8gcHJpbnRzIFwid29ybGRcIlxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gYWNrbm93bGVkZ2VtZW50cyAod2l0aG91dCBiaW5hcnkgY29udGVudCkgYXJlIHN1cHBvcnRlZCB0b286XG4gICAgICogbXlOYW1lc3BhY2Uuc2VydmVyU2lkZUVtaXQoXCJwaW5nXCIsIChlcnIsIHJlc3BvbnNlcykgPT4ge1xuICAgICAqICBpZiAoZXJyKSB7XG4gICAgICogICAgIC8vIHNvbWUgc2VydmVycyBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiAgIH0gZWxzZSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlcyk7IC8vIG9uZSByZXNwb25zZSBwZXIgc2VydmVyIChleGNlcHQgdGhlIGN1cnJlbnQgb25lKVxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogbXlOYW1lc3BhY2Uub24oXCJwaW5nXCIsIChjYikgPT4ge1xuICAgICAqICAgY2IoXCJwb25nXCIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGV2IC0gdGhlIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0gYXJncyAtIGFuIGFycmF5IG9mIGFyZ3VtZW50cywgd2hpY2ggbWF5IGluY2x1ZGUgYW4gYWNrbm93bGVkZ2VtZW50IGNhbGxiYWNrIGF0IHRoZSBlbmRcbiAgICAgKi9cbiAgICBzZXJ2ZXJTaWRlRW1pdChldiwgLi4uYXJncykge1xuICAgICAgICBpZiAoZXhwb3J0cy5SRVNFUlZFRF9FVkVOVFMuaGFzKGV2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7U3RyaW5nKGV2KX1cIiBpcyBhIHJlc2VydmVkIGV2ZW50IG5hbWVgKTtcbiAgICAgICAgfVxuICAgICAgICBhcmdzLnVuc2hpZnQoZXYpO1xuICAgICAgICB0aGlzLmFkYXB0ZXIuc2VydmVyU2lkZUVtaXQoYXJncyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgYW5kIGV4cGVjdCBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSB0aGUgb3RoZXIgU29ja2V0LklPIHNlcnZlcnMgb2YgdGhlIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogdHJ5IHtcbiAgICAgKiAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IG15TmFtZXNwYWNlLnNlcnZlclNpZGVFbWl0V2l0aEFjayhcInBpbmdcIik7XG4gICAgICogICBjb25zb2xlLmxvZyhyZXNwb25zZXMpOyAvLyBvbmUgcmVzcG9uc2UgcGVyIHNlcnZlciAoZXhjZXB0IHRoZSBjdXJyZW50IG9uZSlcbiAgICAgKiB9IGNhdGNoIChlKSB7XG4gICAgICogICAvLyBzb21lIHNlcnZlcnMgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogfVxuICAgICAqXG4gICAgICogQHBhcmFtIGV2IC0gdGhlIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0gYXJncyAtIGFuIGFycmF5IG9mIGFyZ3VtZW50c1xuICAgICAqXG4gICAgICogQHJldHVybiBhIFByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIGFsbCBzZXJ2ZXJzIGhhdmUgYWNrbm93bGVkZ2VkIHRoZSBldmVudFxuICAgICAqL1xuICAgIHNlcnZlclNpZGVFbWl0V2l0aEFjayhldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgYXJncy5wdXNoKChlcnIsIHJlc3BvbnNlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyLnJlc3BvbnNlcyA9IHJlc3BvbnNlcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyU2lkZUVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBwYWNrZXQgaXMgcmVjZWl2ZWQgZnJvbSBhbm90aGVyIFNvY2tldC5JTyBzZXJ2ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gYW4gYXJyYXkgb2YgYXJndW1lbnRzLCB3aGljaCBtYXkgaW5jbHVkZSBhbiBhY2tub3dsZWRnZW1lbnQgY2FsbGJhY2sgYXQgdGhlIGVuZFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25TZXJ2ZXJTaWRlRW1pdChhcmdzKSB7XG4gICAgICAgIHN1cGVyLmVtaXRVbnR5cGVkLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBjbGllbnRzLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgdGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UsIHBsZWFzZSB1c2Uge0BsaW5rIE5hbWVzcGFjZSNzZXJ2ZXJTaWRlRW1pdH0gb3JcbiAgICAgKiB7QGxpbmsgTmFtZXNwYWNlI2ZldGNoU29ja2V0c30gaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhbGxTb2NrZXRzKCkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikuYWxsU29ja2V0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIG15TmFtZXNwYWNlLmNvbXByZXNzKGZhbHNlKS5lbWl0KFwiaGVsbG9cIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tcHJlc3MgLSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIGNvbXByZXNzKGNvbXByZXNzKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5jb21wcmVzcyhjb21wcmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IGRhdGEgbWF5IGJlIGxvc3QgaWYgdGhlIGNsaWVudCBpcyBub3QgcmVhZHkgdG9cbiAgICAgKiByZWNlaXZlIG1lc3NhZ2VzIChiZWNhdXNlIG9mIG5ldHdvcmsgc2xvd25lc3Mgb3Igb3RoZXIgaXNzdWVzLCBvciBiZWNhdXNlIHRoZXnigJlyZSBjb25uZWN0ZWQgdGhyb3VnaCBsb25nIHBvbGxpbmdcbiAgICAgKiBhbmQgaXMgaW4gdGhlIG1pZGRsZSBvZiBhIHJlcXVlc3QtcmVzcG9uc2UgY3ljbGUpLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIG15TmFtZXNwYWNlLnZvbGF0aWxlLmVtaXQoXCJoZWxsb1wiKTsgLy8gdGhlIGNsaWVudHMgbWF5IG9yIG1heSBub3QgcmVjZWl2ZSBpdFxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgZ2V0IHZvbGF0aWxlKCkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikudm9sYXRpbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IGRhdGEgd2lsbCBvbmx5IGJlIGJyb2FkY2FzdCB0byB0aGUgY3VycmVudCBub2RlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIC8vIHRoZSDigJxmb2/igJ0gZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzIG9uIHRoaXMgbm9kZVxuICAgICAqIG15TmFtZXNwYWNlLmxvY2FsLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZ2V0IGxvY2FsKCkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikubG9jYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIG5leHQgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIG15TmFtZXNwYWNlLnRpbWVvdXQoMTAwMCkuZW1pdChcInNvbWUtZXZlbnRcIiwgKGVyciwgcmVzcG9uc2VzKSA9PiB7XG4gICAgICogICBpZiAoZXJyKSB7XG4gICAgICogICAgIC8vIHNvbWUgY2xpZW50cyBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiAgIH0gZWxzZSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlcyk7IC8vIG9uZSByZXNwb25zZSBwZXIgY2xpZW50XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGltZW91dFxuICAgICAqL1xuICAgIHRpbWVvdXQodGltZW91dCkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikudGltZW91dCh0aW1lb3V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIC8vIHJldHVybiBhbGwgU29ja2V0IGluc3RhbmNlc1xuICAgICAqIGNvbnN0IHNvY2tldHMgPSBhd2FpdCBteU5hbWVzcGFjZS5mZXRjaFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIC8vIHJldHVybiBhbGwgU29ja2V0IGluc3RhbmNlcyBpbiB0aGUgXCJyb29tMVwiIHJvb21cbiAgICAgKiBjb25zdCBzb2NrZXRzID0gYXdhaXQgbXlOYW1lc3BhY2UuaW4oXCJyb29tMVwiKS5mZXRjaFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIGZvciAoY29uc3Qgc29ja2V0IG9mIHNvY2tldHMpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5pZCk7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuaGFuZHNoYWtlKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5yb29tcyk7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuZGF0YSk7XG4gICAgICpcbiAgICAgKiAgIHNvY2tldC5lbWl0KFwiaGVsbG9cIik7XG4gICAgICogICBzb2NrZXQuam9pbihcInJvb20xXCIpO1xuICAgICAqICAgc29ja2V0LmxlYXZlKFwicm9vbTJcIik7XG4gICAgICogICBzb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICBmZXRjaFNvY2tldHMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5mZXRjaFNvY2tldHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgam9pbiB0aGUgc3BlY2lmaWVkIHJvb21zLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBqb2luIHRoZSBcInJvb20xXCIgcm9vbVxuICAgICAqIG15TmFtZXNwYWNlLnNvY2tldHNKb2luKFwicm9vbTFcIik7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbSBqb2luIHRoZSBcInJvb20yXCIgYW5kIFwicm9vbTNcIiByb29tc1xuICAgICAqIG15TmFtZXNwYWNlLmluKFwicm9vbTFcIikuc29ja2V0c0pvaW4oW1wicm9vbTJcIiwgXCJyb29tM1wiXSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKi9cbiAgICBzb2NrZXRzSm9pbihyb29tKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5zb2NrZXRzSm9pbihyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgbGVhdmUgdGhlIHNwZWNpZmllZCByb29tcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgbGVhdmUgdGhlIFwicm9vbTFcIiByb29tXG4gICAgICogbXlOYW1lc3BhY2Uuc29ja2V0c0xlYXZlKFwicm9vbTFcIik7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbSBsZWF2ZSB0aGUgXCJyb29tMlwiIGFuZCBcInJvb20zXCIgcm9vbXNcbiAgICAgKiBteU5hbWVzcGFjZS5pbihcInJvb20xXCIpLnNvY2tldHNMZWF2ZShbXCJyb29tMlwiLCBcInJvb20zXCJdKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqL1xuICAgIHNvY2tldHNMZWF2ZShyb29tKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5zb2NrZXRzTGVhdmUocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGRpc2Nvbm5lY3QuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIHdpdGhpbiBhIGNsdXN0ZXIgb2YgbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBBZGFwdGVyfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGRpc2Nvbm5lY3QgKHRoZSBjb25uZWN0aW9ucyBtaWdodCBiZSBrZXB0IGFsaXZlIGZvciBvdGhlciBuYW1lc3BhY2VzKVxuICAgICAqIG15TmFtZXNwYWNlLmRpc2Nvbm5lY3RTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbSBkaXNjb25uZWN0IGFuZCBjbG9zZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uc1xuICAgICAqIG15TmFtZXNwYWNlLmluKFwicm9vbTFcIikuZGlzY29ubmVjdFNvY2tldHModHJ1ZSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xvc2UgLSB3aGV0aGVyIHRvIGNsb3NlIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0U29ja2V0cyhjbG9zZSA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5kaXNjb25uZWN0U29ja2V0cyhjbG9zZSk7XG4gICAgfVxufVxuZXhwb3J0cy5OYW1lc3BhY2UgPSBOYW1lc3BhY2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/socket.io/dist/namespace.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/socket.io/dist/parent-namespace.js":
/*!*********************************************************!*\
  !*** ./node_modules/socket.io/dist/parent-namespace.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ParentNamespace = void 0;\nconst namespace_1 = __webpack_require__(/*! ./namespace */ \"(action-browser)/./node_modules/socket.io/dist/namespace.js\");\nconst socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ \"(action-browser)/./node_modules/socket.io-adapter/dist/index.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(action-browser)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst debug = (0, debug_1.default)(\"socket.io:parent-namespace\");\n/**\n * A parent namespace is a special {@link Namespace} that holds a list of child namespaces which were created either\n * with a regular expression or with a function.\n *\n * @example\n * const parentNamespace = io.of(/\\/dynamic-\\d+/);\n *\n * parentNamespace.on(\"connection\", (socket) => {\n *   const childNamespace = socket.nsp;\n * }\n *\n * // will reach all the clients that are in one of the child namespaces, like \"/dynamic-101\"\n * parentNamespace.emit(\"hello\", \"world\");\n *\n */\nclass ParentNamespace extends namespace_1.Namespace {\n    constructor(server) {\n        super(server, \"/_\" + ParentNamespace.count++);\n        this.children = new Set();\n    }\n    /**\n     * @private\n     */\n    _initAdapter() {\n        this.adapter = new ParentBroadcastAdapter(this);\n    }\n    emit(ev, ...args) {\n        this.children.forEach((nsp) => {\n            nsp.emit(ev, ...args);\n        });\n        return true;\n    }\n    createChild(name) {\n        debug(\"creating child namespace %s\", name);\n        const namespace = new namespace_1.Namespace(this.server, name);\n        this[\"_fns\"].forEach((fn) => namespace.use(fn));\n        this.listeners(\"connect\").forEach((listener) => namespace.on(\"connect\", listener));\n        this.listeners(\"connection\").forEach((listener) => namespace.on(\"connection\", listener));\n        this.children.add(namespace);\n        if (this.server._opts.cleanupEmptyChildNamespaces) {\n            const remove = namespace._remove;\n            namespace._remove = (socket) => {\n                remove.call(namespace, socket);\n                if (namespace.sockets.size === 0) {\n                    debug(\"closing child namespace %s\", name);\n                    namespace.adapter.close();\n                    this.server._nsps.delete(namespace.name);\n                    this.children.delete(namespace);\n                }\n            };\n        }\n        this.server._nsps.set(name, namespace);\n        // @ts-ignore\n        this.server.sockets.emitReserved(\"new_namespace\", namespace);\n        return namespace;\n    }\n    fetchSockets() {\n        // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\n        // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\n        // the behavior for namespaces created with a function is less clear\n        // note²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\n        // may exist on one node but not exist on another (since it is created upon client connection)\n        throw new Error(\"fetchSockets() is not supported on parent namespaces\");\n    }\n}\nexports.ParentNamespace = ParentNamespace;\nParentNamespace.count = 0;\n/**\n * A dummy adapter that only supports broadcasting to child (concrete) namespaces.\n * @private file\n */\nclass ParentBroadcastAdapter extends socket_io_adapter_1.Adapter {\n    broadcast(packet, opts) {\n        this.nsp.children.forEach((nsp) => {\n            nsp.adapter.broadcast(packet, opts);\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9wYXJlbnQtbmFtZXNwYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLG9CQUFvQixtQkFBTyxDQUFDLGdGQUFhO0FBQ3pDLDRCQUE0QixtQkFBTyxDQUFDLDBGQUFtQjtBQUN2RCxnQ0FBZ0MsbUJBQU8sQ0FBQyx3RkFBTztBQUMvQztBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcnNvbGUvRG9jdW1lbnRzL0dpdEh1Yi9tYXNzaW1pbm8vbWFzc2ltaW5vL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9wYXJlbnQtbmFtZXNwYWNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG5jb25zdCBuYW1lc3BhY2VfMSA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbmNvbnN0IHNvY2tldF9pb19hZGFwdGVyXzEgPSByZXF1aXJlKFwic29ja2V0LmlvLWFkYXB0ZXJcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwic29ja2V0LmlvOnBhcmVudC1uYW1lc3BhY2VcIik7XG4vKipcbiAqIEEgcGFyZW50IG5hbWVzcGFjZSBpcyBhIHNwZWNpYWwge0BsaW5rIE5hbWVzcGFjZX0gdGhhdCBob2xkcyBhIGxpc3Qgb2YgY2hpbGQgbmFtZXNwYWNlcyB3aGljaCB3ZXJlIGNyZWF0ZWQgZWl0aGVyXG4gKiB3aXRoIGEgcmVndWxhciBleHByZXNzaW9uIG9yIHdpdGggYSBmdW5jdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgcGFyZW50TmFtZXNwYWNlID0gaW8ub2YoL1xcL2R5bmFtaWMtXFxkKy8pO1xuICpcbiAqIHBhcmVudE5hbWVzcGFjZS5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICogICBjb25zdCBjaGlsZE5hbWVzcGFjZSA9IHNvY2tldC5uc3A7XG4gKiB9XG4gKlxuICogLy8gd2lsbCByZWFjaCBhbGwgdGhlIGNsaWVudHMgdGhhdCBhcmUgaW4gb25lIG9mIHRoZSBjaGlsZCBuYW1lc3BhY2VzLCBsaWtlIFwiL2R5bmFtaWMtMTAxXCJcbiAqIHBhcmVudE5hbWVzcGFjZS5lbWl0KFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAqXG4gKi9cbmNsYXNzIFBhcmVudE5hbWVzcGFjZSBleHRlbmRzIG5hbWVzcGFjZV8xLk5hbWVzcGFjZSB7XG4gICAgY29uc3RydWN0b3Ioc2VydmVyKSB7XG4gICAgICAgIHN1cGVyKHNlcnZlciwgXCIvX1wiICsgUGFyZW50TmFtZXNwYWNlLmNvdW50KyspO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0QWRhcHRlcigpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyID0gbmV3IFBhcmVudEJyb2FkY2FzdEFkYXB0ZXIodGhpcyk7XG4gICAgfVxuICAgIGVtaXQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChuc3ApID0+IHtcbiAgICAgICAgICAgIG5zcC5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjcmVhdGVDaGlsZChuYW1lKSB7XG4gICAgICAgIGRlYnVnKFwiY3JlYXRpbmcgY2hpbGQgbmFtZXNwYWNlICVzXCIsIG5hbWUpO1xuICAgICAgICBjb25zdCBuYW1lc3BhY2UgPSBuZXcgbmFtZXNwYWNlXzEuTmFtZXNwYWNlKHRoaXMuc2VydmVyLCBuYW1lKTtcbiAgICAgICAgdGhpc1tcIl9mbnNcIl0uZm9yRWFjaCgoZm4pID0+IG5hbWVzcGFjZS51c2UoZm4pKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMoXCJjb25uZWN0XCIpLmZvckVhY2goKGxpc3RlbmVyKSA9PiBuYW1lc3BhY2Uub24oXCJjb25uZWN0XCIsIGxpc3RlbmVyKSk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzKFwiY29ubmVjdGlvblwiKS5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbmFtZXNwYWNlLm9uKFwiY29ubmVjdGlvblwiLCBsaXN0ZW5lcikpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmFkZChuYW1lc3BhY2UpO1xuICAgICAgICBpZiAodGhpcy5zZXJ2ZXIuX29wdHMuY2xlYW51cEVtcHR5Q2hpbGROYW1lc3BhY2VzKSB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmUgPSBuYW1lc3BhY2UuX3JlbW92ZTtcbiAgICAgICAgICAgIG5hbWVzcGFjZS5fcmVtb3ZlID0gKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlbW92ZS5jYWxsKG5hbWVzcGFjZSwgc29ja2V0KTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZXNwYWNlLnNvY2tldHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImNsb3NpbmcgY2hpbGQgbmFtZXNwYWNlICVzXCIsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2UuYWRhcHRlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcnZlci5fbnNwcy5kZWxldGUobmFtZXNwYWNlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmRlbGV0ZShuYW1lc3BhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJ2ZXIuX25zcHMuc2V0KG5hbWUsIG5hbWVzcGFjZSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5zZXJ2ZXIuc29ja2V0cy5lbWl0UmVzZXJ2ZWQoXCJuZXdfbmFtZXNwYWNlXCIsIG5hbWVzcGFjZSk7XG4gICAgICAgIHJldHVybiBuYW1lc3BhY2U7XG4gICAgfVxuICAgIGZldGNoU29ja2V0cygpIHtcbiAgICAgICAgLy8gbm90ZTogd2UgY291bGQgbWFrZSB0aGUgZmV0Y2hTb2NrZXRzKCkgbWV0aG9kIHdvcmsgZm9yIGR5bmFtaWMgbmFtZXNwYWNlcyBjcmVhdGVkIHdpdGggYSByZWdleCAoYnkgc2VuZGluZyB0aGVcbiAgICAgICAgLy8gcmVnZXggdG8gdGhlIG90aGVyIFNvY2tldC5JTyBzZXJ2ZXJzLCBhbmQgcmV0dXJuaW5nIHRoZSBzb2NrZXRzIG9mIGVhY2ggbWF0Y2hpbmcgbmFtZXNwYWNlIGZvciBleGFtcGxlKSwgYnV0XG4gICAgICAgIC8vIHRoZSBiZWhhdmlvciBmb3IgbmFtZXNwYWNlcyBjcmVhdGVkIHdpdGggYSBmdW5jdGlvbiBpcyBsZXNzIGNsZWFyXG4gICAgICAgIC8vIG5vdGXCsjogd2UgY2Fubm90IGxvb3Agb3ZlciBlYWNoIGNoaWxkcmVuIG5hbWVzcGFjZSwgYmVjYXVzZSB3aXRoIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCBhIGdpdmVuIG5hbWVzcGFjZVxuICAgICAgICAvLyBtYXkgZXhpc3Qgb24gb25lIG5vZGUgYnV0IG5vdCBleGlzdCBvbiBhbm90aGVyIChzaW5jZSBpdCBpcyBjcmVhdGVkIHVwb24gY2xpZW50IGNvbm5lY3Rpb24pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZldGNoU29ja2V0cygpIGlzIG5vdCBzdXBwb3J0ZWQgb24gcGFyZW50IG5hbWVzcGFjZXNcIik7XG4gICAgfVxufVxuZXhwb3J0cy5QYXJlbnROYW1lc3BhY2UgPSBQYXJlbnROYW1lc3BhY2U7XG5QYXJlbnROYW1lc3BhY2UuY291bnQgPSAwO1xuLyoqXG4gKiBBIGR1bW15IGFkYXB0ZXIgdGhhdCBvbmx5IHN1cHBvcnRzIGJyb2FkY2FzdGluZyB0byBjaGlsZCAoY29uY3JldGUpIG5hbWVzcGFjZXMuXG4gKiBAcHJpdmF0ZSBmaWxlXG4gKi9cbmNsYXNzIFBhcmVudEJyb2FkY2FzdEFkYXB0ZXIgZXh0ZW5kcyBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIge1xuICAgIGJyb2FkY2FzdChwYWNrZXQsIG9wdHMpIHtcbiAgICAgICAgdGhpcy5uc3AuY2hpbGRyZW4uZm9yRWFjaCgobnNwKSA9PiB7XG4gICAgICAgICAgICBuc3AuYWRhcHRlci5icm9hZGNhc3QocGFja2V0LCBvcHRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/socket.io/dist/parent-namespace.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/socket.io/dist/socket-types.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io/dist/socket-types.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RESERVED_EVENTS = void 0;\nexports.RESERVED_EVENTS = new Set([\n    \"connect\",\n    \"connect_error\",\n    \"disconnect\",\n    \"disconnecting\",\n    \"newListener\",\n    \"removeListener\",\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9zb2NrZXQtdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcnNvbGUvRG9jdW1lbnRzL0dpdEh1Yi9tYXNzaW1pbm8vbWFzc2ltaW5vL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9zb2NrZXQtdHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJFU0VSVkVEX0VWRU5UUyA9IHZvaWQgMDtcbmV4cG9ydHMuUkVTRVJWRURfRVZFTlRTID0gbmV3IFNldChbXG4gICAgXCJjb25uZWN0XCIsXG4gICAgXCJjb25uZWN0X2Vycm9yXCIsXG4gICAgXCJkaXNjb25uZWN0XCIsXG4gICAgXCJkaXNjb25uZWN0aW5nXCIsXG4gICAgXCJuZXdMaXN0ZW5lclwiLFxuICAgIFwicmVtb3ZlTGlzdGVuZXJcIixcbl0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/socket.io/dist/socket-types.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/socket.io/dist/socket.js":
/*!***********************************************!*\
  !*** ./node_modules/socket.io/dist/socket.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Socket = void 0;\nconst socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ \"(action-browser)/./node_modules/socket.io-parser/build/cjs/index.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(action-browser)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst typed_events_1 = __webpack_require__(/*! ./typed-events */ \"(action-browser)/./node_modules/socket.io/dist/typed-events.js\");\nconst base64id_1 = __importDefault(__webpack_require__(/*! base64id */ \"(action-browser)/./node_modules/base64id/lib/base64id.js\"));\nconst broadcast_operator_1 = __webpack_require__(/*! ./broadcast-operator */ \"(action-browser)/./node_modules/socket.io/dist/broadcast-operator.js\");\nconst socket_types_1 = __webpack_require__(/*! ./socket-types */ \"(action-browser)/./node_modules/socket.io/dist/socket-types.js\");\nconst debug = (0, debug_1.default)(\"socket.io:socket\");\nconst RECOVERABLE_DISCONNECT_REASONS = new Set([\n    \"transport error\",\n    \"transport close\",\n    \"forced close\",\n    \"ping timeout\",\n    \"server shutting down\",\n    \"forced server close\",\n]);\nfunction noop() { }\n/**\n * This is the main object for interacting with a client.\n *\n * A Socket belongs to a given {@link Namespace} and uses an underlying {@link Client} to communicate.\n *\n * Within each {@link Namespace}, you can also define arbitrary channels (called \"rooms\") that the {@link Socket} can\n * join and leave. That provides a convenient way to broadcast to a group of socket instances.\n *\n * @example\n * io.on(\"connection\", (socket) => {\n *   console.log(`socket ${socket.id} connected`);\n *\n *   // send an event to the client\n *   socket.emit(\"foo\", \"bar\");\n *\n *   socket.on(\"foobar\", () => {\n *     // an event was received from the client\n *   });\n *\n *   // join the room named \"room1\"\n *   socket.join(\"room1\");\n *\n *   // broadcast to everyone in the room named \"room1\"\n *   io.to(\"room1\").emit(\"hello\");\n *\n *   // upon disconnection\n *   socket.on(\"disconnect\", (reason) => {\n *     console.log(`socket ${socket.id} disconnected due to ${reason}`);\n *   });\n * });\n */\nclass Socket extends typed_events_1.StrictEventEmitter {\n    /**\n     * Interface to a `Client` for a given `Namespace`.\n     *\n     * @param {Namespace} nsp\n     * @param {Client} client\n     * @param {Object} auth\n     * @package\n     */\n    constructor(nsp, client, auth, previousSession) {\n        super();\n        this.nsp = nsp;\n        this.client = client;\n        /**\n         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\n         * be transmitted to the client, the data attribute and the rooms will be restored.\n         */\n        this.recovered = false;\n        /**\n         * Additional information that can be attached to the Socket instance and which will be used in the\n         * {@link Server.fetchSockets()} method.\n         */\n        this.data = {};\n        /**\n         * Whether the socket is currently connected or not.\n         *\n         * @example\n         * io.use((socket, next) => {\n         *   console.log(socket.connected); // false\n         *   next();\n         * });\n         *\n         * io.on(\"connection\", (socket) => {\n         *   console.log(socket.connected); // true\n         * });\n         */\n        this.connected = false;\n        this.acks = new Map();\n        this.fns = [];\n        this.flags = {};\n        this.server = nsp.server;\n        this.adapter = this.nsp.adapter;\n        if (previousSession) {\n            this.id = previousSession.sid;\n            this.pid = previousSession.pid;\n            previousSession.rooms.forEach((room) => this.join(room));\n            this.data = previousSession.data;\n            previousSession.missedPackets.forEach((packet) => {\n                this.packet({\n                    type: socket_io_parser_1.PacketType.EVENT,\n                    data: packet,\n                });\n            });\n            this.recovered = true;\n        }\n        else {\n            if (client.conn.protocol === 3) {\n                // @ts-ignore\n                this.id = nsp.name !== \"/\" ? nsp.name + \"#\" + client.id : client.id;\n            }\n            else {\n                this.id = base64id_1.default.generateId(); // don't reuse the Engine.IO id because it's sensitive information\n            }\n            if (this.server._opts.connectionStateRecovery) {\n                this.pid = base64id_1.default.generateId();\n            }\n        }\n        this.handshake = this.buildHandshake(auth);\n        // prevents crash when the socket receives an \"error\" event without listener\n        this.on(\"error\", noop);\n    }\n    /**\n     * Builds the `handshake` BC object\n     *\n     * @private\n     */\n    buildHandshake(auth) {\n        var _a, _b, _c, _d;\n        return {\n            headers: ((_a = this.request) === null || _a === void 0 ? void 0 : _a.headers) || {},\n            time: new Date() + \"\",\n            address: this.conn.remoteAddress,\n            xdomain: !!((_b = this.request) === null || _b === void 0 ? void 0 : _b.headers.origin),\n            // @ts-ignore\n            secure: !this.request || !!this.request.connection.encrypted,\n            issued: +new Date(),\n            url: (_c = this.request) === null || _c === void 0 ? void 0 : _c.url,\n            // @ts-ignore\n            query: ((_d = this.request) === null || _d === void 0 ? void 0 : _d._query) || {},\n            auth,\n        };\n    }\n    /**\n     * Emits to this client.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.emit(\"hello\", \"world\");\n     *\n     *   // all serializable datastructures are supported (no need to call JSON.stringify)\n     *   socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Buffer.from([6]) });\n     *\n     *   // with an acknowledgement from the client\n     *   socket.emit(\"hello\", \"world\", (val) => {\n     *     // ...\n     *   });\n     * });\n     *\n     * @return Always returns `true`.\n     */\n    emit(ev, ...args) {\n        if (socket_types_1.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${String(ev)}\" is a reserved event name`);\n        }\n        const data = [ev, ...args];\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: data,\n        };\n        // access last argument to see if it's an ACK callback\n        if (typeof data[data.length - 1] === \"function\") {\n            const id = this.nsp._ids++;\n            debug(\"emitting packet with ack id %d\", id);\n            this.registerAckCallback(id, data.pop());\n            packet.id = id;\n        }\n        const flags = Object.assign({}, this.flags);\n        this.flags = {};\n        // @ts-ignore\n        if (this.nsp.server.opts.connectionStateRecovery) {\n            // this ensures the packet is stored and can be transmitted upon reconnection\n            this.adapter.broadcast(packet, {\n                rooms: new Set([this.id]),\n                except: new Set(),\n                flags,\n            });\n        }\n        else {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet, flags);\n        }\n        return true;\n    }\n    /**\n     * Emits an event and waits for an acknowledgement\n     *\n     * @example\n     * io.on(\"connection\", async (socket) => {\n     *   // without timeout\n     *   const response = await socket.emitWithAck(\"hello\", \"world\");\n     *\n     *   // with a specific timeout\n     *   try {\n     *     const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n     *   } catch (err) {\n     *     // the client did not acknowledge the event in the given delay\n     *   }\n     * });\n     *\n     * @return a Promise that will be fulfilled when the client acknowledges the event\n     */\n    emitWithAck(ev, ...args) {\n        // the timeout flag is optional\n        const withErr = this.flags.timeout !== undefined;\n        return new Promise((resolve, reject) => {\n            args.push((arg1, arg2) => {\n                if (withErr) {\n                    return arg1 ? reject(arg1) : resolve(arg2);\n                }\n                else {\n                    return resolve(arg1);\n                }\n            });\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * @private\n     */\n    registerAckCallback(id, ack) {\n        const timeout = this.flags.timeout;\n        if (timeout === undefined) {\n            this.acks.set(id, ack);\n            return;\n        }\n        const timer = setTimeout(() => {\n            debug(\"event with ack id %d has timed out after %d ms\", id, timeout);\n            this.acks.delete(id);\n            ack.call(this, new Error(\"operation has timed out\"));\n        }, timeout);\n        this.acks.set(id, (...args) => {\n            clearTimeout(timer);\n            ack.apply(this, [null, ...args]);\n        });\n    }\n    /**\n     * Targets a room when broadcasting.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the “foo” event will be broadcast to all connected clients in the “room-101” room, except this socket\n     *   socket.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     *   // the code above is equivalent to:\n     *   io.to(\"room-101\").except(socket.id).emit(\"foo\", \"bar\");\n     *\n     *   // with an array of rooms (a client will be notified at most once)\n     *   socket.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     *   // with multiple chained calls\n     *   socket.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    to(room) {\n        return this.newBroadcastOperator().to(room);\n    }\n    /**\n     * Targets a room when broadcasting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // disconnect all clients in the \"room-101\" room, except this socket\n     *   socket.in(\"room-101\").disconnectSockets();\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    in(room) {\n        return this.newBroadcastOperator().in(room);\n    }\n    /**\n     * Excludes a room when broadcasting.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     *   // and this socket\n     *   socket.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     *   // with an array of rooms\n     *   socket.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     *   // with multiple chained calls\n     *   socket.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    except(room) {\n        return this.newBroadcastOperator().except(room);\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.send(\"hello\");\n     *\n     *   // this is equivalent to\n     *   socket.emit(\"message\", \"hello\");\n     * });\n     *\n     * @return self\n     */\n    send(...args) {\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a `message` event. Alias of {@link send}.\n     *\n     * @return self\n     */\n    write(...args) {\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param {Object} packet - packet object\n     * @param {Object} opts - options\n     * @private\n     */\n    packet(packet, opts = {}) {\n        packet.nsp = this.nsp.name;\n        opts.compress = false !== opts.compress;\n        this.client._packet(packet, opts);\n    }\n    /**\n     * Joins a room.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // join a single room\n     *   socket.join(\"room1\");\n     *\n     *   // join multiple rooms\n     *   socket.join([\"room1\", \"room2\"]);\n     * });\n     *\n     * @param {String|Array} rooms - room or array of rooms\n     * @return a Promise or nothing, depending on the adapter\n     */\n    join(rooms) {\n        debug(\"join room %s\", rooms);\n        return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [rooms]));\n    }\n    /**\n     * Leaves a room.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // leave a single room\n     *   socket.leave(\"room1\");\n     *\n     *   // leave multiple rooms\n     *   socket.leave(\"room1\").leave(\"room2\");\n     * });\n     *\n     * @param {String} room\n     * @return a Promise or nothing, depending on the adapter\n     */\n    leave(room) {\n        debug(\"leave room %s\", room);\n        return this.adapter.del(this.id, room);\n    }\n    /**\n     * Leave all rooms.\n     *\n     * @private\n     */\n    leaveAll() {\n        this.adapter.delAll(this.id);\n    }\n    /**\n     * Called by `Namespace` upon successful\n     * middleware execution (ie: authorization).\n     * Socket is added to namespace array before\n     * call to join, so adapters can access it.\n     *\n     * @private\n     */\n    _onconnect() {\n        debug(\"socket connected - writing packet\");\n        this.connected = true;\n        this.join(this.id);\n        if (this.conn.protocol === 3) {\n            this.packet({ type: socket_io_parser_1.PacketType.CONNECT });\n        }\n        else {\n            this.packet({\n                type: socket_io_parser_1.PacketType.CONNECT,\n                data: { sid: this.id, pid: this.pid },\n            });\n        }\n    }\n    /**\n     * Called with each packet. Called by `Client`.\n     *\n     * @param {Object} packet\n     * @private\n     */\n    _onpacket(packet) {\n        debug(\"got packet %j\", packet);\n        switch (packet.type) {\n            case socket_io_parser_1.PacketType.EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n        }\n    }\n    /**\n     * Called upon event packet.\n     *\n     * @param {Packet} packet - packet object\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        debug(\"emitting event %j\", args);\n        if (null != packet.id) {\n            debug(\"attaching ack callback to event\");\n            args.push(this.ack(packet.id));\n        }\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        this.dispatch(args);\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @param {Number} id - packet id\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function () {\n            // prevent double callbacks\n            if (sent)\n                return;\n            const args = Array.prototype.slice.call(arguments);\n            debug(\"sending ack %j\", args);\n            self.packet({\n                id: id,\n                type: socket_io_parser_1.PacketType.ACK,\n                data: args,\n            });\n            sent = true;\n        };\n    }\n    /**\n     * Called upon ack packet.\n     *\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks.get(packet.id);\n        if (\"function\" == typeof ack) {\n            debug(\"calling ack %s with %j\", packet.id, packet.data);\n            ack.apply(this, packet.data);\n            this.acks.delete(packet.id);\n        }\n        else {\n            debug(\"bad ack %s\", packet.id);\n        }\n    }\n    /**\n     * Called upon client disconnect packet.\n     *\n     * @private\n     */\n    ondisconnect() {\n        debug(\"got disconnect packet\");\n        this._onclose(\"client namespace disconnect\");\n    }\n    /**\n     * Handles a client error.\n     *\n     * @private\n     */\n    _onerror(err) {\n        // FIXME the meaning of the \"error\" event is overloaded:\n        //  - it can be sent by the client (`socket.emit(\"error\")`)\n        //  - it can be emitted when the connection encounters an error (an invalid packet for example)\n        //  - it can be emitted when a packet is rejected in a middleware (`socket.use()`)\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Called upon closing. Called by `Client`.\n     *\n     * @param {String} reason\n     * @param description\n     * @throw {Error} optional error object\n     *\n     * @private\n     */\n    _onclose(reason, description) {\n        if (!this.connected)\n            return this;\n        debug(\"closing socket - reason %s\", reason);\n        this.emitReserved(\"disconnecting\", reason, description);\n        if (this.server._opts.connectionStateRecovery &&\n            RECOVERABLE_DISCONNECT_REASONS.has(reason)) {\n            debug(\"connection state recovery is enabled for sid %s\", this.id);\n            this.adapter.persistSession({\n                sid: this.id,\n                pid: this.pid,\n                rooms: [...this.rooms],\n                data: this.data,\n            });\n        }\n        this._cleanup();\n        this.client._remove(this);\n        this.connected = false;\n        this.emitReserved(\"disconnect\", reason, description);\n        return;\n    }\n    /**\n     * Makes the socket leave all the rooms it was part of and prevents it from joining any other room\n     *\n     * @private\n     */\n    _cleanup() {\n        this.leaveAll();\n        this.nsp._remove(this);\n        this.join = noop;\n    }\n    /**\n     * Produces an `error` packet.\n     *\n     * @param {Object} err - error object\n     *\n     * @private\n     */\n    _error(err) {\n        this.packet({ type: socket_io_parser_1.PacketType.CONNECT_ERROR, data: err });\n    }\n    /**\n     * Disconnects this client.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // disconnect this socket (the connection might be kept alive for other namespaces)\n     *   socket.disconnect();\n     *\n     *   // disconnect this socket and close the underlying connection\n     *   socket.disconnect(true);\n     * })\n     *\n     * @param {Boolean} close - if `true`, closes the underlying connection\n     * @return self\n     */\n    disconnect(close = false) {\n        if (!this.connected)\n            return this;\n        if (close) {\n            this.client._disconnect();\n        }\n        else {\n            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });\n            this._onclose(\"server namespace disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.compress(false).emit(\"hello\");\n     * });\n     *\n     * @param {Boolean} compress - if `true`, compresses the sending data\n     * @return {Socket} self\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.volatile.emit(\"hello\"); // the client may or may not receive it\n     * });\n     *\n     * @return {Socket} self\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the\n     * sender.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the “foo” event will be broadcast to all connected clients, except this socket\n     *   socket.broadcast.emit(\"foo\", \"bar\");\n     * });\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    get broadcast() {\n        return this.newBroadcastOperator();\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the “foo” event will be broadcast to all connected clients on this node, except this socket\n     *   socket.local.emit(\"foo\", \"bar\");\n     * });\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    get local() {\n        return this.newBroadcastOperator().local;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n     * given number of milliseconds have elapsed without an acknowledgement from the client:\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.timeout(5000).emit(\"my-event\", (err) => {\n     *     if (err) {\n     *       // the client did not acknowledge the event in the given delay\n     *     }\n     *   });\n     * });\n     *\n     * @returns self\n     */\n    timeout(timeout) {\n        this.flags.timeout = timeout;\n        return this;\n    }\n    /**\n     * Dispatch incoming event to socket listeners.\n     *\n     * @param {Array} event - event that will get emitted\n     * @private\n     */\n    dispatch(event) {\n        debug(\"dispatching an event %j\", event);\n        this.run(event, (err) => {\n            process.nextTick(() => {\n                if (err) {\n                    return this._onerror(err);\n                }\n                if (this.connected) {\n                    super.emitUntyped.apply(this, event);\n                }\n                else {\n                    debug(\"ignore packet received after disconnection\");\n                }\n            });\n        });\n    }\n    /**\n     * Sets up socket middleware.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.use(([event, ...args], next) => {\n     *     if (isUnauthorized(event)) {\n     *       return next(new Error(\"unauthorized event\"));\n     *     }\n     *     // do not forget to call next\n     *     next();\n     *   });\n     *\n     *   socket.on(\"error\", (err) => {\n     *     if (err && err.message === \"unauthorized event\") {\n     *       socket.disconnect();\n     *     }\n     *   });\n     * });\n     *\n     * @param {Function} fn - middleware function (event, next)\n     * @return {Socket} self\n     */\n    use(fn) {\n        this.fns.push(fn);\n        return this;\n    }\n    /**\n     * Executes the middleware for an incoming event.\n     *\n     * @param {Array} event - event that will get emitted\n     * @param {Function} fn - last fn call in the middleware\n     * @private\n     */\n    run(event, fn) {\n        if (!this.fns.length)\n            return fn();\n        const fns = this.fns.slice(0);\n        function run(i) {\n            fns[i](event, (err) => {\n                // upon error, short-circuit\n                if (err)\n                    return fn(err);\n                // if no middleware left, summon callback\n                if (!fns[i + 1])\n                    return fn();\n                // go on to next\n                run(i + 1);\n            });\n        }\n        run(0);\n    }\n    /**\n     * Whether the socket is currently disconnected\n     */\n    get disconnected() {\n        return !this.connected;\n    }\n    /**\n     * A reference to the request that originated the underlying Engine.IO Socket.\n     */\n    get request() {\n        return this.client.request;\n    }\n    /**\n     * A reference to the underlying Client transport connection (Engine.IO Socket object).\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   console.log(socket.conn.transport.name); // prints \"polling\" or \"websocket\"\n     *\n     *   socket.conn.once(\"upgrade\", () => {\n     *     console.log(socket.conn.transport.name); // prints \"websocket\"\n     *   });\n     * });\n     */\n    get conn() {\n        return this.client.conn;\n    }\n    /**\n     * Returns the rooms the socket is currently in.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   console.log(socket.rooms); // Set { <socket.id> }\n     *\n     *   socket.join(\"room1\");\n     *\n     *   console.log(socket.rooms); // Set { <socket.id>, \"room1\" }\n     * });\n     */\n    get rooms() {\n        return this.adapter.socketRooms(this.id) || new Set();\n    }\n    /**\n     * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to\n     * the callback.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.onAny((event, ...args) => {\n     *     console.log(`got event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to\n     * the callback. The listener is added to the beginning of the listeners array.\n     *\n     * @param listener\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is received.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   const catchAllListener = (event, ...args) => {\n     *     console.log(`got event ${event}`);\n     *   }\n     *\n     *   socket.onAny(catchAllListener);\n     *\n     *   // remove a specific listener\n     *   socket.offAny(catchAllListener);\n     *\n     *   // or remove all listeners\n     *   socket.offAny();\n     * });\n     *\n     * @param listener\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n    /**\n     * Adds a listener that will be fired when any event is sent. The event name is passed as the first argument to\n     * the callback.\n     *\n     * Note: acknowledgements sent to the client are not included.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.onAnyOutgoing((event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */\n    onAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.prependAnyOutgoing((event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */\n    prependAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is sent.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   const catchAllListener = (event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   }\n     *\n     *   socket.onAnyOutgoing(catchAllListener);\n     *\n     *   // remove a specific listener\n     *   socket.offAnyOutgoing(catchAllListener);\n     *\n     *   // or remove all listeners\n     *   socket.offAnyOutgoing();\n     * });\n     *\n     * @param listener - the catch-all listener\n     */\n    offAnyOutgoing(listener) {\n        if (!this._anyOutgoingListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyOutgoingListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyOutgoingListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAnyOutgoing() {\n        return this._anyOutgoingListeners || [];\n    }\n    /**\n     * Notify the listeners for each packet sent (emit or broadcast)\n     *\n     * @param packet\n     *\n     * @private\n     */\n    notifyOutgoingListeners(packet) {\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n            const listeners = this._anyOutgoingListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, packet.data);\n            }\n        }\n    }\n    newBroadcastOperator() {\n        const flags = Object.assign({}, this.flags);\n        this.flags = {};\n        return new broadcast_operator_1.BroadcastOperator(this.adapter, new Set(), new Set([this.id]), flags);\n    }\n}\nexports.Socket = Socket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9zb2NrZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsMkJBQTJCLG1CQUFPLENBQUMsNkZBQWtCO0FBQ3JELGdDQUFnQyxtQkFBTyxDQUFDLHdGQUFPO0FBQy9DLHVCQUF1QixtQkFBTyxDQUFDLHNGQUFnQjtBQUMvQyxtQ0FBbUMsbUJBQU8sQ0FBQywwRUFBVTtBQUNyRCw2QkFBNkIsbUJBQU8sQ0FBQyxrR0FBc0I7QUFDM0QsdUJBQXVCLG1CQUFPLENBQUMsc0ZBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQix3QkFBd0IsY0FBYztBQUN2RjtBQUNBLGdCQUFnQixnQkFBZ0Isb0VBQW9FLGNBQWM7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVcsc0JBQXNCLE9BQU87QUFDckUsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBNkM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkJBQTZCO0FBQ3JELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOERBQThEO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdEQUFnRDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsUUFBUTtBQUNSO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUMsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxNQUFNO0FBQzNDLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE1BQU07QUFDM0MsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE1BQU07QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yc29sZS9Eb2N1bWVudHMvR2l0SHViL21hc3NpbWluby9tYXNzaW1pbm8vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9kaXN0L3NvY2tldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU29ja2V0ID0gdm9pZCAwO1xuY29uc3Qgc29ja2V0X2lvX3BhcnNlcl8xID0gcmVxdWlyZShcInNvY2tldC5pby1wYXJzZXJcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCB0eXBlZF9ldmVudHNfMSA9IHJlcXVpcmUoXCIuL3R5cGVkLWV2ZW50c1wiKTtcbmNvbnN0IGJhc2U2NGlkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJhc2U2NGlkXCIpKTtcbmNvbnN0IGJyb2FkY2FzdF9vcGVyYXRvcl8xID0gcmVxdWlyZShcIi4vYnJvYWRjYXN0LW9wZXJhdG9yXCIpO1xuY29uc3Qgc29ja2V0X3R5cGVzXzEgPSByZXF1aXJlKFwiLi9zb2NrZXQtdHlwZXNcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwic29ja2V0LmlvOnNvY2tldFwiKTtcbmNvbnN0IFJFQ09WRVJBQkxFX0RJU0NPTk5FQ1RfUkVBU09OUyA9IG5ldyBTZXQoW1xuICAgIFwidHJhbnNwb3J0IGVycm9yXCIsXG4gICAgXCJ0cmFuc3BvcnQgY2xvc2VcIixcbiAgICBcImZvcmNlZCBjbG9zZVwiLFxuICAgIFwicGluZyB0aW1lb3V0XCIsXG4gICAgXCJzZXJ2ZXIgc2h1dHRpbmcgZG93blwiLFxuICAgIFwiZm9yY2VkIHNlcnZlciBjbG9zZVwiLFxuXSk7XG5mdW5jdGlvbiBub29wKCkgeyB9XG4vKipcbiAqIFRoaXMgaXMgdGhlIG1haW4gb2JqZWN0IGZvciBpbnRlcmFjdGluZyB3aXRoIGEgY2xpZW50LlxuICpcbiAqIEEgU29ja2V0IGJlbG9uZ3MgdG8gYSBnaXZlbiB7QGxpbmsgTmFtZXNwYWNlfSBhbmQgdXNlcyBhbiB1bmRlcmx5aW5nIHtAbGluayBDbGllbnR9IHRvIGNvbW11bmljYXRlLlxuICpcbiAqIFdpdGhpbiBlYWNoIHtAbGluayBOYW1lc3BhY2V9LCB5b3UgY2FuIGFsc28gZGVmaW5lIGFyYml0cmFyeSBjaGFubmVscyAoY2FsbGVkIFwicm9vbXNcIikgdGhhdCB0aGUge0BsaW5rIFNvY2tldH0gY2FuXG4gKiBqb2luIGFuZCBsZWF2ZS4gVGhhdCBwcm92aWRlcyBhIGNvbnZlbmllbnQgd2F5IHRvIGJyb2FkY2FzdCB0byBhIGdyb3VwIG9mIHNvY2tldCBpbnN0YW5jZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKGBzb2NrZXQgJHtzb2NrZXQuaWR9IGNvbm5lY3RlZGApO1xuICpcbiAqICAgLy8gc2VuZCBhbiBldmVudCB0byB0aGUgY2xpZW50XG4gKiAgIHNvY2tldC5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICpcbiAqICAgc29ja2V0Lm9uKFwiZm9vYmFyXCIsICgpID0+IHtcbiAqICAgICAvLyBhbiBldmVudCB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgY2xpZW50XG4gKiAgIH0pO1xuICpcbiAqICAgLy8gam9pbiB0aGUgcm9vbSBuYW1lZCBcInJvb20xXCJcbiAqICAgc29ja2V0LmpvaW4oXCJyb29tMVwiKTtcbiAqXG4gKiAgIC8vIGJyb2FkY2FzdCB0byBldmVyeW9uZSBpbiB0aGUgcm9vbSBuYW1lZCBcInJvb20xXCJcbiAqICAgaW8udG8oXCJyb29tMVwiKS5lbWl0KFwiaGVsbG9cIik7XG4gKlxuICogICAvLyB1cG9uIGRpc2Nvbm5lY3Rpb25cbiAqICAgc29ja2V0Lm9uKFwiZGlzY29ubmVjdFwiLCAocmVhc29uKSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coYHNvY2tldCAke3NvY2tldC5pZH0gZGlzY29ubmVjdGVkIGR1ZSB0byAke3JlYXNvbn1gKTtcbiAqICAgfSk7XG4gKiB9KTtcbiAqL1xuY2xhc3MgU29ja2V0IGV4dGVuZHMgdHlwZWRfZXZlbnRzXzEuU3RyaWN0RXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBJbnRlcmZhY2UgdG8gYSBgQ2xpZW50YCBmb3IgYSBnaXZlbiBgTmFtZXNwYWNlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TmFtZXNwYWNlfSBuc3BcbiAgICAgKiBAcGFyYW0ge0NsaWVudH0gY2xpZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF1dGhcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5zcCwgY2xpZW50LCBhdXRoLCBwcmV2aW91c1Nlc3Npb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uc3AgPSBuc3A7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY29ubmVjdGlvbiBzdGF0ZSB3YXMgcmVjb3ZlcmVkIGFmdGVyIGEgdGVtcG9yYXJ5IGRpc2Nvbm5lY3Rpb24uIEluIHRoYXQgY2FzZSwgYW55IG1pc3NlZCBwYWNrZXRzIHdpbGxcbiAgICAgICAgICogYmUgdHJhbnNtaXR0ZWQgdG8gdGhlIGNsaWVudCwgdGhlIGRhdGEgYXR0cmlidXRlIGFuZCB0aGUgcm9vbXMgd2lsbCBiZSByZXN0b3JlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVjb3ZlcmVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBTb2NrZXQgaW5zdGFuY2UgYW5kIHdoaWNoIHdpbGwgYmUgdXNlZCBpbiB0aGVcbiAgICAgICAgICoge0BsaW5rIFNlcnZlci5mZXRjaFNvY2tldHMoKX0gbWV0aG9kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBzb2NrZXQgaXMgY3VycmVudGx5IGNvbm5lY3RlZCBvciBub3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGlvLnVzZSgoc29ja2V0LCBuZXh0KSA9PiB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmNvbm5lY3RlZCk7IC8vIGZhbHNlXG4gICAgICAgICAqICAgbmV4dCgpO1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuY29ubmVjdGVkKTsgLy8gdHJ1ZVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWNrcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5mbnMgPSBbXTtcbiAgICAgICAgdGhpcy5mbGFncyA9IHt9O1xuICAgICAgICB0aGlzLnNlcnZlciA9IG5zcC5zZXJ2ZXI7XG4gICAgICAgIHRoaXMuYWRhcHRlciA9IHRoaXMubnNwLmFkYXB0ZXI7XG4gICAgICAgIGlmIChwcmV2aW91c1Nlc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBwcmV2aW91c1Nlc3Npb24uc2lkO1xuICAgICAgICAgICAgdGhpcy5waWQgPSBwcmV2aW91c1Nlc3Npb24ucGlkO1xuICAgICAgICAgICAgcHJldmlvdXNTZXNzaW9uLnJvb21zLmZvckVhY2goKHJvb20pID0+IHRoaXMuam9pbihyb29tKSk7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBwcmV2aW91c1Nlc3Npb24uZGF0YTtcbiAgICAgICAgICAgIHByZXZpb3VzU2Vzc2lvbi5taXNzZWRQYWNrZXRzLmZvckVhY2goKHBhY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGFja2V0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRVZFTlQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHBhY2tldCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNsaWVudC5jb25uLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRoaXMuaWQgPSBuc3AubmFtZSAhPT0gXCIvXCIgPyBuc3AubmFtZSArIFwiI1wiICsgY2xpZW50LmlkIDogY2xpZW50LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IGJhc2U2NGlkXzEuZGVmYXVsdC5nZW5lcmF0ZUlkKCk7IC8vIGRvbid0IHJldXNlIHRoZSBFbmdpbmUuSU8gaWQgYmVjYXVzZSBpdCdzIHNlbnNpdGl2ZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VydmVyLl9vcHRzLmNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waWQgPSBiYXNlNjRpZF8xLmRlZmF1bHQuZ2VuZXJhdGVJZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZHNoYWtlID0gdGhpcy5idWlsZEhhbmRzaGFrZShhdXRoKTtcbiAgICAgICAgLy8gcHJldmVudHMgY3Jhc2ggd2hlbiB0aGUgc29ja2V0IHJlY2VpdmVzIGFuIFwiZXJyb3JcIiBldmVudCB3aXRob3V0IGxpc3RlbmVyXG4gICAgICAgIHRoaXMub24oXCJlcnJvclwiLCBub29wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIHRoZSBgaGFuZHNoYWtlYCBCQyBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnVpbGRIYW5kc2hha2UoYXV0aCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWFkZXJzOiAoKF9hID0gdGhpcy5yZXF1ZXN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhZGVycykgfHwge30sXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpICsgXCJcIixcbiAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuY29ubi5yZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgeGRvbWFpbjogISEoKF9iID0gdGhpcy5yZXF1ZXN0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVhZGVycy5vcmlnaW4pLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgc2VjdXJlOiAhdGhpcy5yZXF1ZXN0IHx8ICEhdGhpcy5yZXF1ZXN0LmNvbm5lY3Rpb24uZW5jcnlwdGVkLFxuICAgICAgICAgICAgaXNzdWVkOiArbmV3IERhdGUoKSxcbiAgICAgICAgICAgIHVybDogKF9jID0gdGhpcy5yZXF1ZXN0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcXVlcnk6ICgoX2QgPSB0aGlzLnJlcXVlc3QpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5fcXVlcnkpIHx8IHt9LFxuICAgICAgICAgICAgYXV0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgdG8gdGhpcyBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBzb2NrZXQuZW1pdChcImhlbGxvXCIsIFwid29ybGRcIik7XG4gICAgICpcbiAgICAgKiAgIC8vIGFsbCBzZXJpYWxpemFibGUgZGF0YXN0cnVjdHVyZXMgYXJlIHN1cHBvcnRlZCAobm8gbmVlZCB0byBjYWxsIEpTT04uc3RyaW5naWZ5KVxuICAgICAqICAgc29ja2V0LmVtaXQoXCJoZWxsb1wiLCAxLCBcIjJcIiwgeyAzOiBbXCI0XCJdLCA1OiBCdWZmZXIuZnJvbShbNl0pIH0pO1xuICAgICAqXG4gICAgICogICAvLyB3aXRoIGFuIGFja25vd2xlZGdlbWVudCBmcm9tIHRoZSBjbGllbnRcbiAgICAgKiAgIHNvY2tldC5lbWl0KFwiaGVsbG9cIiwgXCJ3b3JsZFwiLCAodmFsKSA9PiB7XG4gICAgICogICAgIC8vIC4uLlxuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEFsd2F5cyByZXR1cm5zIGB0cnVlYC5cbiAgICAgKi9cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIGlmIChzb2NrZXRfdHlwZXNfMS5SRVNFUlZFRF9FVkVOVFMuaGFzKGV2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7U3RyaW5nKGV2KX1cIiBpcyBhIHJlc2VydmVkIGV2ZW50IG5hbWVgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gW2V2LCAuLi5hcmdzXTtcbiAgICAgICAgY29uc3QgcGFja2V0ID0ge1xuICAgICAgICAgICAgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRVZFTlQsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICB9O1xuICAgICAgICAvLyBhY2Nlc3MgbGFzdCBhcmd1bWVudCB0byBzZWUgaWYgaXQncyBhbiBBQ0sgY2FsbGJhY2tcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2RhdGEubGVuZ3RoIC0gMV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLm5zcC5faWRzKys7XG4gICAgICAgICAgICBkZWJ1ZyhcImVtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZFwiLCBpZCk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyQWNrQ2FsbGJhY2soaWQsIGRhdGEucG9wKCkpO1xuICAgICAgICAgICAgcGFja2V0LmlkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZsYWdzKTtcbiAgICAgICAgdGhpcy5mbGFncyA9IHt9O1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICh0aGlzLm5zcC5zZXJ2ZXIub3B0cy5jb25uZWN0aW9uU3RhdGVSZWNvdmVyeSkge1xuICAgICAgICAgICAgLy8gdGhpcyBlbnN1cmVzIHRoZSBwYWNrZXQgaXMgc3RvcmVkIGFuZCBjYW4gYmUgdHJhbnNtaXR0ZWQgdXBvbiByZWNvbm5lY3Rpb25cbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci5icm9hZGNhc3QocGFja2V0LCB7XG4gICAgICAgICAgICAgICAgcm9vbXM6IG5ldyBTZXQoW3RoaXMuaWRdKSxcbiAgICAgICAgICAgICAgICBleGNlcHQ6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICBmbGFncyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlPdXRnb2luZ0xpc3RlbmVycyhwYWNrZXQpO1xuICAgICAgICAgICAgdGhpcy5wYWNrZXQocGFja2V0LCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGFuZCB3YWl0cyBmb3IgYW4gYWNrbm93bGVkZ2VtZW50XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCBhc3luYyAoc29ja2V0KSA9PiB7XG4gICAgICogICAvLyB3aXRob3V0IHRpbWVvdXRcbiAgICAgKiAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc29ja2V0LmVtaXRXaXRoQWNrKFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAgICAgKlxuICAgICAqICAgLy8gd2l0aCBhIHNwZWNpZmljIHRpbWVvdXRcbiAgICAgKiAgIHRyeSB7XG4gICAgICogICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc29ja2V0LnRpbWVvdXQoMTAwMCkuZW1pdFdpdGhBY2soXCJoZWxsb1wiLCBcIndvcmxkXCIpO1xuICAgICAqICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICogICAgIC8vIHRoZSBjbGllbnQgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIGNsaWVudCBhY2tub3dsZWRnZXMgdGhlIGV2ZW50XG4gICAgICovXG4gICAgZW1pdFdpdGhBY2soZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gdGhlIHRpbWVvdXQgZmxhZyBpcyBvcHRpb25hbFxuICAgICAgICBjb25zdCB3aXRoRXJyID0gdGhpcy5mbGFncy50aW1lb3V0ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBhcmdzLnB1c2goKGFyZzEsIGFyZzIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAod2l0aEVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnMSA/IHJlamVjdChhcmcxKSA6IHJlc29sdmUoYXJnMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShhcmcxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChldiwgLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlZ2lzdGVyQWNrQ2FsbGJhY2soaWQsIGFjaykge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy5mbGFncy50aW1lb3V0O1xuICAgICAgICBpZiAodGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFja3Muc2V0KGlkLCBhY2spO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcImV2ZW50IHdpdGggYWNrIGlkICVkIGhhcyB0aW1lZCBvdXQgYWZ0ZXIgJWQgbXNcIiwgaWQsIHRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5hY2tzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBhY2suY2FsbCh0aGlzLCBuZXcgRXJyb3IoXCJvcGVyYXRpb24gaGFzIHRpbWVkIG91dFwiKSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB0aGlzLmFja3Muc2V0KGlkLCAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIGFjay5hcHBseSh0aGlzLCBbbnVsbCwgLi4uYXJnc10pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBicm9hZGNhc3RpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cyBpbiB0aGUg4oCccm9vbS0xMDHigJ0gcm9vbSwgZXhjZXB0IHRoaXMgc29ja2V0XG4gICAgICogICBzb2NrZXQudG8oXCJyb29tLTEwMVwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogICAvLyB0aGUgY29kZSBhYm92ZSBpcyBlcXVpdmFsZW50IHRvOlxuICAgICAqICAgaW8udG8oXCJyb29tLTEwMVwiKS5leGNlcHQoc29ja2V0LmlkKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogICAvLyB3aXRoIGFuIGFycmF5IG9mIHJvb21zIChhIGNsaWVudCB3aWxsIGJlIG5vdGlmaWVkIGF0IG1vc3Qgb25jZSlcbiAgICAgKiAgIHNvY2tldC50byhbXCJyb29tLTEwMVwiLCBcInJvb20tMTAyXCJdKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogICAvLyB3aXRoIG11bHRpcGxlIGNoYWluZWQgY2FsbHNcbiAgICAgKiAgIHNvY2tldC50byhcInJvb20tMTAxXCIpLnRvKFwicm9vbS0xMDJcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICB0byhyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld0Jyb2FkY2FzdE9wZXJhdG9yKCkudG8ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gYnJvYWRjYXN0aW5nLiBTaW1pbGFyIHRvIGB0bygpYCwgYnV0IG1pZ2h0IGZlZWwgY2xlYXJlciBpbiBzb21lIGNhc2VzOlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgLy8gZGlzY29ubmVjdCBhbGwgY2xpZW50cyBpbiB0aGUgXCJyb29tLTEwMVwiIHJvb20sIGV4Y2VwdCB0aGlzIHNvY2tldFxuICAgICAqICAgc29ja2V0LmluKFwicm9vbS0xMDFcIikuZGlzY29ubmVjdFNvY2tldHMoKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBpbihyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld0Jyb2FkY2FzdE9wZXJhdG9yKCkuaW4ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4Y2x1ZGVzIGEgcm9vbSB3aGVuIGJyb2FkY2FzdGluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIC8vIHRoZSBcImZvb1wiIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cywgZXhjZXB0IHRoZSBvbmVzIHRoYXQgYXJlIGluIHRoZSBcInJvb20tMTAxXCIgcm9vbVxuICAgICAqICAgLy8gYW5kIHRoaXMgc29ja2V0XG4gICAgICogICBzb2NrZXQuZXhjZXB0KFwicm9vbS0xMDFcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqICAgLy8gd2l0aCBhbiBhcnJheSBvZiByb29tc1xuICAgICAqICAgc29ja2V0LmV4Y2VwdChbXCJyb29tLTEwMVwiLCBcInJvb20tMTAyXCJdKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogICAvLyB3aXRoIG11bHRpcGxlIGNoYWluZWQgY2FsbHNcbiAgICAgKiAgIHNvY2tldC5leGNlcHQoXCJyb29tLTEwMVwiKS5leGNlcHQoXCJyb29tLTEwMlwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGV4Y2VwdChyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld0Jyb2FkY2FzdE9wZXJhdG9yKCkuZXhjZXB0KHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1pbWljcyB0aGUgV2ViU29ja2V0LnNlbmQoKSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJTb2NrZXQvc2VuZFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgc29ja2V0LnNlbmQoXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqICAgLy8gdGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICogICBzb2NrZXQuZW1pdChcIm1lc3NhZ2VcIiwgXCJoZWxsb1wiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIHNlbmQoLi4uYXJncykge1xuICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuIEFsaWFzIG9mIHtAbGluayBzZW5kfS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIHdyaXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwibWVzc2FnZVwiLCAuLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBwYWNrZXQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwYWNrZXQocGFja2V0LCBvcHRzID0ge30pIHtcbiAgICAgICAgcGFja2V0Lm5zcCA9IHRoaXMubnNwLm5hbWU7XG4gICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZSAhPT0gb3B0cy5jb21wcmVzcztcbiAgICAgICAgdGhpcy5jbGllbnQuX3BhY2tldChwYWNrZXQsIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBKb2lucyBhIHJvb20uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICAvLyBqb2luIGEgc2luZ2xlIHJvb21cbiAgICAgKiAgIHNvY2tldC5qb2luKFwicm9vbTFcIik7XG4gICAgICpcbiAgICAgKiAgIC8vIGpvaW4gbXVsdGlwbGUgcm9vbXNcbiAgICAgKiAgIHNvY2tldC5qb2luKFtcInJvb20xXCIsIFwicm9vbTJcIl0pO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHJvb21zIC0gcm9vbSBvciBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBQcm9taXNlIG9yIG5vdGhpbmcsIGRlcGVuZGluZyBvbiB0aGUgYWRhcHRlclxuICAgICAqL1xuICAgIGpvaW4ocm9vbXMpIHtcbiAgICAgICAgZGVidWcoXCJqb2luIHJvb20gJXNcIiwgcm9vbXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdGVyLmFkZEFsbCh0aGlzLmlkLCBuZXcgU2V0KEFycmF5LmlzQXJyYXkocm9vbXMpID8gcm9vbXMgOiBbcm9vbXNdKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlYXZlcyBhIHJvb20uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICAvLyBsZWF2ZSBhIHNpbmdsZSByb29tXG4gICAgICogICBzb2NrZXQubGVhdmUoXCJyb29tMVwiKTtcbiAgICAgKlxuICAgICAqICAgLy8gbGVhdmUgbXVsdGlwbGUgcm9vbXNcbiAgICAgKiAgIHNvY2tldC5sZWF2ZShcInJvb20xXCIpLmxlYXZlKFwicm9vbTJcIik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcm9vbVxuICAgICAqIEByZXR1cm4gYSBQcm9taXNlIG9yIG5vdGhpbmcsIGRlcGVuZGluZyBvbiB0aGUgYWRhcHRlclxuICAgICAqL1xuICAgIGxlYXZlKHJvb20pIHtcbiAgICAgICAgZGVidWcoXCJsZWF2ZSByb29tICVzXCIsIHJvb20pO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdGVyLmRlbCh0aGlzLmlkLCByb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGVhdmUgYWxsIHJvb21zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBsZWF2ZUFsbCgpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyLmRlbEFsbCh0aGlzLmlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJ5IGBOYW1lc3BhY2VgIHVwb24gc3VjY2Vzc2Z1bFxuICAgICAqIG1pZGRsZXdhcmUgZXhlY3V0aW9uIChpZTogYXV0aG9yaXphdGlvbikuXG4gICAgICogU29ja2V0IGlzIGFkZGVkIHRvIG5hbWVzcGFjZSBhcnJheSBiZWZvcmVcbiAgICAgKiBjYWxsIHRvIGpvaW4sIHNvIGFkYXB0ZXJzIGNhbiBhY2Nlc3MgaXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbmNvbm5lY3QoKSB7XG4gICAgICAgIGRlYnVnKFwic29ja2V0IGNvbm5lY3RlZCAtIHdyaXRpbmcgcGFja2V0XCIpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuam9pbih0aGlzLmlkKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubi5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNUIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYWNrZXQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkNPTk5FQ1QsXG4gICAgICAgICAgICAgICAgZGF0YTogeyBzaWQ6IHRoaXMuaWQsIHBpZDogdGhpcy5waWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIGVhY2ggcGFja2V0LiBDYWxsZWQgYnkgYENsaWVudGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25wYWNrZXQocGFja2V0KSB7XG4gICAgICAgIGRlYnVnKFwiZ290IHBhY2tldCAlalwiLCBwYWNrZXQpO1xuICAgICAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkVWRU5UOlxuICAgICAgICAgICAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5CSU5BUllfRVZFTlQ6XG4gICAgICAgICAgICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkFDSzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkJJTkFSWV9BQ0s6XG4gICAgICAgICAgICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5ESVNDT05ORUNUOlxuICAgICAgICAgICAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gZXZlbnQgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYWNrZXR9IHBhY2tldCAtIHBhY2tldCBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZXZlbnQocGFja2V0KSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcbiAgICAgICAgZGVidWcoXCJlbWl0dGluZyBldmVudCAlalwiLCBhcmdzKTtcbiAgICAgICAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImF0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnRcIik7XG4gICAgICAgICAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2FueUxpc3RlbmVycyAmJiB0aGlzLl9hbnlMaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaChhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCAtIHBhY2tldCBpZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWNrKGlkKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgc2VudCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgICAgICAgICBpZiAoc2VudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGRlYnVnKFwic2VuZGluZyBhY2sgJWpcIiwgYXJncyk7XG4gICAgICAgICAgICBzZWxmLnBhY2tldCh7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkFDSyxcbiAgICAgICAgICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZW50ID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gYWNrIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25hY2socGFja2V0KSB7XG4gICAgICAgIGNvbnN0IGFjayA9IHRoaXMuYWNrcy5nZXQocGFja2V0LmlkKTtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYWNrKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImNhbGxpbmcgYWNrICVzIHdpdGggJWpcIiwgcGFja2V0LmlkLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgICBhY2suYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5hY2tzLmRlbGV0ZShwYWNrZXQuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoXCJiYWQgYWNrICVzXCIsIHBhY2tldC5pZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gY2xpZW50IGRpc2Nvbm5lY3QgcGFja2V0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGRlYnVnKFwiZ290IGRpc2Nvbm5lY3QgcGFja2V0XCIpO1xuICAgICAgICB0aGlzLl9vbmNsb3NlKFwiY2xpZW50IG5hbWVzcGFjZSBkaXNjb25uZWN0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGEgY2xpZW50IGVycm9yLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25lcnJvcihlcnIpIHtcbiAgICAgICAgLy8gRklYTUUgdGhlIG1lYW5pbmcgb2YgdGhlIFwiZXJyb3JcIiBldmVudCBpcyBvdmVybG9hZGVkOlxuICAgICAgICAvLyAgLSBpdCBjYW4gYmUgc2VudCBieSB0aGUgY2xpZW50IChgc29ja2V0LmVtaXQoXCJlcnJvclwiKWApXG4gICAgICAgIC8vICAtIGl0IGNhbiBiZSBlbWl0dGVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gZW5jb3VudGVycyBhbiBlcnJvciAoYW4gaW52YWxpZCBwYWNrZXQgZm9yIGV4YW1wbGUpXG4gICAgICAgIC8vICAtIGl0IGNhbiBiZSBlbWl0dGVkIHdoZW4gYSBwYWNrZXQgaXMgcmVqZWN0ZWQgaW4gYSBtaWRkbGV3YXJlIChgc29ja2V0LnVzZSgpYClcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJlcnJvclwiLCBlcnIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBjbG9zaW5nLiBDYWxsZWQgYnkgYENsaWVudGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uXG4gICAgICogQHBhcmFtIGRlc2NyaXB0aW9uXG4gICAgICogQHRocm93IHtFcnJvcn0gb3B0aW9uYWwgZXJyb3Igb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbmNsb3NlKHJlYXNvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBkZWJ1ZyhcImNsb3Npbmcgc29ja2V0IC0gcmVhc29uICVzXCIsIHJlYXNvbik7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZGlzY29ubmVjdGluZ1wiLCByZWFzb24sIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyLl9vcHRzLmNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5ICYmXG4gICAgICAgICAgICBSRUNPVkVSQUJMRV9ESVNDT05ORUNUX1JFQVNPTlMuaGFzKHJlYXNvbikpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiBzdGF0ZSByZWNvdmVyeSBpcyBlbmFibGVkIGZvciBzaWQgJXNcIiwgdGhpcy5pZCk7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIucGVyc2lzdFNlc3Npb24oe1xuICAgICAgICAgICAgICAgIHNpZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICBwaWQ6IHRoaXMucGlkLFxuICAgICAgICAgICAgICAgIHJvb21zOiBbLi4udGhpcy5yb29tc10sXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICB0aGlzLmNsaWVudC5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRpc2Nvbm5lY3RcIiwgcmVhc29uLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIHNvY2tldCBsZWF2ZSBhbGwgdGhlIHJvb21zIGl0IHdhcyBwYXJ0IG9mIGFuZCBwcmV2ZW50cyBpdCBmcm9tIGpvaW5pbmcgYW55IG90aGVyIHJvb21cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NsZWFudXAoKSB7XG4gICAgICAgIHRoaXMubGVhdmVBbGwoKTtcbiAgICAgICAgdGhpcy5uc3AuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5qb2luID0gbm9vcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYW4gYGVycm9yYCBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXJyIC0gZXJyb3Igb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9lcnJvcihlcnIpIHtcbiAgICAgICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNUX0VSUk9SLCBkYXRhOiBlcnIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIHRoaXMgY2xpZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgLy8gZGlzY29ubmVjdCB0aGlzIHNvY2tldCAodGhlIGNvbm5lY3Rpb24gbWlnaHQgYmUga2VwdCBhbGl2ZSBmb3Igb3RoZXIgbmFtZXNwYWNlcylcbiAgICAgKiAgIHNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICpcbiAgICAgKiAgIC8vIGRpc2Nvbm5lY3QgdGhpcyBzb2NrZXQgYW5kIGNsb3NlIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25cbiAgICAgKiAgIHNvY2tldC5kaXNjb25uZWN0KHRydWUpO1xuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsb3NlIC0gaWYgYHRydWVgLCBjbG9zZXMgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoY2xvc2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChjbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQuX2Rpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFja2V0KHsgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRElTQ09OTkVDVCB9KTtcbiAgICAgICAgICAgIHRoaXMuX29uY2xvc2UoXCJzZXJ2ZXIgbmFtZXNwYWNlIGRpc2Nvbm5lY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBzb2NrZXQuY29tcHJlc3MoZmFsc2UpLmVtaXQoXCJoZWxsb1wiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29tcHJlc3MgLSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICAgICAqL1xuICAgIGNvbXByZXNzKGNvbXByZXNzKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MuY29tcHJlc3MgPSBjb21wcmVzcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IGRhdGEgbWF5IGJlIGxvc3QgaWYgdGhlIGNsaWVudCBpcyBub3QgcmVhZHkgdG9cbiAgICAgKiByZWNlaXZlIG1lc3NhZ2VzIChiZWNhdXNlIG9mIG5ldHdvcmsgc2xvd25lc3Mgb3Igb3RoZXIgaXNzdWVzLCBvciBiZWNhdXNlIHRoZXnigJlyZSBjb25uZWN0ZWQgdGhyb3VnaCBsb25nIHBvbGxpbmdcbiAgICAgKiBhbmQgaXMgaW4gdGhlIG1pZGRsZSBvZiBhIHJlcXVlc3QtcmVzcG9uc2UgY3ljbGUpLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgc29ja2V0LnZvbGF0aWxlLmVtaXQoXCJoZWxsb1wiKTsgLy8gdGhlIGNsaWVudCBtYXkgb3IgbWF5IG5vdCByZWNlaXZlIGl0XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAgICAgKi9cbiAgICBnZXQgdm9sYXRpbGUoKSB7XG4gICAgICAgIHRoaXMuZmxhZ3Mudm9sYXRpbGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSB3aWxsIG9ubHkgYmUgYnJvYWRjYXN0IHRvIGV2ZXJ5IHNvY2tldHMgYnV0IHRoZVxuICAgICAqIHNlbmRlci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIC8vIHRoZSDigJxmb2/igJ0gZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzLCBleGNlcHQgdGhpcyBzb2NrZXRcbiAgICAgKiAgIHNvY2tldC5icm9hZGNhc3QuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBnZXQgYnJvYWRjYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdCcm9hZGNhc3RPcGVyYXRvcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIHdpbGwgb25seSBiZSBicm9hZGNhc3QgdG8gdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIC8vIHRoZSDigJxmb2/igJ0gZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzIG9uIHRoaXMgbm9kZSwgZXhjZXB0IHRoaXMgc29ja2V0XG4gICAgICogICBzb2NrZXQubG9jYWwuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBnZXQgbG9jYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld0Jyb2FkY2FzdE9wZXJhdG9yKCkubG9jYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYW4gZXJyb3Igd2hlbiB0aGVcbiAgICAgKiBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCB3aXRob3V0IGFuIGFja25vd2xlZGdlbWVudCBmcm9tIHRoZSBjbGllbnQ6XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBzb2NrZXQudGltZW91dCg1MDAwKS5lbWl0KFwibXktZXZlbnRcIiwgKGVycikgPT4ge1xuICAgICAqICAgICBpZiAoZXJyKSB7XG4gICAgICogICAgICAgLy8gdGhlIGNsaWVudCBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiAgICAgfVxuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBzZWxmXG4gICAgICovXG4gICAgdGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMuZmxhZ3MudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaCBpbmNvbWluZyBldmVudCB0byBzb2NrZXQgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gZXZlbnQgLSBldmVudCB0aGF0IHdpbGwgZ2V0IGVtaXR0ZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRpc3BhdGNoKGV2ZW50KSB7XG4gICAgICAgIGRlYnVnKFwiZGlzcGF0Y2hpbmcgYW4gZXZlbnQgJWpcIiwgZXZlbnQpO1xuICAgICAgICB0aGlzLnJ1bihldmVudCwgKGVycikgPT4ge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb25lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuZW1pdFVudHlwZWQuYXBwbHkodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJpZ25vcmUgcGFja2V0IHJlY2VpdmVkIGFmdGVyIGRpc2Nvbm5lY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHNvY2tldCBtaWRkbGV3YXJlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgc29ja2V0LnVzZSgoW2V2ZW50LCAuLi5hcmdzXSwgbmV4dCkgPT4ge1xuICAgICAqICAgICBpZiAoaXNVbmF1dGhvcml6ZWQoZXZlbnQpKSB7XG4gICAgICogICAgICAgcmV0dXJuIG5leHQobmV3IEVycm9yKFwidW5hdXRob3JpemVkIGV2ZW50XCIpKTtcbiAgICAgKiAgICAgfVxuICAgICAqICAgICAvLyBkbyBub3QgZm9yZ2V0IHRvIGNhbGwgbmV4dFxuICAgICAqICAgICBuZXh0KCk7XG4gICAgICogICB9KTtcbiAgICAgKlxuICAgICAqICAgc29ja2V0Lm9uKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAqICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBcInVuYXV0aG9yaXplZCBldmVudFwiKSB7XG4gICAgICogICAgICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgKiAgICAgfVxuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIG1pZGRsZXdhcmUgZnVuY3Rpb24gKGV2ZW50LCBuZXh0KVxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICAgICAqL1xuICAgIHVzZShmbikge1xuICAgICAgICB0aGlzLmZucy5wdXNoKGZuKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBtaWRkbGV3YXJlIGZvciBhbiBpbmNvbWluZyBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGV2ZW50IC0gZXZlbnQgdGhhdCB3aWxsIGdldCBlbWl0dGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBsYXN0IGZuIGNhbGwgaW4gdGhlIG1pZGRsZXdhcmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJ1bihldmVudCwgZm4pIHtcbiAgICAgICAgaWYgKCF0aGlzLmZucy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgY29uc3QgZm5zID0gdGhpcy5mbnMuc2xpY2UoMCk7XG4gICAgICAgIGZ1bmN0aW9uIHJ1bihpKSB7XG4gICAgICAgICAgICBmbnNbaV0oZXZlbnQsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB1cG9uIGVycm9yLCBzaG9ydC1jaXJjdWl0XG4gICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGVycik7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gbWlkZGxld2FyZSBsZWZ0LCBzdW1tb24gY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBpZiAoIWZuc1tpICsgMV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICAgICAgICAgIC8vIGdvIG9uIHRvIG5leHRcbiAgICAgICAgICAgICAgICBydW4oaSArIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcnVuKDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBzb2NrZXQgaXMgY3VycmVudGx5IGRpc2Nvbm5lY3RlZFxuICAgICAqL1xuICAgIGdldCBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb25uZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSByZXF1ZXN0IHRoYXQgb3JpZ2luYXRlZCB0aGUgdW5kZXJseWluZyBFbmdpbmUuSU8gU29ja2V0LlxuICAgICAqL1xuICAgIGdldCByZXF1ZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIHVuZGVybHlpbmcgQ2xpZW50IHRyYW5zcG9ydCBjb25uZWN0aW9uIChFbmdpbmUuSU8gU29ja2V0IG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuY29ubi50cmFuc3BvcnQubmFtZSk7IC8vIHByaW50cyBcInBvbGxpbmdcIiBvciBcIndlYnNvY2tldFwiXG4gICAgICpcbiAgICAgKiAgIHNvY2tldC5jb25uLm9uY2UoXCJ1cGdyYWRlXCIsICgpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coc29ja2V0LmNvbm4udHJhbnNwb3J0Lm5hbWUpOyAvLyBwcmludHMgXCJ3ZWJzb2NrZXRcIlxuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgZ2V0IGNvbm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jb25uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByb29tcyB0aGUgc29ja2V0IGlzIGN1cnJlbnRseSBpbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5yb29tcyk7IC8vIFNldCB7IDxzb2NrZXQuaWQ+IH1cbiAgICAgKlxuICAgICAqICAgc29ja2V0LmpvaW4oXCJyb29tMVwiKTtcbiAgICAgKlxuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LnJvb21zKTsgLy8gU2V0IHsgPHNvY2tldC5pZD4sIFwicm9vbTFcIiB9XG4gICAgICogfSk7XG4gICAgICovXG4gICAgZ2V0IHJvb21zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdGVyLnNvY2tldFJvb21zKHRoaXMuaWQpIHx8IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyByZWNlaXZlZC4gVGhlIGV2ZW50IG5hbWUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0b1xuICAgICAqIHRoZSBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIHNvY2tldC5vbkFueSgoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYGdvdCBldmVudCAke2V2ZW50fWApO1xuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvbkFueShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnMgfHwgW107XG4gICAgICAgIHRoaXMuX2FueUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgcmVjZWl2ZWQuIFRoZSBldmVudCBuYW1lIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG9cbiAgICAgKiB0aGUgY2FsbGJhY2suIFRoZSBsaXN0ZW5lciBpcyBhZGRlZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBwcmVwZW5kQW55KGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FueUxpc3RlbmVycyA9IHRoaXMuX2FueUxpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5fYW55TGlzdGVuZXJzLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIHJlY2VpdmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgY29uc3QgY2F0Y2hBbGxMaXN0ZW5lciA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhgZ290IGV2ZW50ICR7ZXZlbnR9YCk7XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiAgIHNvY2tldC5vbkFueShjYXRjaEFsbExpc3RlbmVyKTtcbiAgICAgKlxuICAgICAqICAgLy8gcmVtb3ZlIGEgc3BlY2lmaWMgbGlzdGVuZXJcbiAgICAgKiAgIHNvY2tldC5vZmZBbnkoY2F0Y2hBbGxMaXN0ZW5lcik7XG4gICAgICpcbiAgICAgKiAgIC8vIG9yIHJlbW92ZSBhbGwgbGlzdGVuZXJzXG4gICAgICogICBzb2NrZXQub2ZmQW55KCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvZmZBbnkobGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hbnlMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fYW55TGlzdGVuZXJzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIgPT09IGxpc3RlbmVyc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgdGhhdCBhcmUgbGlzdGVuaW5nIGZvciBhbnkgZXZlbnQgdGhhdCBpcyBzcGVjaWZpZWQuIFRoaXMgYXJyYXkgY2FuIGJlIG1hbmlwdWxhdGVkLFxuICAgICAqIGUuZy4gdG8gcmVtb3ZlIGxpc3RlbmVycy5cbiAgICAgKi9cbiAgICBsaXN0ZW5lcnNBbnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbnlMaXN0ZW5lcnMgfHwgW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgc2VudC4gVGhlIGV2ZW50IG5hbWUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0b1xuICAgICAqIHRoZSBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIE5vdGU6IGFja25vd2xlZGdlbWVudHMgc2VudCB0byB0aGUgY2xpZW50IGFyZSBub3QgaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBzb2NrZXQub25BbnlPdXRnb2luZygoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYHNlbnQgZXZlbnQgJHtldmVudH1gKTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgb25BbnlPdXRnb2luZyhsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyA9IHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzIHx8IFtdO1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgZW1pdHRlZC4gVGhlIGV2ZW50IG5hbWUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGVcbiAgICAgKiBjYWxsYmFjay4gVGhlIGxpc3RlbmVyIGlzIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RlbmVycyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIHNvY2tldC5wcmVwZW5kQW55T3V0Z29pbmcoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGBzZW50IGV2ZW50ICR7ZXZlbnR9YCk7XG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqL1xuICAgIHByZXBlbmRBbnlPdXRnb2luZyhsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyA9IHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzIHx8IFtdO1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyBzZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgY29uc3QgY2F0Y2hBbGxMaXN0ZW5lciA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhgc2VudCBldmVudCAke2V2ZW50fWApO1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogICBzb2NrZXQub25BbnlPdXRnb2luZyhjYXRjaEFsbExpc3RlbmVyKTtcbiAgICAgKlxuICAgICAqICAgLy8gcmVtb3ZlIGEgc3BlY2lmaWMgbGlzdGVuZXJcbiAgICAgKiAgIHNvY2tldC5vZmZBbnlPdXRnb2luZyhjYXRjaEFsbExpc3RlbmVyKTtcbiAgICAgKlxuICAgICAqICAgLy8gb3IgcmVtb3ZlIGFsbCBsaXN0ZW5lcnNcbiAgICAgKiAgIHNvY2tldC5vZmZBbnlPdXRnb2luZygpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gdGhlIGNhdGNoLWFsbCBsaXN0ZW5lclxuICAgICAqL1xuICAgIG9mZkFueU91dGdvaW5nKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lciA9PT0gbGlzdGVuZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRoYXQgYXJlIGxpc3RlbmluZyBmb3IgYW55IGV2ZW50IHRoYXQgaXMgc3BlY2lmaWVkLiBUaGlzIGFycmF5IGNhbiBiZSBtYW5pcHVsYXRlZCxcbiAgICAgKiBlLmcuIHRvIHJlbW92ZSBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgbGlzdGVuZXJzQW55T3V0Z29pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyB8fCBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90aWZ5IHRoZSBsaXN0ZW5lcnMgZm9yIGVhY2ggcGFja2V0IHNlbnQgKGVtaXQgb3IgYnJvYWRjYXN0KVxuICAgICAqXG4gICAgICogQHBhcmFtIHBhY2tldFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBub3RpZnlPdXRnb2luZ0xpc3RlbmVycyhwYWNrZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzICYmIHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5ld0Jyb2FkY2FzdE9wZXJhdG9yKCkge1xuICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZmxhZ3MpO1xuICAgICAgICB0aGlzLmZsYWdzID0ge307XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyLCBuZXcgU2V0KCksIG5ldyBTZXQoW3RoaXMuaWRdKSwgZmxhZ3MpO1xuICAgIH1cbn1cbmV4cG9ydHMuU29ja2V0ID0gU29ja2V0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/socket.io/dist/socket.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/socket.io/dist/typed-events.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io/dist/typed-events.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StrictEventEmitter = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\n/**\n * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type\n * parameters for mappings of event names to event data types, and strictly\n * types method calls to the `EventEmitter` according to these event maps.\n *\n * @typeParam ListenEvents - `EventsMap` of user-defined events that can be\n * listened to with `on` or `once`\n * @typeParam EmitEvents - `EventsMap` of user-defined events that can be\n * emitted with `emit`\n * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be\n * emitted by socket.io with `emitReserved`, and can be listened to with\n * `listen`.\n */\nclass StrictEventEmitter extends events_1.EventEmitter {\n    /**\n     * Adds the `listener` function as an event listener for `ev`.\n     *\n     * @param ev Name of the event\n     * @param listener Callback function\n     */\n    on(ev, listener) {\n        return super.on(ev, listener);\n    }\n    /**\n     * Adds a one-time `listener` function as an event listener for `ev`.\n     *\n     * @param ev Name of the event\n     * @param listener Callback function\n     */\n    once(ev, listener) {\n        return super.once(ev, listener);\n    }\n    /**\n     * Emits an event.\n     *\n     * @param ev Name of the event\n     * @param args Values to send to listeners of this event\n     */\n    emit(ev, ...args) {\n        return super.emit(ev, ...args);\n    }\n    /**\n     * Emits a reserved event.\n     *\n     * This method is `protected`, so that only a class extending\n     * `StrictEventEmitter` can emit its own reserved events.\n     *\n     * @param ev Reserved event name\n     * @param args Arguments to emit along with the event\n     */\n    emitReserved(ev, ...args) {\n        return super.emit(ev, ...args);\n    }\n    /**\n     * Emits an event.\n     *\n     * This method is `protected`, so that only a class extending\n     * `StrictEventEmitter` can get around the strict typing. This is useful for\n     * calling `emit.apply`, which can be called as `emitUntyped.apply`.\n     *\n     * @param ev Event name\n     * @param args Arguments to emit along with the event\n     */\n    emitUntyped(ev, ...args) {\n        return super.emit(ev, ...args);\n    }\n    /**\n     * Returns the listeners listening to an event.\n     *\n     * @param event Event name\n     * @returns Array of listeners subscribed to `event`\n     */\n    listeners(event) {\n        return super.listeners(event);\n    }\n}\nexports.StrictEventEmitter = StrictEventEmitter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC90eXBlZC1ldmVudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yc29sZS9Eb2N1bWVudHMvR2l0SHViL21hc3NpbWluby9tYXNzaW1pbm8vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9kaXN0L3R5cGVkLWV2ZW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RyaWN0RXZlbnRFbWl0dGVyID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuLyoqXG4gKiBTdHJpY3RseSB0eXBlZCB2ZXJzaW9uIG9mIGFuIGBFdmVudEVtaXR0ZXJgLiBBIGBUeXBlZEV2ZW50RW1pdHRlcmAgdGFrZXMgdHlwZVxuICogcGFyYW1ldGVycyBmb3IgbWFwcGluZ3Mgb2YgZXZlbnQgbmFtZXMgdG8gZXZlbnQgZGF0YSB0eXBlcywgYW5kIHN0cmljdGx5XG4gKiB0eXBlcyBtZXRob2QgY2FsbHMgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGFjY29yZGluZyB0byB0aGVzZSBldmVudCBtYXBzLlxuICpcbiAqIEB0eXBlUGFyYW0gTGlzdGVuRXZlbnRzIC0gYEV2ZW50c01hcGAgb2YgdXNlci1kZWZpbmVkIGV2ZW50cyB0aGF0IGNhbiBiZVxuICogbGlzdGVuZWQgdG8gd2l0aCBgb25gIG9yIGBvbmNlYFxuICogQHR5cGVQYXJhbSBFbWl0RXZlbnRzIC0gYEV2ZW50c01hcGAgb2YgdXNlci1kZWZpbmVkIGV2ZW50cyB0aGF0IGNhbiBiZVxuICogZW1pdHRlZCB3aXRoIGBlbWl0YFxuICogQHR5cGVQYXJhbSBSZXNlcnZlZEV2ZW50cyAtIGBFdmVudHNNYXBgIG9mIHJlc2VydmVkIGV2ZW50cywgdGhhdCBjYW4gYmVcbiAqIGVtaXR0ZWQgYnkgc29ja2V0LmlvIHdpdGggYGVtaXRSZXNlcnZlZGAsIGFuZCBjYW4gYmUgbGlzdGVuZWQgdG8gd2l0aFxuICogYGxpc3RlbmAuXG4gKi9cbmNsYXNzIFN0cmljdEV2ZW50RW1pdHRlciBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgYGxpc3RlbmVyYCBmdW5jdGlvbiBhcyBhbiBldmVudCBsaXN0ZW5lciBmb3IgYGV2YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldiBOYW1lIG9mIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqL1xuICAgIG9uKGV2LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIub24oZXYsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG9uZS10aW1lIGBsaXN0ZW5lcmAgZnVuY3Rpb24gYXMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGBldmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgTmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBvbmNlKGV2LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIub25jZShldiwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldiBOYW1lIG9mIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSBhcmdzIFZhbHVlcyB0byBzZW5kIHRvIGxpc3RlbmVycyBvZiB0aGlzIGV2ZW50XG4gICAgICovXG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldiwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGEgcmVzZXJ2ZWQgZXZlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBgcHJvdGVjdGVkYCwgc28gdGhhdCBvbmx5IGEgY2xhc3MgZXh0ZW5kaW5nXG4gICAgICogYFN0cmljdEV2ZW50RW1pdHRlcmAgY2FuIGVtaXQgaXRzIG93biByZXNlcnZlZCBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgUmVzZXJ2ZWQgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIEFyZ3VtZW50cyB0byBlbWl0IGFsb25nIHdpdGggdGhlIGV2ZW50XG4gICAgICovXG4gICAgZW1pdFJlc2VydmVkKGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBgcHJvdGVjdGVkYCwgc28gdGhhdCBvbmx5IGEgY2xhc3MgZXh0ZW5kaW5nXG4gICAgICogYFN0cmljdEV2ZW50RW1pdHRlcmAgY2FuIGdldCBhcm91bmQgdGhlIHN0cmljdCB0eXBpbmcuIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgICAqIGNhbGxpbmcgYGVtaXQuYXBwbHlgLCB3aGljaCBjYW4gYmUgY2FsbGVkIGFzIGBlbWl0VW50eXBlZC5hcHBseWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgRXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIEFyZ3VtZW50cyB0byBlbWl0IGFsb25nIHdpdGggdGhlIGV2ZW50XG4gICAgICovXG4gICAgZW1pdFVudHlwZWQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IEV2ZW50IG5hbWVcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBsaXN0ZW5lcnMgc3Vic2NyaWJlZCB0byBgZXZlbnRgXG4gICAgICovXG4gICAgbGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBzdXBlci5saXN0ZW5lcnMoZXZlbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyaWN0RXZlbnRFbWl0dGVyID0gU3RyaWN0RXZlbnRFbWl0dGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/socket.io/dist/typed-events.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/socket.io/dist/uws.js":
/*!********************************************!*\
  !*** ./node_modules/socket.io/dist/uws.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.patchAdapter = patchAdapter;\nexports.restoreAdapter = restoreAdapter;\nexports.serveFile = serveFile;\nconst socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ \"(action-browser)/./node_modules/socket.io-adapter/dist/index.js\");\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(action-browser)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst debug = (0, debug_1.default)(\"socket.io:adapter-uws\");\nconst SEPARATOR = \"\\x1f\"; // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nconst { addAll, del, broadcast } = socket_io_adapter_1.Adapter.prototype;\nfunction patchAdapter(app /* : TemplatedApp */) {\n    socket_io_adapter_1.Adapter.prototype.addAll = function (id, rooms) {\n        const isNew = !this.sids.has(id);\n        addAll.call(this, id, rooms);\n        const socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);\n        if (!socket) {\n            return;\n        }\n        if (socket.conn.transport.name === \"websocket\") {\n            subscribe(this.nsp.name, socket, isNew, rooms);\n            return;\n        }\n        if (isNew) {\n            socket.conn.on(\"upgrade\", () => {\n                const rooms = this.sids.get(id);\n                if (rooms) {\n                    subscribe(this.nsp.name, socket, isNew, rooms);\n                }\n            });\n        }\n    };\n    socket_io_adapter_1.Adapter.prototype.del = function (id, room) {\n        del.call(this, id, room);\n        const socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);\n        if (socket && socket.conn.transport.name === \"websocket\") {\n            // @ts-ignore\n            const sessionId = socket.conn.id;\n            // @ts-ignore\n            const websocket = socket.conn.transport.socket;\n            const topic = `${this.nsp.name}${SEPARATOR}${room}`;\n            debug(\"unsubscribe connection %s from topic %s\", sessionId, topic);\n            websocket.unsubscribe(topic);\n        }\n    };\n    socket_io_adapter_1.Adapter.prototype.broadcast = function (packet, opts) {\n        const useFastPublish = opts.rooms.size <= 1 && opts.except.size === 0;\n        if (!useFastPublish) {\n            broadcast.call(this, packet, opts);\n            return;\n        }\n        const flags = opts.flags || {};\n        const basePacketOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress,\n        };\n        packet.nsp = this.nsp.name;\n        const encodedPackets = this.encoder.encode(packet);\n        const topic = opts.rooms.size === 0\n            ? this.nsp.name\n            : `${this.nsp.name}${SEPARATOR}${opts.rooms.keys().next().value}`;\n        debug(\"fast publish to %s\", topic);\n        // fast publish for clients connected with WebSocket\n        encodedPackets.forEach((encodedPacket) => {\n            const isBinary = typeof encodedPacket !== \"string\";\n            // \"4\" being the message type in the Engine.IO protocol, see https://github.com/socketio/engine.io-protocol\n            app.publish(topic, isBinary ? encodedPacket : \"4\" + encodedPacket, isBinary);\n        });\n        this.apply(opts, (socket) => {\n            if (socket.conn.transport.name !== \"websocket\") {\n                // classic publish for clients connected with HTTP long-polling\n                socket.client.writeToEngine(encodedPackets, basePacketOpts);\n            }\n        });\n    };\n}\nfunction subscribe(namespaceName, socket, isNew, rooms) {\n    // @ts-ignore\n    const sessionId = socket.conn.id;\n    // @ts-ignore\n    const websocket = socket.conn.transport.socket;\n    if (isNew) {\n        debug(\"subscribe connection %s to topic %s\", sessionId, namespaceName);\n        websocket.subscribe(namespaceName);\n    }\n    rooms.forEach((room) => {\n        const topic = `${namespaceName}${SEPARATOR}${room}`; // '#' can be used as wildcard\n        debug(\"subscribe connection %s to topic %s\", sessionId, topic);\n        websocket.subscribe(topic);\n    });\n}\nfunction restoreAdapter() {\n    socket_io_adapter_1.Adapter.prototype.addAll = addAll;\n    socket_io_adapter_1.Adapter.prototype.del = del;\n    socket_io_adapter_1.Adapter.prototype.broadcast = broadcast;\n}\nconst toArrayBuffer = (buffer) => {\n    const { buffer: arrayBuffer, byteOffset, byteLength } = buffer;\n    return arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n};\n// imported from https://github.com/kolodziejczak-sz/uwebsocket-serve\nfunction serveFile(res /* : HttpResponse */, filepath) {\n    const { size } = (0, fs_1.statSync)(filepath);\n    const readStream = (0, fs_1.createReadStream)(filepath);\n    const destroyReadStream = () => !readStream.destroyed && readStream.destroy();\n    const onError = (error) => {\n        destroyReadStream();\n        throw error;\n    };\n    const onDataChunk = (chunk) => {\n        const arrayBufferChunk = toArrayBuffer(chunk);\n        res.cork(() => {\n            const lastOffset = res.getWriteOffset();\n            const [ok, done] = res.tryEnd(arrayBufferChunk, size);\n            if (!done && !ok) {\n                readStream.pause();\n                res.onWritable((offset) => {\n                    const [ok, done] = res.tryEnd(arrayBufferChunk.slice(offset - lastOffset), size);\n                    if (!done && ok) {\n                        readStream.resume();\n                    }\n                    return ok;\n                });\n            }\n        });\n    };\n    res.onAborted(destroyReadStream);\n    readStream\n        .on(\"data\", onDataChunk)\n        .on(\"error\", onError)\n        .on(\"end\", destroyReadStream);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC91d3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLGlCQUFpQjtBQUNqQiw0QkFBNEIsbUJBQU8sQ0FBQywwRkFBbUI7QUFDdkQsYUFBYSxtQkFBTyxDQUFDLGNBQUk7QUFDekIsZ0NBQWdDLG1CQUFPLENBQUMsd0ZBQU87QUFDL0M7QUFDQSwwQkFBMEI7QUFDMUIsUUFBUSx5QkFBeUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWMsRUFBRSxVQUFVLEVBQUUsS0FBSztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWMsRUFBRSxVQUFVLEVBQUUsK0JBQStCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixjQUFjLEVBQUUsVUFBVSxFQUFFLEtBQUssR0FBRztBQUM3RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4Q0FBOEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3Jzb2xlL0RvY3VtZW50cy9HaXRIdWIvbWFzc2ltaW5vL21hc3NpbWluby9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvdXdzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXRjaEFkYXB0ZXIgPSBwYXRjaEFkYXB0ZXI7XG5leHBvcnRzLnJlc3RvcmVBZGFwdGVyID0gcmVzdG9yZUFkYXB0ZXI7XG5leHBvcnRzLnNlcnZlRmlsZSA9IHNlcnZlRmlsZTtcbmNvbnN0IHNvY2tldF9pb19hZGFwdGVyXzEgPSByZXF1aXJlKFwic29ja2V0LmlvLWFkYXB0ZXJcIik7XG5jb25zdCBmc18xID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcInNvY2tldC5pbzphZGFwdGVyLXV3c1wiKTtcbmNvbnN0IFNFUEFSQVRPUiA9IFwiXFx4MWZcIjsgLy8gc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RlbGltaXRlciNBU0NJSV9kZWxpbWl0ZWRfdGV4dFxuY29uc3QgeyBhZGRBbGwsIGRlbCwgYnJvYWRjYXN0IH0gPSBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIucHJvdG90eXBlO1xuZnVuY3Rpb24gcGF0Y2hBZGFwdGVyKGFwcCAvKiA6IFRlbXBsYXRlZEFwcCAqLykge1xuICAgIHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlci5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24gKGlkLCByb29tcykge1xuICAgICAgICBjb25zdCBpc05ldyA9ICF0aGlzLnNpZHMuaGFzKGlkKTtcbiAgICAgICAgYWRkQWxsLmNhbGwodGhpcywgaWQsIHJvb21zKTtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5uc3Auc29ja2V0cy5nZXQoaWQpIHx8IHRoaXMubnNwLl9wcmVDb25uZWN0U29ja2V0cy5nZXQoaWQpO1xuICAgICAgICBpZiAoIXNvY2tldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb2NrZXQuY29ubi50cmFuc3BvcnQubmFtZSA9PT0gXCJ3ZWJzb2NrZXRcIikge1xuICAgICAgICAgICAgc3Vic2NyaWJlKHRoaXMubnNwLm5hbWUsIHNvY2tldCwgaXNOZXcsIHJvb21zKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICAgIHNvY2tldC5jb25uLm9uKFwidXBncmFkZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vbXMgPSB0aGlzLnNpZHMuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICBpZiAocm9vbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKHRoaXMubnNwLm5hbWUsIHNvY2tldCwgaXNOZXcsIHJvb21zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc29ja2V0X2lvX2FkYXB0ZXJfMS5BZGFwdGVyLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAoaWQsIHJvb20pIHtcbiAgICAgICAgZGVsLmNhbGwodGhpcywgaWQsIHJvb20pO1xuICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLm5zcC5zb2NrZXRzLmdldChpZCkgfHwgdGhpcy5uc3AuX3ByZUNvbm5lY3RTb2NrZXRzLmdldChpZCk7XG4gICAgICAgIGlmIChzb2NrZXQgJiYgc29ja2V0LmNvbm4udHJhbnNwb3J0Lm5hbWUgPT09IFwid2Vic29ja2V0XCIpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9IHNvY2tldC5jb25uLmlkO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3Qgd2Vic29ja2V0ID0gc29ja2V0LmNvbm4udHJhbnNwb3J0LnNvY2tldDtcbiAgICAgICAgICAgIGNvbnN0IHRvcGljID0gYCR7dGhpcy5uc3AubmFtZX0ke1NFUEFSQVRPUn0ke3Jvb219YDtcbiAgICAgICAgICAgIGRlYnVnKFwidW5zdWJzY3JpYmUgY29ubmVjdGlvbiAlcyBmcm9tIHRvcGljICVzXCIsIHNlc3Npb25JZCwgdG9waWMpO1xuICAgICAgICAgICAgd2Vic29ja2V0LnVuc3Vic2NyaWJlKHRvcGljKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc29ja2V0X2lvX2FkYXB0ZXJfMS5BZGFwdGVyLnByb3RvdHlwZS5icm9hZGNhc3QgPSBmdW5jdGlvbiAocGFja2V0LCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IHVzZUZhc3RQdWJsaXNoID0gb3B0cy5yb29tcy5zaXplIDw9IDEgJiYgb3B0cy5leGNlcHQuc2l6ZSA9PT0gMDtcbiAgICAgICAgaWYgKCF1c2VGYXN0UHVibGlzaCkge1xuICAgICAgICAgICAgYnJvYWRjYXN0LmNhbGwodGhpcywgcGFja2V0LCBvcHRzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmbGFncyA9IG9wdHMuZmxhZ3MgfHwge307XG4gICAgICAgIGNvbnN0IGJhc2VQYWNrZXRPcHRzID0ge1xuICAgICAgICAgICAgcHJlRW5jb2RlZDogdHJ1ZSxcbiAgICAgICAgICAgIHZvbGF0aWxlOiBmbGFncy52b2xhdGlsZSxcbiAgICAgICAgICAgIGNvbXByZXNzOiBmbGFncy5jb21wcmVzcyxcbiAgICAgICAgfTtcbiAgICAgICAgcGFja2V0Lm5zcCA9IHRoaXMubnNwLm5hbWU7XG4gICAgICAgIGNvbnN0IGVuY29kZWRQYWNrZXRzID0gdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQpO1xuICAgICAgICBjb25zdCB0b3BpYyA9IG9wdHMucm9vbXMuc2l6ZSA9PT0gMFxuICAgICAgICAgICAgPyB0aGlzLm5zcC5uYW1lXG4gICAgICAgICAgICA6IGAke3RoaXMubnNwLm5hbWV9JHtTRVBBUkFUT1J9JHtvcHRzLnJvb21zLmtleXMoKS5uZXh0KCkudmFsdWV9YDtcbiAgICAgICAgZGVidWcoXCJmYXN0IHB1Ymxpc2ggdG8gJXNcIiwgdG9waWMpO1xuICAgICAgICAvLyBmYXN0IHB1Ymxpc2ggZm9yIGNsaWVudHMgY29ubmVjdGVkIHdpdGggV2ViU29ja2V0XG4gICAgICAgIGVuY29kZWRQYWNrZXRzLmZvckVhY2goKGVuY29kZWRQYWNrZXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzQmluYXJ5ID0gdHlwZW9mIGVuY29kZWRQYWNrZXQgIT09IFwic3RyaW5nXCI7XG4gICAgICAgICAgICAvLyBcIjRcIiBiZWluZyB0aGUgbWVzc2FnZSB0eXBlIGluIHRoZSBFbmdpbmUuSU8gcHJvdG9jb2wsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vc29ja2V0aW8vZW5naW5lLmlvLXByb3RvY29sXG4gICAgICAgICAgICBhcHAucHVibGlzaCh0b3BpYywgaXNCaW5hcnkgPyBlbmNvZGVkUGFja2V0IDogXCI0XCIgKyBlbmNvZGVkUGFja2V0LCBpc0JpbmFyeSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFwcGx5KG9wdHMsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIGlmIChzb2NrZXQuY29ubi50cmFuc3BvcnQubmFtZSAhPT0gXCJ3ZWJzb2NrZXRcIikge1xuICAgICAgICAgICAgICAgIC8vIGNsYXNzaWMgcHVibGlzaCBmb3IgY2xpZW50cyBjb25uZWN0ZWQgd2l0aCBIVFRQIGxvbmctcG9sbGluZ1xuICAgICAgICAgICAgICAgIHNvY2tldC5jbGllbnQud3JpdGVUb0VuZ2luZShlbmNvZGVkUGFja2V0cywgYmFzZVBhY2tldE9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc3Vic2NyaWJlKG5hbWVzcGFjZU5hbWUsIHNvY2tldCwgaXNOZXcsIHJvb21zKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHNlc3Npb25JZCA9IHNvY2tldC5jb25uLmlkO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCB3ZWJzb2NrZXQgPSBzb2NrZXQuY29ubi50cmFuc3BvcnQuc29ja2V0O1xuICAgIGlmIChpc05ldykge1xuICAgICAgICBkZWJ1ZyhcInN1YnNjcmliZSBjb25uZWN0aW9uICVzIHRvIHRvcGljICVzXCIsIHNlc3Npb25JZCwgbmFtZXNwYWNlTmFtZSk7XG4gICAgICAgIHdlYnNvY2tldC5zdWJzY3JpYmUobmFtZXNwYWNlTmFtZSk7XG4gICAgfVxuICAgIHJvb21zLmZvckVhY2goKHJvb20pID0+IHtcbiAgICAgICAgY29uc3QgdG9waWMgPSBgJHtuYW1lc3BhY2VOYW1lfSR7U0VQQVJBVE9SfSR7cm9vbX1gOyAvLyAnIycgY2FuIGJlIHVzZWQgYXMgd2lsZGNhcmRcbiAgICAgICAgZGVidWcoXCJzdWJzY3JpYmUgY29ubmVjdGlvbiAlcyB0byB0b3BpYyAlc1wiLCBzZXNzaW9uSWQsIHRvcGljKTtcbiAgICAgICAgd2Vic29ja2V0LnN1YnNjcmliZSh0b3BpYyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZXN0b3JlQWRhcHRlcigpIHtcbiAgICBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIucHJvdG90eXBlLmFkZEFsbCA9IGFkZEFsbDtcbiAgICBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIucHJvdG90eXBlLmRlbCA9IGRlbDtcbiAgICBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIucHJvdG90eXBlLmJyb2FkY2FzdCA9IGJyb2FkY2FzdDtcbn1cbmNvbnN0IHRvQXJyYXlCdWZmZXIgPSAoYnVmZmVyKSA9PiB7XG4gICAgY29uc3QgeyBidWZmZXI6IGFycmF5QnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoIH0gPSBidWZmZXI7XG4gICAgcmV0dXJuIGFycmF5QnVmZmVyLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoKTtcbn07XG4vLyBpbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rb2xvZHppZWpjemFrLXN6L3V3ZWJzb2NrZXQtc2VydmVcbmZ1bmN0aW9uIHNlcnZlRmlsZShyZXMgLyogOiBIdHRwUmVzcG9uc2UgKi8sIGZpbGVwYXRoKSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSAoMCwgZnNfMS5zdGF0U3luYykoZmlsZXBhdGgpO1xuICAgIGNvbnN0IHJlYWRTdHJlYW0gPSAoMCwgZnNfMS5jcmVhdGVSZWFkU3RyZWFtKShmaWxlcGF0aCk7XG4gICAgY29uc3QgZGVzdHJveVJlYWRTdHJlYW0gPSAoKSA9PiAhcmVhZFN0cmVhbS5kZXN0cm95ZWQgJiYgcmVhZFN0cmVhbS5kZXN0cm95KCk7XG4gICAgY29uc3Qgb25FcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICBkZXN0cm95UmVhZFN0cmVhbSgpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9O1xuICAgIGNvbnN0IG9uRGF0YUNodW5rID0gKGNodW5rKSA9PiB7XG4gICAgICAgIGNvbnN0IGFycmF5QnVmZmVyQ2h1bmsgPSB0b0FycmF5QnVmZmVyKGNodW5rKTtcbiAgICAgICAgcmVzLmNvcmsoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGFzdE9mZnNldCA9IHJlcy5nZXRXcml0ZU9mZnNldCgpO1xuICAgICAgICAgICAgY29uc3QgW29rLCBkb25lXSA9IHJlcy50cnlFbmQoYXJyYXlCdWZmZXJDaHVuaywgc2l6ZSk7XG4gICAgICAgICAgICBpZiAoIWRvbmUgJiYgIW9rKSB7XG4gICAgICAgICAgICAgICAgcmVhZFN0cmVhbS5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIHJlcy5vbldyaXRhYmxlKChvZmZzZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW29rLCBkb25lXSA9IHJlcy50cnlFbmQoYXJyYXlCdWZmZXJDaHVuay5zbGljZShvZmZzZXQgLSBsYXN0T2Zmc2V0KSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9uZSAmJiBvaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZFN0cmVhbS5yZXN1bWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2s7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmVzLm9uQWJvcnRlZChkZXN0cm95UmVhZFN0cmVhbSk7XG4gICAgcmVhZFN0cmVhbVxuICAgICAgICAub24oXCJkYXRhXCIsIG9uRGF0YUNodW5rKVxuICAgICAgICAub24oXCJlcnJvclwiLCBvbkVycm9yKVxuICAgICAgICAub24oXCJlbmRcIiwgZGVzdHJveVJlYWRTdHJlYW0pO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/socket.io/dist/uws.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/socket.io/node_modules/debug/src/browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/browser.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"(action-browser)/./node_modules/socket.io/node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLFlBQVk7QUFDWixpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNENBQTRDOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsNEZBQVU7O0FBRW5DLE9BQU8sWUFBWTs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3Jzb2xlL0RvY3VtZW50cy9HaXRIdWIvbWFzc2ltaW5vL21hc3NpbWluby9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbmV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG5cdGxldCB3YXJuZWQgPSBmYWxzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0bGV0IG07XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgKG0gPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSkgJiYgcGFyc2VJbnQobVsxXSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/socket.io/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/socket.io/node_modules/debug/src/common.js":
/*!*****************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/common.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"(action-browser)/./node_modules/ms/index.js\");\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsdURBQUk7QUFDcEM7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3Jzb2xlL0RvY3VtZW50cy9HaXRIdWIvbWFzc2ltaW5vL21hc3NpbWluby9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXHRcdGxldCBuYW1lc3BhY2VzQ2FjaGU7XG5cdFx0bGV0IGVuYWJsZWRDYWNoZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdGlmIChlbmFibGVPdmVycmlkZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBlbmFibGVPdmVycmlkZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmFtZXNwYWNlc0NhY2hlICE9PSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcblx0XHRcdFx0XHRlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZW5hYmxlZENhY2hlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogdiA9PiB7XG5cdFx0XHRcdGVuYWJsZU92ZXJyaWRlID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblx0XHRjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnNsaWNlKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/socket.io/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/socket.io/node_modules/debug/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || false === true || process.__nwjs) {\n\tmodule.exports = __webpack_require__(/*! ./browser.js */ \"(action-browser)/./node_modules/socket.io/node_modules/debug/src/browser.js\");\n} else {\n\tmodule.exports = __webpack_require__(/*! ./node.js */ \"(action-browser)/./node_modules/socket.io/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxRUFBcUUsS0FBZTtBQUNwRixDQUFDLHVJQUF3QztBQUN6QyxFQUFFO0FBQ0YsQ0FBQyxpSUFBcUM7QUFDdEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3Jzb2xlL0RvY3VtZW50cy9HaXRIdWIvbWFzc2ltaW5vL21hc3NpbWluby9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEZXRlY3QgRWxlY3Ryb24gcmVuZGVyZXIgLyBud2pzIHByb2Nlc3MsIHdoaWNoIGlzIG5vZGUsIGJ1dCB3ZSBzaG91bGRcbiAqIHRyZWF0IGFzIGEgYnJvd3Nlci5cbiAqL1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8IHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCBwcm9jZXNzLmJyb3dzZXIgPT09IHRydWUgfHwgcHJvY2Vzcy5fX253anMpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jyb3dzZXIuanMnKTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9ub2RlLmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/socket.io/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/socket.io/node_modules/debug/src/node.js":
/*!***************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/node.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */\n\nconst tty = __webpack_require__(/*! tty */ \"tty\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(\n\t() => {},\n\t'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'\n);\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = __webpack_require__(/*! supports-color */ \"(action-browser)/./node_modules/supports-color/index.js\");\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"(action-browser)/./node_modules/socket.io/node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.split('\\n')\n\t\t.map(str => str.trim())\n\t\t.join(' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaLFdBQVc7QUFDWCxrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLFlBQVk7QUFDWixpQkFBaUI7QUFDakIsZUFBZTtBQUNmLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLCtFQUFnQjs7QUFFL0M7QUFDQSxFQUFFLGNBQWM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLDZEQUE2RDtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMsSUFBSTs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSw0QkFBNEI7O0FBRXBDO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRCxzQkFBc0IsV0FBVyxJQUFJLE1BQU07O0FBRTNDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsNEZBQVU7O0FBRW5DLE9BQU8sWUFBWTs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcnNvbGUvRG9jdW1lbnRzL0dpdEh1Yi9tYXNzaW1pbm8vbWFzc2ltaW5vL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCB0dHkgPSByZXF1aXJlKCd0dHknKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgTm9kZS5qcyBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5pbml0ID0gaW5pdDtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLmRlc3Ryb3kgPSB1dGlsLmRlcHJlY2F0ZShcblx0KCkgPT4ge30sXG5cdCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJ1xuKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbNiwgMiwgMywgNCwgNSwgMV07XG5cbnRyeSB7XG5cdC8vIE9wdGlvbmFsIGRlcGVuZGVuY3kgKGFzIGluLCBkb2Vzbid0IG5lZWQgdG8gYmUgaW5zdGFsbGVkLCBOT1QgbGlrZSBvcHRpb25hbERlcGVuZGVuY2llcyBpbiBwYWNrYWdlLmpzb24pXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcblx0Y29uc3Qgc3VwcG9ydHNDb2xvciA9IHJlcXVpcmUoJ3N1cHBvcnRzLWNvbG9yJyk7XG5cblx0aWYgKHN1cHBvcnRzQ29sb3IgJiYgKHN1cHBvcnRzQ29sb3Iuc3RkZXJyIHx8IHN1cHBvcnRzQ29sb3IpLmxldmVsID49IDIpIHtcblx0XHRleHBvcnRzLmNvbG9ycyA9IFtcblx0XHRcdDIwLFxuXHRcdFx0MjEsXG5cdFx0XHQyNixcblx0XHRcdDI3LFxuXHRcdFx0MzIsXG5cdFx0XHQzMyxcblx0XHRcdDM4LFxuXHRcdFx0MzksXG5cdFx0XHQ0MCxcblx0XHRcdDQxLFxuXHRcdFx0NDIsXG5cdFx0XHQ0Myxcblx0XHRcdDQ0LFxuXHRcdFx0NDUsXG5cdFx0XHQ1Nixcblx0XHRcdDU3LFxuXHRcdFx0NjIsXG5cdFx0XHQ2Myxcblx0XHRcdDY4LFxuXHRcdFx0NjksXG5cdFx0XHQ3NCxcblx0XHRcdDc1LFxuXHRcdFx0NzYsXG5cdFx0XHQ3Nyxcblx0XHRcdDc4LFxuXHRcdFx0NzksXG5cdFx0XHQ4MCxcblx0XHRcdDgxLFxuXHRcdFx0OTIsXG5cdFx0XHQ5Myxcblx0XHRcdDk4LFxuXHRcdFx0OTksXG5cdFx0XHQxMTIsXG5cdFx0XHQxMTMsXG5cdFx0XHQxMjgsXG5cdFx0XHQxMjksXG5cdFx0XHQxMzQsXG5cdFx0XHQxMzUsXG5cdFx0XHQxNDgsXG5cdFx0XHQxNDksXG5cdFx0XHQxNjAsXG5cdFx0XHQxNjEsXG5cdFx0XHQxNjIsXG5cdFx0XHQxNjMsXG5cdFx0XHQxNjQsXG5cdFx0XHQxNjUsXG5cdFx0XHQxNjYsXG5cdFx0XHQxNjcsXG5cdFx0XHQxNjgsXG5cdFx0XHQxNjksXG5cdFx0XHQxNzAsXG5cdFx0XHQxNzEsXG5cdFx0XHQxNzIsXG5cdFx0XHQxNzMsXG5cdFx0XHQxNzgsXG5cdFx0XHQxNzksXG5cdFx0XHQxODQsXG5cdFx0XHQxODUsXG5cdFx0XHQxOTYsXG5cdFx0XHQxOTcsXG5cdFx0XHQxOTgsXG5cdFx0XHQxOTksXG5cdFx0XHQyMDAsXG5cdFx0XHQyMDEsXG5cdFx0XHQyMDIsXG5cdFx0XHQyMDMsXG5cdFx0XHQyMDQsXG5cdFx0XHQyMDUsXG5cdFx0XHQyMDYsXG5cdFx0XHQyMDcsXG5cdFx0XHQyMDgsXG5cdFx0XHQyMDksXG5cdFx0XHQyMTQsXG5cdFx0XHQyMTUsXG5cdFx0XHQyMjAsXG5cdFx0XHQyMjFcblx0XHRdO1xuXHR9XG59IGNhdGNoIChlcnJvcikge1xuXHQvLyBTd2FsbG93IC0gd2Ugb25seSBjYXJlIGlmIGBzdXBwb3J0cy1jb2xvcmAgaXMgYXZhaWxhYmxlOyBpdCBkb2Vzbid0IGhhdmUgdG8gYmUuXG59XG5cbi8qKlxuICogQnVpbGQgdXAgdGhlIGRlZmF1bHQgYGluc3BlY3RPcHRzYCBvYmplY3QgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICpcbiAqICAgJCBERUJVR19DT0xPUlM9bm8gREVCVUdfREVQVEg9MTAgREVCVUdfU0hPV19ISURERU49ZW5hYmxlZCBub2RlIHNjcmlwdC5qc1xuICovXG5cbmV4cG9ydHMuaW5zcGVjdE9wdHMgPSBPYmplY3Qua2V5cyhwcm9jZXNzLmVudikuZmlsdGVyKGtleSA9PiB7XG5cdHJldHVybiAvXmRlYnVnXy9pLnRlc3Qoa2V5KTtcbn0pLnJlZHVjZSgob2JqLCBrZXkpID0+IHtcblx0Ly8gQ2FtZWwtY2FzZVxuXHRjb25zdCBwcm9wID0ga2V5XG5cdFx0LnN1YnN0cmluZyg2KVxuXHRcdC50b0xvd2VyQ2FzZSgpXG5cdFx0LnJlcGxhY2UoL18oW2Etel0pL2csIChfLCBrKSA9PiB7XG5cdFx0XHRyZXR1cm4gay50b1VwcGVyQ2FzZSgpO1xuXHRcdH0pO1xuXG5cdC8vIENvZXJjZSBzdHJpbmcgdmFsdWUgaW50byBKUyB2YWx1ZVxuXHRsZXQgdmFsID0gcHJvY2Vzcy5lbnZba2V5XTtcblx0aWYgKC9eKHllc3xvbnx0cnVlfGVuYWJsZWQpJC9pLnRlc3QodmFsKSkge1xuXHRcdHZhbCA9IHRydWU7XG5cdH0gZWxzZSBpZiAoL14obm98b2ZmfGZhbHNlfGRpc2FibGVkKSQvaS50ZXN0KHZhbCkpIHtcblx0XHR2YWwgPSBmYWxzZTtcblx0fSBlbHNlIGlmICh2YWwgPT09ICdudWxsJykge1xuXHRcdHZhbCA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0dmFsID0gTnVtYmVyKHZhbCk7XG5cdH1cblxuXHRvYmpbcHJvcF0gPSB2YWw7XG5cdHJldHVybiBvYmo7XG59LCB7fSk7XG5cbi8qKlxuICogSXMgc3Rkb3V0IGEgVFRZPyBDb2xvcmVkIG91dHB1dCBpcyBlbmFibGVkIHdoZW4gYHRydWVgLlxuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0cmV0dXJuICdjb2xvcnMnIGluIGV4cG9ydHMuaW5zcGVjdE9wdHMgP1xuXHRcdEJvb2xlYW4oZXhwb3J0cy5pbnNwZWN0T3B0cy5jb2xvcnMpIDpcblx0XHR0dHkuaXNhdHR5KHByb2Nlc3Muc3RkZXJyLmZkKTtcbn1cblxuLyoqXG4gKiBBZGRzIEFOU0kgY29sb3IgZXNjYXBlIGNvZGVzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0Y29uc3Qge25hbWVzcGFjZTogbmFtZSwgdXNlQ29sb3JzfSA9IHRoaXM7XG5cblx0aWYgKHVzZUNvbG9ycykge1xuXHRcdGNvbnN0IGMgPSB0aGlzLmNvbG9yO1xuXHRcdGNvbnN0IGNvbG9yQ29kZSA9ICdcXHUwMDFCWzMnICsgKGMgPCA4ID8gYyA6ICc4OzU7JyArIGMpO1xuXHRcdGNvbnN0IHByZWZpeCA9IGAgICR7Y29sb3JDb2RlfTsxbSR7bmFtZX0gXFx1MDAxQlswbWA7XG5cblx0XHRhcmdzWzBdID0gcHJlZml4ICsgYXJnc1swXS5zcGxpdCgnXFxuJykuam9pbignXFxuJyArIHByZWZpeCk7XG5cdFx0YXJncy5wdXNoKGNvbG9yQ29kZSArICdtKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpICsgJ1xcdTAwMUJbMG0nKTtcblx0fSBlbHNlIHtcblx0XHRhcmdzWzBdID0gZ2V0RGF0ZSgpICsgbmFtZSArICcgJyArIGFyZ3NbMF07XG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZSgpIHtcblx0aWYgKGV4cG9ydHMuaW5zcGVjdE9wdHMuaGlkZURhdGUpIHtcblx0XHRyZXR1cm4gJyc7XG5cdH1cblx0cmV0dXJuIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSArICcgJztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGB1dGlsLmZvcm1hdFdpdGhPcHRpb25zKClgIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMgYW5kIHdyaXRlcyB0byBzdGRlcnIuXG4gKi9cblxuZnVuY3Rpb24gbG9nKC4uLmFyZ3MpIHtcblx0cmV0dXJuIHByb2Nlc3Muc3RkZXJyLndyaXRlKHV0aWwuZm9ybWF0V2l0aE9wdGlvbnMoZXhwb3J0cy5pbnNwZWN0T3B0cywgLi4uYXJncykgKyAnXFxuJyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRwcm9jZXNzLmVudi5ERUJVRyA9IG5hbWVzcGFjZXM7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgeW91IHNldCBhIHByb2Nlc3MuZW52IGZpZWxkIHRvIG51bGwgb3IgdW5kZWZpbmVkLCBpdCBnZXRzIGNhc3QgdG8gdGhlXG5cdFx0Ly8gc3RyaW5nICdudWxsJyBvciAndW5kZWZpbmVkJy4gSnVzdCBkZWxldGUgaW5zdGVhZC5cblx0XHRkZWxldGUgcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRyZXR1cm4gcHJvY2Vzcy5lbnYuREVCVUc7XG59XG5cbi8qKlxuICogSW5pdCBsb2dpYyBmb3IgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKlxuICogQ3JlYXRlIGEgbmV3IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGluIGNhc2UgYHVzZUNvbG9yc2AgaXMgc2V0XG4gKiBkaWZmZXJlbnRseSBmb3IgYSBwYXJ0aWN1bGFyIGBkZWJ1Z2AgaW5zdGFuY2UuXG4gKi9cblxuZnVuY3Rpb24gaW5pdChkZWJ1Zykge1xuXHRkZWJ1Zy5pbnNwZWN0T3B0cyA9IHt9O1xuXG5cdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhleHBvcnRzLmluc3BlY3RPcHRzKTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0ZGVidWcuaW5zcGVjdE9wdHNba2V5c1tpXV0gPSBleHBvcnRzLmluc3BlY3RPcHRzW2tleXNbaV1dO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbCBvbiBhIHNpbmdsZSBsaW5lLlxuICovXG5cbmZvcm1hdHRlcnMubyA9IGZ1bmN0aW9uICh2KSB7XG5cdHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cdHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cylcblx0XHQuc3BsaXQoJ1xcbicpXG5cdFx0Lm1hcChzdHIgPT4gc3RyLnRyaW0oKSlcblx0XHQuam9pbignICcpO1xufTtcblxuLyoqXG4gKiBNYXAgJU8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsb3dpbmcgbXVsdGlwbGUgbGluZXMgaWYgbmVlZGVkLlxuICovXG5cbmZvcm1hdHRlcnMuTyA9IGZ1bmN0aW9uICh2KSB7XG5cdHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cdHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cyk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/socket.io/node_modules/debug/src/node.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/socket.io/package.json":
/*!*********************************************!*\
  !*** ./node_modules/socket.io/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"socket.io","version":"4.8.1","description":"node.js realtime framework server","keywords":["realtime","framework","websocket","tcp","events","socket","io"],"files":["dist/","client-dist/","wrapper.mjs","!**/*.tsbuildinfo"],"directories":{"doc":"docs/","example":"example/","lib":"lib/","test":"test/"},"type":"commonjs","main":"./dist/index.js","exports":{"types":"./dist/index.d.ts","import":"./wrapper.mjs","require":"./dist/index.js"},"types":"./dist/index.d.ts","license":"MIT","homepage":"https://github.com/socketio/socket.io/tree/main/packages/socket.io#readme","repository":{"type":"git","url":"git+https://github.com/socketio/socket.io.git"},"bugs":{"url":"https://github.com/socketio/socket.io/issues"},"scripts":{"compile":"rimraf ./dist && tsc","test":"npm run format:check && npm run compile && npm run test:types && npm run test:unit","test:types":"tsd","test:unit":"nyc mocha --require ts-node/register --reporter spec --slow 200 --bail --timeout 10000 test/index.ts","format:check":"prettier --check \\"lib/**/*.ts\\" \\"test/**/*.ts\\"","format:fix":"prettier --write \\"lib/**/*.ts\\" \\"test/**/*.ts\\"","prepack":"npm run compile"},"dependencies":{"accepts":"~1.3.4","base64id":"~2.0.0","cors":"~2.8.5","debug":"~4.3.2","engine.io":"~6.6.0","socket.io-adapter":"~2.5.2","socket.io-parser":"~4.2.4"},"contributors":[{"name":"Guillermo Rauch","email":"rauchg@gmail.com"},{"name":"Arnout Kazemier","email":"info@3rd-eden.com"},{"name":"Vladimir Dronnikov","email":"dronnikov@gmail.com"},{"name":"Einar Otto Stangvik","email":"einaros@gmail.com"}],"engines":{"node":">=10.2.0"},"tsd":{"directory":"test"}}');

/***/ }),

/***/ "(action-browser)/./node_modules/socket.io/wrapper.mjs":
/*!********************************************!*\
  !*** ./node_modules/socket.io/wrapper.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Namespace: () => (/* binding */ Namespace),\n/* harmony export */   Server: () => (/* binding */ Server),\n/* harmony export */   Socket: () => (/* binding */ Socket)\n/* harmony export */ });\n/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ \"(action-browser)/./node_modules/socket.io/dist/index.js\");\n\n\nconst {Server, Namespace, Socket} = _dist_index_js__WEBPACK_IMPORTED_MODULE_0__;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vd3JhcHBlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQzs7QUFFMUIsT0FBTywyQkFBMkIsRUFBRSwyQ0FBRSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcnNvbGUvRG9jdW1lbnRzL0dpdEh1Yi9tYXNzaW1pbm8vbWFzc2ltaW5vL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vd3JhcHBlci5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGlvIGZyb20gXCIuL2Rpc3QvaW5kZXguanNcIjtcblxuZXhwb3J0IGNvbnN0IHtTZXJ2ZXIsIE5hbWVzcGFjZSwgU29ja2V0fSA9IGlvO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/socket.io/wrapper.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/broadcast-operator.js":
/*!***********************************************************!*\
  !*** ./node_modules/socket.io/dist/broadcast-operator.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RemoteSocket = exports.BroadcastOperator = void 0;\nconst socket_types_1 = __webpack_require__(/*! ./socket-types */ \"(rsc)/./node_modules/socket.io/dist/socket-types.js\");\nconst socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ \"(rsc)/./node_modules/socket.io-parser/build/cjs/index.js\");\nclass BroadcastOperator {\n    constructor(adapter, rooms = new Set(), exceptRooms = new Set(), flags = {}) {\n        this.adapter = adapter;\n        this.rooms = rooms;\n        this.exceptRooms = exceptRooms;\n        this.flags = flags;\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @example\n     * // the “foo” event will be broadcast to all connected clients in the “room-101” room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms (a client will be notified at most once)\n     * io.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    to(room) {\n        const rooms = new Set(this.rooms);\n        if (Array.isArray(room)) {\n            room.forEach((r) => rooms.add(r));\n        }\n        else {\n            rooms.add(room);\n        }\n        return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);\n    }\n    /**\n     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * // disconnect all clients in the \"room-101\" room\n     * io.in(\"room-101\").disconnectSockets();\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    in(room) {\n        return this.to(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @example\n     * // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     * io.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms\n     * io.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    except(room) {\n        const exceptRooms = new Set(this.exceptRooms);\n        if (Array.isArray(room)) {\n            room.forEach((r) => exceptRooms.add(r));\n        }\n        else {\n            exceptRooms.add(room);\n        }\n        return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return a new BroadcastOperator instance\n     */\n    compress(compress) {\n        const flags = Object.assign({}, this.flags, { compress });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.volatile.emit(\"hello\"); // the clients may or may not receive it\n     *\n     * @return a new BroadcastOperator instance\n     */\n    get volatile() {\n        const flags = Object.assign({}, this.flags, { volatile: true });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * // the “foo” event will be broadcast to all connected clients on this node\n     * io.local.emit(\"foo\", \"bar\");\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    get local() {\n        const flags = Object.assign({}, this.flags, { local: true });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation\n     *\n     * @example\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @param timeout\n     */\n    timeout(timeout) {\n        const flags = Object.assign({}, this.flags, { timeout });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Emits to all clients.\n     *\n     * @example\n     * // the “foo” event will be broadcast to all connected clients\n     * io.emit(\"foo\", \"bar\");\n     *\n     * // the “foo” event will be broadcast to all connected clients in the “room-101” room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an acknowledgement expected from all connected clients\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @return Always true\n     */\n    emit(ev, ...args) {\n        if (socket_types_1.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${String(ev)}\" is a reserved event name`);\n        }\n        // set up packet object\n        const data = [ev, ...args];\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: data,\n        };\n        const withAck = typeof data[data.length - 1] === \"function\";\n        if (!withAck) {\n            this.adapter.broadcast(packet, {\n                rooms: this.rooms,\n                except: this.exceptRooms,\n                flags: this.flags,\n            });\n            return true;\n        }\n        const ack = data.pop();\n        let timedOut = false;\n        let responses = [];\n        const timer = setTimeout(() => {\n            timedOut = true;\n            ack.apply(this, [\n                new Error(\"operation has timed out\"),\n                this.flags.expectSingleResponse ? null : responses,\n            ]);\n        }, this.flags.timeout);\n        let expectedServerCount = -1;\n        let actualServerCount = 0;\n        let expectedClientCount = 0;\n        const checkCompleteness = () => {\n            if (!timedOut &&\n                expectedServerCount === actualServerCount &&\n                responses.length === expectedClientCount) {\n                clearTimeout(timer);\n                ack.apply(this, [\n                    null,\n                    this.flags.expectSingleResponse ? responses[0] : responses,\n                ]);\n            }\n        };\n        this.adapter.broadcastWithAck(packet, {\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        }, (clientCount) => {\n            // each Socket.IO server in the cluster sends the number of clients that were notified\n            expectedClientCount += clientCount;\n            actualServerCount++;\n            checkCompleteness();\n        }, (clientResponse) => {\n            // each client sends an acknowledgement\n            responses.push(clientResponse);\n            checkCompleteness();\n        });\n        this.adapter.serverCount().then((serverCount) => {\n            expectedServerCount = serverCount;\n            checkCompleteness();\n        });\n        return true;\n    }\n    /**\n     * Emits an event and waits for an acknowledgement from all clients.\n     *\n     * @example\n     * try {\n     *   const responses = await io.timeout(1000).emitWithAck(\"some-event\");\n     *   console.log(responses); // one response per client\n     * } catch (e) {\n     *   // some clients did not acknowledge the event in the given delay\n     * }\n     *\n     * @return a Promise that will be fulfilled when all clients have acknowledged the event\n     */\n    emitWithAck(ev, ...args) {\n        return new Promise((resolve, reject) => {\n            args.push((err, responses) => {\n                if (err) {\n                    err.responses = responses;\n                    return reject(err);\n                }\n                else {\n                    return resolve(responses);\n                }\n            });\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or\n     * {@link fetchSockets} instead.\n     */\n    allSockets() {\n        if (!this.adapter) {\n            throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n        }\n        return this.adapter.sockets(this.rooms);\n    }\n    /**\n     * Returns the matching socket instances. This method works across a cluster of several Socket.IO servers.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // return all Socket instances\n     * const sockets = await io.fetchSockets();\n     *\n     * // return all Socket instances in the \"room1\" room\n     * const sockets = await io.in(\"room1\").fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   console.log(socket.id);\n     *   console.log(socket.handshake);\n     *   console.log(socket.rooms);\n     *   console.log(socket.data);\n     *\n     *   socket.emit(\"hello\");\n     *   socket.join(\"room1\");\n     *   socket.leave(\"room2\");\n     *   socket.disconnect();\n     * }\n     */\n    fetchSockets() {\n        return this.adapter\n            .fetchSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        })\n            .then((sockets) => {\n            return sockets.map((socket) => {\n                if (socket.server) {\n                    return socket; // local instance\n                }\n                else {\n                    return new RemoteSocket(this.adapter, socket);\n                }\n            });\n        });\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     *\n     * // make all socket instances join the \"room1\" room\n     * io.socketsJoin(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room join the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsJoin([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */\n    socketsJoin(room) {\n        this.adapter.addSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        }, Array.isArray(room) ? room : [room]);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances leave the \"room1\" room\n     * io.socketsLeave(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room leave the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsLeave([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */\n    socketsLeave(room) {\n        this.adapter.delSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        }, Array.isArray(room) ? room : [room]);\n    }\n    /**\n     * Makes the matching socket instances disconnect.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)\n     * io.disconnectSockets();\n     *\n     * // make all socket instances in the \"room1\" room disconnect and close the underlying connections\n     * io.in(\"room1\").disconnectSockets(true);\n     *\n     * @param close - whether to close the underlying connection\n     */\n    disconnectSockets(close = false) {\n        this.adapter.disconnectSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        }, close);\n    }\n}\nexports.BroadcastOperator = BroadcastOperator;\n/**\n * Expose of subset of the attributes and methods of the Socket class\n */\nclass RemoteSocket {\n    constructor(adapter, details) {\n        this.id = details.id;\n        this.handshake = details.handshake;\n        this.rooms = new Set(details.rooms);\n        this.data = details.data;\n        this.operator = new BroadcastOperator(adapter, new Set([this.id]), new Set(), {\n            expectSingleResponse: true, // so that remoteSocket.emit() with acknowledgement behaves like socket.emit()\n        });\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation.\n     *\n     * @example\n     * const sockets = await io.fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   if (someCondition) {\n     *     socket.timeout(1000).emit(\"some-event\", (err) => {\n     *       if (err) {\n     *         // the client did not acknowledge the event in the given delay\n     *       }\n     *     });\n     *   }\n     * }\n     *\n     * // note: if possible, using a room instead of looping over all sockets is preferable\n     * io.timeout(1000).to(someConditionRoom).emit(\"some-event\", (err, responses) => {\n     *   // ...\n     * });\n     *\n     * @param timeout\n     */\n    timeout(timeout) {\n        return this.operator.timeout(timeout);\n    }\n    emit(ev, ...args) {\n        return this.operator.emit(ev, ...args);\n    }\n    /**\n     * Joins a room.\n     *\n     * @param {String|Array} room - room or array of rooms\n     */\n    join(room) {\n        return this.operator.socketsJoin(room);\n    }\n    /**\n     * Leaves a room.\n     *\n     * @param {String} room\n     */\n    leave(room) {\n        return this.operator.socketsLeave(room);\n    }\n    /**\n     * Disconnects this client.\n     *\n     * @param {Boolean} close - if `true`, closes the underlying connection\n     * @return {Socket} self\n     */\n    disconnect(close = false) {\n        this.operator.disconnectSockets(close);\n        return this;\n    }\n}\nexports.RemoteSocket = RemoteSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvYnJvYWRjYXN0LW9wZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLHlCQUF5QjtBQUNoRCx1QkFBdUIsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDL0MsMkJBQTJCLG1CQUFPLENBQUMsa0ZBQWtCO0FBQ3JEO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCLFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0IsZ0JBQWdCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0IsYUFBYTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsbUNBQW1DO0FBQ25DO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQixTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLG1DQUFtQztBQUNuQztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsNkJBQTZCO0FBQ25ILFFBQVEsb0JBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHLGNBQWM7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHLGNBQWM7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsY0FBYztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsY0FBYztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yc29sZS9Eb2N1bWVudHMvR2l0SHViL21hc3NpbWluby9tYXNzaW1pbm8vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9kaXN0L2Jyb2FkY2FzdC1vcGVyYXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVtb3RlU29ja2V0ID0gZXhwb3J0cy5Ccm9hZGNhc3RPcGVyYXRvciA9IHZvaWQgMDtcbmNvbnN0IHNvY2tldF90eXBlc18xID0gcmVxdWlyZShcIi4vc29ja2V0LXR5cGVzXCIpO1xuY29uc3Qgc29ja2V0X2lvX3BhcnNlcl8xID0gcmVxdWlyZShcInNvY2tldC5pby1wYXJzZXJcIik7XG5jbGFzcyBCcm9hZGNhc3RPcGVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoYWRhcHRlciwgcm9vbXMgPSBuZXcgU2V0KCksIGV4Y2VwdFJvb21zID0gbmV3IFNldCgpLCBmbGFncyA9IHt9KSB7XG4gICAgICAgIHRoaXMuYWRhcHRlciA9IGFkYXB0ZXI7XG4gICAgICAgIHRoaXMucm9vbXMgPSByb29tcztcbiAgICAgICAgdGhpcy5leGNlcHRSb29tcyA9IGV4Y2VwdFJvb21zO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gZW1pdHRpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHRoZSDigJxmb2/igJ0gZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzIGluIHRoZSDigJxyb29tLTEwMeKAnSByb29tXG4gICAgICogaW8udG8oXCJyb29tLTEwMVwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBhbiBhcnJheSBvZiByb29tcyAoYSBjbGllbnQgd2lsbCBiZSBub3RpZmllZCBhdCBtb3N0IG9uY2UpXG4gICAgICogaW8udG8oW1wicm9vbS0xMDFcIiwgXCJyb29tLTEwMlwiXSkuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggbXVsdGlwbGUgY2hhaW5lZCBjYWxsc1xuICAgICAqIGlvLnRvKFwicm9vbS0xMDFcIikudG8oXCJyb29tLTEwMlwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIHRvKHJvb20pIHtcbiAgICAgICAgY29uc3Qgcm9vbXMgPSBuZXcgU2V0KHRoaXMucm9vbXMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyb29tKSkge1xuICAgICAgICAgICAgcm9vbS5mb3JFYWNoKChyKSA9PiByb29tcy5hZGQocikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcm9vbXMuYWRkKHJvb20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyLCByb29tcywgdGhpcy5leGNlcHRSb29tcywgdGhpcy5mbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gZW1pdHRpbmcuIFNpbWlsYXIgdG8gYHRvKClgLCBidXQgbWlnaHQgZmVlbCBjbGVhcmVyIGluIHNvbWUgY2FzZXM6XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGRpc2Nvbm5lY3QgYWxsIGNsaWVudHMgaW4gdGhlIFwicm9vbS0xMDFcIiByb29tXG4gICAgICogaW8uaW4oXCJyb29tLTEwMVwiKS5kaXNjb25uZWN0U29ja2V0cygpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGluKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4Y2x1ZGVzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB0aGUgXCJmb29cIiBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMsIGV4Y2VwdCB0aGUgb25lcyB0aGF0IGFyZSBpbiB0aGUgXCJyb29tLTEwMVwiIHJvb21cbiAgICAgKiBpby5leGNlcHQoXCJyb29tLTEwMVwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIGlvLmV4Y2VwdChbXCJyb29tLTEwMVwiLCBcInJvb20tMTAyXCJdKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBtdWx0aXBsZSBjaGFpbmVkIGNhbGxzXG4gICAgICogaW8uZXhjZXB0KFwicm9vbS0xMDFcIikuZXhjZXB0KFwicm9vbS0xMDJcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBleGNlcHQocm9vbSkge1xuICAgICAgICBjb25zdCBleGNlcHRSb29tcyA9IG5ldyBTZXQodGhpcy5leGNlcHRSb29tcyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJvb20pKSB7XG4gICAgICAgICAgICByb29tLmZvckVhY2goKHIpID0+IGV4Y2VwdFJvb21zLmFkZChyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleGNlcHRSb29tcy5hZGQocm9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCcm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIsIHRoaXMucm9vbXMsIGV4Y2VwdFJvb21zLCB0aGlzLmZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29tcHJlc3MgZmxhZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8uY29tcHJlc3MoZmFsc2UpLmVtaXQoXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21wcmVzcyAtIGlmIGB0cnVlYCwgY29tcHJlc3NlcyB0aGUgc2VuZGluZyBkYXRhXG4gICAgICogQHJldHVybiBhIG5ldyBCcm9hZGNhc3RPcGVyYXRvciBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbXByZXNzKGNvbXByZXNzKSB7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5mbGFncywgeyBjb21wcmVzcyB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCcm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIsIHRoaXMucm9vbXMsIHRoaXMuZXhjZXB0Um9vbXMsIGZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSBtYXkgYmUgbG9zdCBpZiB0aGUgY2xpZW50IGlzIG5vdCByZWFkeSB0b1xuICAgICAqIHJlY2VpdmUgbWVzc2FnZXMgKGJlY2F1c2Ugb2YgbmV0d29yayBzbG93bmVzcyBvciBvdGhlciBpc3N1ZXMsIG9yIGJlY2F1c2UgdGhleeKAmXJlIGNvbm5lY3RlZCB0aHJvdWdoIGxvbmcgcG9sbGluZ1xuICAgICAqIGFuZCBpcyBpbiB0aGUgbWlkZGxlIG9mIGEgcmVxdWVzdC1yZXNwb25zZSBjeWNsZSkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLnZvbGF0aWxlLmVtaXQoXCJoZWxsb1wiKTsgLy8gdGhlIGNsaWVudHMgbWF5IG9yIG1heSBub3QgcmVjZWl2ZSBpdFxuICAgICAqXG4gICAgICogQHJldHVybiBhIG5ldyBCcm9hZGNhc3RPcGVyYXRvciBpbnN0YW5jZVxuICAgICAqL1xuICAgIGdldCB2b2xhdGlsZSgpIHtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZsYWdzLCB7IHZvbGF0aWxlOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlciwgdGhpcy5yb29tcywgdGhpcy5leGNlcHRSb29tcywgZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIHdpbGwgb25seSBiZSBicm9hZGNhc3QgdG8gdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gdGhlIOKAnGZvb+KAnSBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMgb24gdGhpcyBub2RlXG4gICAgICogaW8ubG9jYWwuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBnZXQgbG9jYWwoKSB7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5mbGFncywgeyBsb2NhbDogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCcm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIsIHRoaXMucm9vbXMsIHRoaXMuZXhjZXB0Um9vbXMsIGZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgbmV4dCBvcGVyYXRpb25cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8udGltZW91dCgxMDAwKS5lbWl0KFwic29tZS1ldmVudFwiLCAoZXJyLCByZXNwb25zZXMpID0+IHtcbiAgICAgKiAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgLy8gc29tZSBjbGllbnRzIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgfSBlbHNlIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzcG9uc2VzKTsgLy8gb25lIHJlc3BvbnNlIHBlciBjbGllbnRcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lb3V0XG4gICAgICovXG4gICAgdGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5mbGFncywgeyB0aW1lb3V0IH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlciwgdGhpcy5yb29tcywgdGhpcy5leGNlcHRSb29tcywgZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyB0byBhbGwgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gdGhlIOKAnGZvb+KAnSBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHNcbiAgICAgKiBpby5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gdGhlIOKAnGZvb+KAnSBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMgaW4gdGhlIOKAnHJvb20tMTAx4oCdIHJvb21cbiAgICAgKiBpby50byhcInJvb20tMTAxXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGFuIGFja25vd2xlZGdlbWVudCBleHBlY3RlZCBmcm9tIGFsbCBjb25uZWN0ZWQgY2xpZW50c1xuICAgICAqIGlvLnRpbWVvdXQoMTAwMCkuZW1pdChcInNvbWUtZXZlbnRcIiwgKGVyciwgcmVzcG9uc2VzKSA9PiB7XG4gICAgICogICBpZiAoZXJyKSB7XG4gICAgICogICAgIC8vIHNvbWUgY2xpZW50cyBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiAgIH0gZWxzZSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlcyk7IC8vIG9uZSByZXNwb25zZSBwZXIgY2xpZW50XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEFsd2F5cyB0cnVlXG4gICAgICovXG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICBpZiAoc29ja2V0X3R5cGVzXzEuUkVTRVJWRURfRVZFTlRTLmhhcyhldikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke1N0cmluZyhldil9XCIgaXMgYSByZXNlcnZlZCBldmVudCBuYW1lYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHVwIHBhY2tldCBvYmplY3RcbiAgICAgICAgY29uc3QgZGF0YSA9IFtldiwgLi4uYXJnc107XG4gICAgICAgIGNvbnN0IHBhY2tldCA9IHtcbiAgICAgICAgICAgIHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkVWRU5ULFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgd2l0aEFjayA9IHR5cGVvZiBkYXRhW2RhdGEubGVuZ3RoIC0gMV0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgaWYgKCF3aXRoQWNrKSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIuYnJvYWRjYXN0KHBhY2tldCwge1xuICAgICAgICAgICAgICAgIHJvb21zOiB0aGlzLnJvb21zLFxuICAgICAgICAgICAgICAgIGV4Y2VwdDogdGhpcy5leGNlcHRSb29tcyxcbiAgICAgICAgICAgICAgICBmbGFnczogdGhpcy5mbGFncyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWNrID0gZGF0YS5wb3AoKTtcbiAgICAgICAgbGV0IHRpbWVkT3V0ID0gZmFsc2U7XG4gICAgICAgIGxldCByZXNwb25zZXMgPSBbXTtcbiAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGFjay5hcHBseSh0aGlzLCBbXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKFwib3BlcmF0aW9uIGhhcyB0aW1lZCBvdXRcIiksXG4gICAgICAgICAgICAgICAgdGhpcy5mbGFncy5leHBlY3RTaW5nbGVSZXNwb25zZSA/IG51bGwgOiByZXNwb25zZXMsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSwgdGhpcy5mbGFncy50aW1lb3V0KTtcbiAgICAgICAgbGV0IGV4cGVjdGVkU2VydmVyQ291bnQgPSAtMTtcbiAgICAgICAgbGV0IGFjdHVhbFNlcnZlckNvdW50ID0gMDtcbiAgICAgICAgbGV0IGV4cGVjdGVkQ2xpZW50Q291bnQgPSAwO1xuICAgICAgICBjb25zdCBjaGVja0NvbXBsZXRlbmVzcyA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGltZWRPdXQgJiZcbiAgICAgICAgICAgICAgICBleHBlY3RlZFNlcnZlckNvdW50ID09PSBhY3R1YWxTZXJ2ZXJDb3VudCAmJlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlcy5sZW5ndGggPT09IGV4cGVjdGVkQ2xpZW50Q291bnQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIGFjay5hcHBseSh0aGlzLCBbXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmxhZ3MuZXhwZWN0U2luZ2xlUmVzcG9uc2UgPyByZXNwb25zZXNbMF0gOiByZXNwb25zZXMsXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRhcHRlci5icm9hZGNhc3RXaXRoQWNrKHBhY2tldCwge1xuICAgICAgICAgICAgcm9vbXM6IHRoaXMucm9vbXMsXG4gICAgICAgICAgICBleGNlcHQ6IHRoaXMuZXhjZXB0Um9vbXMsXG4gICAgICAgICAgICBmbGFnczogdGhpcy5mbGFncyxcbiAgICAgICAgfSwgKGNsaWVudENvdW50KSA9PiB7XG4gICAgICAgICAgICAvLyBlYWNoIFNvY2tldC5JTyBzZXJ2ZXIgaW4gdGhlIGNsdXN0ZXIgc2VuZHMgdGhlIG51bWJlciBvZiBjbGllbnRzIHRoYXQgd2VyZSBub3RpZmllZFxuICAgICAgICAgICAgZXhwZWN0ZWRDbGllbnRDb3VudCArPSBjbGllbnRDb3VudDtcbiAgICAgICAgICAgIGFjdHVhbFNlcnZlckNvdW50Kys7XG4gICAgICAgICAgICBjaGVja0NvbXBsZXRlbmVzcygpO1xuICAgICAgICB9LCAoY2xpZW50UmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIC8vIGVhY2ggY2xpZW50IHNlbmRzIGFuIGFja25vd2xlZGdlbWVudFxuICAgICAgICAgICAgcmVzcG9uc2VzLnB1c2goY2xpZW50UmVzcG9uc2UpO1xuICAgICAgICAgICAgY2hlY2tDb21wbGV0ZW5lc3MoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRhcHRlci5zZXJ2ZXJDb3VudCgpLnRoZW4oKHNlcnZlckNvdW50KSA9PiB7XG4gICAgICAgICAgICBleHBlY3RlZFNlcnZlckNvdW50ID0gc2VydmVyQ291bnQ7XG4gICAgICAgICAgICBjaGVja0NvbXBsZXRlbmVzcygpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGFuZCB3YWl0cyBmb3IgYW4gYWNrbm93bGVkZ2VtZW50IGZyb20gYWxsIGNsaWVudHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHRyeSB7XG4gICAgICogICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBpby50aW1lb3V0KDEwMDApLmVtaXRXaXRoQWNrKFwic29tZS1ldmVudFwiKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHJlc3BvbnNlcyk7IC8vIG9uZSByZXNwb25zZSBwZXIgY2xpZW50XG4gICAgICogfSBjYXRjaCAoZSkge1xuICAgICAqICAgLy8gc29tZSBjbGllbnRzIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiBhbGwgY2xpZW50cyBoYXZlIGFja25vd2xlZGdlZCB0aGUgZXZlbnRcbiAgICAgKi9cbiAgICBlbWl0V2l0aEFjayhldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgYXJncy5wdXNoKChlcnIsIHJlc3BvbnNlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyLnJlc3BvbnNlcyA9IHJlc3BvbnNlcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChldiwgLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBjbGllbnRzLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgdGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UsIHBsZWFzZSB1c2Uge0BsaW5rIFNlcnZlciNzZXJ2ZXJTaWRlRW1pdH0gb3JcbiAgICAgKiB7QGxpbmsgZmV0Y2hTb2NrZXRzfSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFsbFNvY2tldHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5hZGFwdGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhZGFwdGVyIGZvciB0aGlzIG5hbWVzcGFjZSwgYXJlIHlvdSB0cnlpbmcgdG8gZ2V0IHRoZSBsaXN0IG9mIGNsaWVudHMgb2YgYSBkeW5hbWljIG5hbWVzcGFjZT9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlci5zb2NrZXRzKHRoaXMucm9vbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzLiBUaGlzIG1ldGhvZCB3b3JrcyBhY3Jvc3MgYSBjbHVzdGVyIG9mIHNldmVyYWwgU29ja2V0LklPIHNlcnZlcnMuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIHdpdGhpbiBhIGNsdXN0ZXIgb2YgbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBBZGFwdGVyfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gcmV0dXJuIGFsbCBTb2NrZXQgaW5zdGFuY2VzXG4gICAgICogY29uc3Qgc29ja2V0cyA9IGF3YWl0IGlvLmZldGNoU29ja2V0cygpO1xuICAgICAqXG4gICAgICogLy8gcmV0dXJuIGFsbCBTb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbVxuICAgICAqIGNvbnN0IHNvY2tldHMgPSBhd2FpdCBpby5pbihcInJvb20xXCIpLmZldGNoU29ja2V0cygpO1xuICAgICAqXG4gICAgICogZm9yIChjb25zdCBzb2NrZXQgb2Ygc29ja2V0cykge1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmlkKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5oYW5kc2hha2UpO1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LnJvb21zKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5kYXRhKTtcbiAgICAgKlxuICAgICAqICAgc29ja2V0LmVtaXQoXCJoZWxsb1wiKTtcbiAgICAgKiAgIHNvY2tldC5qb2luKFwicm9vbTFcIik7XG4gICAgICogICBzb2NrZXQubGVhdmUoXCJyb29tMlwiKTtcbiAgICAgKiAgIHNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICogfVxuICAgICAqL1xuICAgIGZldGNoU29ja2V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlclxuICAgICAgICAgICAgLmZldGNoU29ja2V0cyh7XG4gICAgICAgICAgICByb29tczogdGhpcy5yb29tcyxcbiAgICAgICAgICAgIGV4Y2VwdDogdGhpcy5leGNlcHRSb29tcyxcbiAgICAgICAgICAgIGZsYWdzOiB0aGlzLmZsYWdzLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHNvY2tldHMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzb2NrZXRzLm1hcCgoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNvY2tldC5zZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldDsgLy8gbG9jYWwgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVtb3RlU29ja2V0KHRoaXMuYWRhcHRlciwgc29ja2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGpvaW4gdGhlIHNwZWNpZmllZCByb29tcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgam9pbiB0aGUgXCJyb29tMVwiIHJvb21cbiAgICAgKiBpby5zb2NrZXRzSm9pbihcInJvb20xXCIpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBpbiB0aGUgXCJyb29tMVwiIHJvb20gam9pbiB0aGUgXCJyb29tMlwiIGFuZCBcInJvb20zXCIgcm9vbXNcbiAgICAgKiBpby5pbihcInJvb20xXCIpLnNvY2tldHNKb2luKFtcInJvb20yXCIsIFwicm9vbTNcIl0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICovXG4gICAgc29ja2V0c0pvaW4ocm9vbSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXIuYWRkU29ja2V0cyh7XG4gICAgICAgICAgICByb29tczogdGhpcy5yb29tcyxcbiAgICAgICAgICAgIGV4Y2VwdDogdGhpcy5leGNlcHRSb29tcyxcbiAgICAgICAgICAgIGZsYWdzOiB0aGlzLmZsYWdzLFxuICAgICAgICB9LCBBcnJheS5pc0FycmF5KHJvb20pID8gcm9vbSA6IFtyb29tXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGxlYXZlIHRoZSBzcGVjaWZpZWQgcm9vbXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIHdpdGhpbiBhIGNsdXN0ZXIgb2YgbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBBZGFwdGVyfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBsZWF2ZSB0aGUgXCJyb29tMVwiIHJvb21cbiAgICAgKiBpby5zb2NrZXRzTGVhdmUoXCJyb29tMVwiKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tIGxlYXZlIHRoZSBcInJvb20yXCIgYW5kIFwicm9vbTNcIiByb29tc1xuICAgICAqIGlvLmluKFwicm9vbTFcIikuc29ja2V0c0xlYXZlKFtcInJvb20yXCIsIFwicm9vbTNcIl0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICovXG4gICAgc29ja2V0c0xlYXZlKHJvb20pIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyLmRlbFNvY2tldHMoe1xuICAgICAgICAgICAgcm9vbXM6IHRoaXMucm9vbXMsXG4gICAgICAgICAgICBleGNlcHQ6IHRoaXMuZXhjZXB0Um9vbXMsXG4gICAgICAgICAgICBmbGFnczogdGhpcy5mbGFncyxcbiAgICAgICAgfSwgQXJyYXkuaXNBcnJheShyb29tKSA/IHJvb20gOiBbcm9vbV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBkaXNjb25uZWN0LlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgZGlzY29ubmVjdCAodGhlIGNvbm5lY3Rpb25zIG1pZ2h0IGJlIGtlcHQgYWxpdmUgZm9yIG90aGVyIG5hbWVzcGFjZXMpXG4gICAgICogaW8uZGlzY29ubmVjdFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tIGRpc2Nvbm5lY3QgYW5kIGNsb3NlIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25zXG4gICAgICogaW8uaW4oXCJyb29tMVwiKS5kaXNjb25uZWN0U29ja2V0cyh0cnVlKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbG9zZSAtIHdoZXRoZXIgdG8gY2xvc2UgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RTb2NrZXRzKGNsb3NlID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyLmRpc2Nvbm5lY3RTb2NrZXRzKHtcbiAgICAgICAgICAgIHJvb21zOiB0aGlzLnJvb21zLFxuICAgICAgICAgICAgZXhjZXB0OiB0aGlzLmV4Y2VwdFJvb21zLFxuICAgICAgICAgICAgZmxhZ3M6IHRoaXMuZmxhZ3MsXG4gICAgICAgIH0sIGNsb3NlKTtcbiAgICB9XG59XG5leHBvcnRzLkJyb2FkY2FzdE9wZXJhdG9yID0gQnJvYWRjYXN0T3BlcmF0b3I7XG4vKipcbiAqIEV4cG9zZSBvZiBzdWJzZXQgb2YgdGhlIGF0dHJpYnV0ZXMgYW5kIG1ldGhvZHMgb2YgdGhlIFNvY2tldCBjbGFzc1xuICovXG5jbGFzcyBSZW1vdGVTb2NrZXQge1xuICAgIGNvbnN0cnVjdG9yKGFkYXB0ZXIsIGRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5pZCA9IGRldGFpbHMuaWQ7XG4gICAgICAgIHRoaXMuaGFuZHNoYWtlID0gZGV0YWlscy5oYW5kc2hha2U7XG4gICAgICAgIHRoaXMucm9vbXMgPSBuZXcgU2V0KGRldGFpbHMucm9vbXMpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkZXRhaWxzLmRhdGE7XG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBuZXcgQnJvYWRjYXN0T3BlcmF0b3IoYWRhcHRlciwgbmV3IFNldChbdGhpcy5pZF0pLCBuZXcgU2V0KCksIHtcbiAgICAgICAgICAgIGV4cGVjdFNpbmdsZVJlc3BvbnNlOiB0cnVlLCAvLyBzbyB0aGF0IHJlbW90ZVNvY2tldC5lbWl0KCkgd2l0aCBhY2tub3dsZWRnZW1lbnQgYmVoYXZlcyBsaWtlIHNvY2tldC5lbWl0KClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIG5leHQgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBzb2NrZXRzID0gYXdhaXQgaW8uZmV0Y2hTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiBmb3IgKGNvbnN0IHNvY2tldCBvZiBzb2NrZXRzKSB7XG4gICAgICogICBpZiAoc29tZUNvbmRpdGlvbikge1xuICAgICAqICAgICBzb2NrZXQudGltZW91dCgxMDAwKS5lbWl0KFwic29tZS1ldmVudFwiLCAoZXJyKSA9PiB7XG4gICAgICogICAgICAgaWYgKGVycikge1xuICAgICAqICAgICAgICAgLy8gdGhlIGNsaWVudCBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiAgICAgICB9XG4gICAgICogICAgIH0pO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIG5vdGU6IGlmIHBvc3NpYmxlLCB1c2luZyBhIHJvb20gaW5zdGVhZCBvZiBsb29waW5nIG92ZXIgYWxsIHNvY2tldHMgaXMgcHJlZmVyYWJsZVxuICAgICAqIGlvLnRpbWVvdXQoMTAwMCkudG8oc29tZUNvbmRpdGlvblJvb20pLmVtaXQoXCJzb21lLWV2ZW50XCIsIChlcnIsIHJlc3BvbnNlcykgPT4ge1xuICAgICAqICAgLy8gLi4uXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGltZW91dFxuICAgICAqL1xuICAgIHRpbWVvdXQodGltZW91dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvci50aW1lb3V0KHRpbWVvdXQpO1xuICAgIH1cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdG9yLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBKb2lucyBhIHJvb20uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcm9vbSAtIHJvb20gb3IgYXJyYXkgb2Ygcm9vbXNcbiAgICAgKi9cbiAgICBqb2luKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3Iuc29ja2V0c0pvaW4ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlYXZlcyBhIHJvb20uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcm9vbVxuICAgICAqL1xuICAgIGxlYXZlKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3Iuc29ja2V0c0xlYXZlKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyB0aGlzIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xvc2UgLSBpZiBgdHJ1ZWAsIGNsb3NlcyB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uXG4gICAgICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gICAgICovXG4gICAgZGlzY29ubmVjdChjbG9zZSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMub3BlcmF0b3IuZGlzY29ubmVjdFNvY2tldHMoY2xvc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLlJlbW90ZVNvY2tldCA9IFJlbW90ZVNvY2tldDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/broadcast-operator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/client.js":
/*!***********************************************!*\
  !*** ./node_modules/socket.io/dist/client.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Client = void 0;\nconst socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ \"(rsc)/./node_modules/socket.io-parser/build/cjs/index.js\");\nconst debugModule = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst debug = debugModule(\"socket.io:client\");\nclass Client {\n    /**\n     * Client constructor.\n     *\n     * @param server instance\n     * @param conn\n     * @package\n     */\n    constructor(server, conn) {\n        this.sockets = new Map();\n        this.nsps = new Map();\n        this.server = server;\n        this.conn = conn;\n        this.encoder = server.encoder;\n        this.decoder = new server._parser.Decoder();\n        this.id = conn.id;\n        this.setup();\n    }\n    /**\n     * @return the reference to the request that originated the Engine.IO connection\n     *\n     * @public\n     */\n    get request() {\n        return this.conn.request;\n    }\n    /**\n     * Sets up event listeners.\n     *\n     * @private\n     */\n    setup() {\n        this.onclose = this.onclose.bind(this);\n        this.ondata = this.ondata.bind(this);\n        this.onerror = this.onerror.bind(this);\n        this.ondecoded = this.ondecoded.bind(this);\n        // @ts-ignore\n        this.decoder.on(\"decoded\", this.ondecoded);\n        this.conn.on(\"data\", this.ondata);\n        this.conn.on(\"error\", this.onerror);\n        this.conn.on(\"close\", this.onclose);\n        this.connectTimeout = setTimeout(() => {\n            if (this.nsps.size === 0) {\n                debug(\"no namespace joined yet, close the client\");\n                this.close();\n            }\n            else {\n                debug(\"the client has already joined a namespace, nothing to do\");\n            }\n        }, this.server._connectTimeout);\n    }\n    /**\n     * Connects a client to a namespace.\n     *\n     * @param {String} name - the namespace\n     * @param {Object} auth - the auth parameters\n     * @private\n     */\n    connect(name, auth = {}) {\n        if (this.server._nsps.has(name)) {\n            debug(\"connecting to namespace %s\", name);\n            return this.doConnect(name, auth);\n        }\n        this.server._checkNamespace(name, auth, (dynamicNspName) => {\n            if (dynamicNspName) {\n                this.doConnect(name, auth);\n            }\n            else {\n                debug(\"creation of namespace %s was denied\", name);\n                this._packet({\n                    type: socket_io_parser_1.PacketType.CONNECT_ERROR,\n                    nsp: name,\n                    data: {\n                        message: \"Invalid namespace\",\n                    },\n                });\n            }\n        });\n    }\n    /**\n     * Connects a client to a namespace.\n     *\n     * @param name - the namespace\n     * @param {Object} auth - the auth parameters\n     *\n     * @private\n     */\n    doConnect(name, auth) {\n        const nsp = this.server.of(name);\n        nsp._add(this, auth, (socket) => {\n            this.sockets.set(socket.id, socket);\n            this.nsps.set(nsp.name, socket);\n            if (this.connectTimeout) {\n                clearTimeout(this.connectTimeout);\n                this.connectTimeout = undefined;\n            }\n        });\n    }\n    /**\n     * Disconnects from all namespaces and closes transport.\n     *\n     * @private\n     */\n    _disconnect() {\n        for (const socket of this.sockets.values()) {\n            socket.disconnect();\n        }\n        this.sockets.clear();\n        this.close();\n    }\n    /**\n     * Removes a socket. Called by each `Socket`.\n     *\n     * @private\n     */\n    _remove(socket) {\n        if (this.sockets.has(socket.id)) {\n            const nsp = this.sockets.get(socket.id).nsp.name;\n            this.sockets.delete(socket.id);\n            this.nsps.delete(nsp);\n        }\n        else {\n            debug(\"ignoring remove for %s\", socket.id);\n        }\n    }\n    /**\n     * Closes the underlying connection.\n     *\n     * @private\n     */\n    close() {\n        if (\"open\" === this.conn.readyState) {\n            debug(\"forcing transport close\");\n            this.conn.close();\n            this.onclose(\"forced server close\");\n        }\n    }\n    /**\n     * Writes a packet to the transport.\n     *\n     * @param {Object} packet object\n     * @param {Object} opts\n     * @private\n     */\n    _packet(packet, opts = {}) {\n        if (this.conn.readyState !== \"open\") {\n            debug(\"ignoring packet write %j\", packet);\n            return;\n        }\n        const encodedPackets = opts.preEncoded\n            ? packet // previous versions of the adapter incorrectly used socket.packet() instead of writeToEngine()\n            : this.encoder.encode(packet);\n        this.writeToEngine(encodedPackets, opts);\n    }\n    writeToEngine(encodedPackets, opts) {\n        if (opts.volatile && !this.conn.transport.writable) {\n            debug(\"volatile packet is discarded since the transport is not currently writable\");\n            return;\n        }\n        const packets = Array.isArray(encodedPackets)\n            ? encodedPackets\n            : [encodedPackets];\n        for (const encodedPacket of packets) {\n            this.conn.write(encodedPacket, opts);\n        }\n    }\n    /**\n     * Called with incoming transport data.\n     *\n     * @private\n     */\n    ondata(data) {\n        // try/catch is needed for protocol violations (GH-1880)\n        try {\n            this.decoder.add(data);\n        }\n        catch (e) {\n            debug(\"invalid packet format\");\n            this.onerror(e);\n        }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        let namespace;\n        let authPayload;\n        if (this.conn.protocol === 3) {\n            const parsed = url.parse(packet.nsp, true);\n            namespace = parsed.pathname;\n            authPayload = parsed.query;\n        }\n        else {\n            namespace = packet.nsp;\n            authPayload = packet.data;\n        }\n        const socket = this.nsps.get(namespace);\n        if (!socket && packet.type === socket_io_parser_1.PacketType.CONNECT) {\n            this.connect(namespace, authPayload);\n        }\n        else if (socket &&\n            packet.type !== socket_io_parser_1.PacketType.CONNECT &&\n            packet.type !== socket_io_parser_1.PacketType.CONNECT_ERROR) {\n            process.nextTick(function () {\n                socket._onpacket(packet);\n            });\n        }\n        else {\n            debug(\"invalid state (packet type: %s)\", packet.type);\n            this.close();\n        }\n    }\n    /**\n     * Handles an error.\n     *\n     * @param {Object} err object\n     * @private\n     */\n    onerror(err) {\n        for (const socket of this.sockets.values()) {\n            socket._onerror(err);\n        }\n        this.conn.close();\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @param reason\n     * @param description\n     * @private\n     */\n    onclose(reason, description) {\n        debug(\"client close with reason %s\", reason);\n        // ignore a potential subsequent `close` event\n        this.destroy();\n        // `nsps` and `sockets` are cleaned up seamlessly\n        for (const socket of this.sockets.values()) {\n            socket._onclose(reason, description);\n        }\n        this.sockets.clear();\n        this.decoder.destroy(); // clean up decoder\n    }\n    /**\n     * Cleans up event listeners.\n     * @private\n     */\n    destroy() {\n        this.conn.removeListener(\"data\", this.ondata);\n        this.conn.removeListener(\"error\", this.onerror);\n        this.conn.removeListener(\"close\", this.onclose);\n        // @ts-ignore\n        this.decoder.removeListener(\"decoded\", this.ondecoded);\n        if (this.connectTimeout) {\n            clearTimeout(this.connectTimeout);\n            this.connectTimeout = undefined;\n        }\n    }\n}\nexports.Client = Client;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCwyQkFBMkIsbUJBQU8sQ0FBQyxrRkFBa0I7QUFDckQsb0JBQW9CLG1CQUFPLENBQUMsNkVBQU87QUFDbkMsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3Jzb2xlL0RvY3VtZW50cy9HaXRIdWIvbWFzc2ltaW5vL21hc3NpbWluby9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DbGllbnQgPSB2b2lkIDA7XG5jb25zdCBzb2NrZXRfaW9fcGFyc2VyXzEgPSByZXF1aXJlKFwic29ja2V0LmlvLXBhcnNlclwiKTtcbmNvbnN0IGRlYnVnTW9kdWxlID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgdXJsID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJzb2NrZXQuaW86Y2xpZW50XCIpO1xuY2xhc3MgQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBDbGllbnQgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VydmVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIGNvbm5cbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNlcnZlciwgY29ubikge1xuICAgICAgICB0aGlzLnNvY2tldHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubnNwcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgICAgIHRoaXMuY29ubiA9IGNvbm47XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IHNlcnZlci5lbmNvZGVyO1xuICAgICAgICB0aGlzLmRlY29kZXIgPSBuZXcgc2VydmVyLl9wYXJzZXIuRGVjb2RlcigpO1xuICAgICAgICB0aGlzLmlkID0gY29ubi5pZDtcbiAgICAgICAgdGhpcy5zZXR1cCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHRoZSByZWZlcmVuY2UgdG8gdGhlIHJlcXVlc3QgdGhhdCBvcmlnaW5hdGVkIHRoZSBFbmdpbmUuSU8gY29ubmVjdGlvblxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldCByZXF1ZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uLnJlcXVlc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZXR1cCgpIHtcbiAgICAgICAgdGhpcy5vbmNsb3NlID0gdGhpcy5vbmNsb3NlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25kYXRhID0gdGhpcy5vbmRhdGEuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25kZWNvZGVkID0gdGhpcy5vbmRlY29kZWQuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmRlY29kZXIub24oXCJkZWNvZGVkXCIsIHRoaXMub25kZWNvZGVkKTtcbiAgICAgICAgdGhpcy5jb25uLm9uKFwiZGF0YVwiLCB0aGlzLm9uZGF0YSk7XG4gICAgICAgIHRoaXMuY29ubi5vbihcImVycm9yXCIsIHRoaXMub25lcnJvcik7XG4gICAgICAgIHRoaXMuY29ubi5vbihcImNsb3NlXCIsIHRoaXMub25jbG9zZSk7XG4gICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5zcHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwibm8gbmFtZXNwYWNlIGpvaW5lZCB5ZXQsIGNsb3NlIHRoZSBjbGllbnRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJ0aGUgY2xpZW50IGhhcyBhbHJlYWR5IGpvaW5lZCBhIG5hbWVzcGFjZSwgbm90aGluZyB0byBkb1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5zZXJ2ZXIuX2Nvbm5lY3RUaW1lb3V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdHMgYSBjbGllbnQgdG8gYSBuYW1lc3BhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIHRoZSBuYW1lc3BhY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXV0aCAtIHRoZSBhdXRoIHBhcmFtZXRlcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbm5lY3QobmFtZSwgYXV0aCA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLnNlcnZlci5fbnNwcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiY29ubmVjdGluZyB0byBuYW1lc3BhY2UgJXNcIiwgbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb0Nvbm5lY3QobmFtZSwgYXV0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJ2ZXIuX2NoZWNrTmFtZXNwYWNlKG5hbWUsIGF1dGgsIChkeW5hbWljTnNwTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGR5bmFtaWNOc3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0Nvbm5lY3QobmFtZSwgYXV0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImNyZWF0aW9uIG9mIG5hbWVzcGFjZSAlcyB3YXMgZGVuaWVkXCIsIG5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhY2tldCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkNPTk5FQ1RfRVJST1IsXG4gICAgICAgICAgICAgICAgICAgIG5zcDogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIG5hbWVzcGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdHMgYSBjbGllbnQgdG8gYSBuYW1lc3BhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lc3BhY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXV0aCAtIHRoZSBhdXRoIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZG9Db25uZWN0KG5hbWUsIGF1dGgpIHtcbiAgICAgICAgY29uc3QgbnNwID0gdGhpcy5zZXJ2ZXIub2YobmFtZSk7XG4gICAgICAgIG5zcC5fYWRkKHRoaXMsIGF1dGgsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0cy5zZXQoc29ja2V0LmlkLCBzb2NrZXQpO1xuICAgICAgICAgICAgdGhpcy5uc3BzLnNldChuc3AubmFtZSwgc29ja2V0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyBmcm9tIGFsbCBuYW1lc3BhY2VzIGFuZCBjbG9zZXMgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGlzY29ubmVjdCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBzb2NrZXQgb2YgdGhpcy5zb2NrZXRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBzb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ja2V0cy5jbGVhcigpO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBzb2NrZXQuIENhbGxlZCBieSBlYWNoIGBTb2NrZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlKHNvY2tldCkge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXRzLmhhcyhzb2NrZXQuaWQpKSB7XG4gICAgICAgICAgICBjb25zdCBuc3AgPSB0aGlzLnNvY2tldHMuZ2V0KHNvY2tldC5pZCkubnNwLm5hbWU7XG4gICAgICAgICAgICB0aGlzLnNvY2tldHMuZGVsZXRlKHNvY2tldC5pZCk7XG4gICAgICAgICAgICB0aGlzLm5zcHMuZGVsZXRlKG5zcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImlnbm9yaW5nIHJlbW92ZSBmb3IgJXNcIiwgc29ja2V0LmlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmIChcIm9wZW5cIiA9PT0gdGhpcy5jb25uLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiZm9yY2luZyB0cmFuc3BvcnQgY2xvc2VcIik7XG4gICAgICAgICAgICB0aGlzLmNvbm4uY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMub25jbG9zZShcImZvcmNlZCBzZXJ2ZXIgY2xvc2VcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgcGFja2V0IHRvIHRoZSB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcGFja2V0KHBhY2tldCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm4ucmVhZHlTdGF0ZSAhPT0gXCJvcGVuXCIpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiaWdub3JpbmcgcGFja2V0IHdyaXRlICVqXCIsIHBhY2tldCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jb2RlZFBhY2tldHMgPSBvcHRzLnByZUVuY29kZWRcbiAgICAgICAgICAgID8gcGFja2V0IC8vIHByZXZpb3VzIHZlcnNpb25zIG9mIHRoZSBhZGFwdGVyIGluY29ycmVjdGx5IHVzZWQgc29ja2V0LnBhY2tldCgpIGluc3RlYWQgb2Ygd3JpdGVUb0VuZ2luZSgpXG4gICAgICAgICAgICA6IHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0KTtcbiAgICAgICAgdGhpcy53cml0ZVRvRW5naW5lKGVuY29kZWRQYWNrZXRzLCBvcHRzKTtcbiAgICB9XG4gICAgd3JpdGVUb0VuZ2luZShlbmNvZGVkUGFja2V0cywgb3B0cykge1xuICAgICAgICBpZiAob3B0cy52b2xhdGlsZSAmJiAhdGhpcy5jb25uLnRyYW5zcG9ydC53cml0YWJsZSkge1xuICAgICAgICAgICAgZGVidWcoXCJ2b2xhdGlsZSBwYWNrZXQgaXMgZGlzY2FyZGVkIHNpbmNlIHRoZSB0cmFuc3BvcnQgaXMgbm90IGN1cnJlbnRseSB3cml0YWJsZVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWNrZXRzID0gQXJyYXkuaXNBcnJheShlbmNvZGVkUGFja2V0cylcbiAgICAgICAgICAgID8gZW5jb2RlZFBhY2tldHNcbiAgICAgICAgICAgIDogW2VuY29kZWRQYWNrZXRzXTtcbiAgICAgICAgZm9yIChjb25zdCBlbmNvZGVkUGFja2V0IG9mIHBhY2tldHMpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubi53cml0ZShlbmNvZGVkUGFja2V0LCBvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBpbmNvbWluZyB0cmFuc3BvcnQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25kYXRhKGRhdGEpIHtcbiAgICAgICAgLy8gdHJ5L2NhdGNoIGlzIG5lZWRlZCBmb3IgcHJvdG9jb2wgdmlvbGF0aW9ucyAoR0gtMTg4MClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiaW52YWxpZCBwYWNrZXQgZm9ybWF0XCIpO1xuICAgICAgICAgICAgdGhpcy5vbmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmRlY29kZWQocGFja2V0KSB7XG4gICAgICAgIGxldCBuYW1lc3BhY2U7XG4gICAgICAgIGxldCBhdXRoUGF5bG9hZDtcbiAgICAgICAgaWYgKHRoaXMuY29ubi5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gdXJsLnBhcnNlKHBhY2tldC5uc3AsIHRydWUpO1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgYXV0aFBheWxvYWQgPSBwYXJzZWQucXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBwYWNrZXQubnNwO1xuICAgICAgICAgICAgYXV0aFBheWxvYWQgPSBwYWNrZXQuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLm5zcHMuZ2V0KG5hbWVzcGFjZSk7XG4gICAgICAgIGlmICghc29ja2V0ICYmIHBhY2tldC50eXBlID09PSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNUKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QobmFtZXNwYWNlLCBhdXRoUGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc29ja2V0ICYmXG4gICAgICAgICAgICBwYWNrZXQudHlwZSAhPT0gc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQ09OTkVDVCAmJlxuICAgICAgICAgICAgcGFja2V0LnR5cGUgIT09IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkNPTk5FQ1RfRVJST1IpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNvY2tldC5fb25wYWNrZXQocGFja2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoXCJpbnZhbGlkIHN0YXRlIChwYWNrZXQgdHlwZTogJXMpXCIsIHBhY2tldC50eXBlKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVyciBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZXJyb3IoZXJyKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc29ja2V0IG9mIHRoaXMuc29ja2V0cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgc29ja2V0Ll9vbmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjbG9zZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWFzb25cbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uY2xvc2UocmVhc29uLCBkZXNjcmlwdGlvbikge1xuICAgICAgICBkZWJ1ZyhcImNsaWVudCBjbG9zZSB3aXRoIHJlYXNvbiAlc1wiLCByZWFzb24pO1xuICAgICAgICAvLyBpZ25vcmUgYSBwb3RlbnRpYWwgc3Vic2VxdWVudCBgY2xvc2VgIGV2ZW50XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAvLyBgbnNwc2AgYW5kIGBzb2NrZXRzYCBhcmUgY2xlYW5lZCB1cCBzZWFtbGVzc2x5XG4gICAgICAgIGZvciAoY29uc3Qgc29ja2V0IG9mIHRoaXMuc29ja2V0cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgc29ja2V0Ll9vbmNsb3NlKHJlYXNvbiwgZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ja2V0cy5jbGVhcigpO1xuICAgICAgICB0aGlzLmRlY29kZXIuZGVzdHJveSgpOyAvLyBjbGVhbiB1cCBkZWNvZGVyXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNvbm4ucmVtb3ZlTGlzdGVuZXIoXCJkYXRhXCIsIHRoaXMub25kYXRhKTtcbiAgICAgICAgdGhpcy5jb25uLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5vbmVycm9yKTtcbiAgICAgICAgdGhpcy5jb25uLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgdGhpcy5vbmNsb3NlKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmRlY29kZXIucmVtb3ZlTGlzdGVuZXIoXCJkZWNvZGVkXCIsIHRoaXMub25kZWNvZGVkKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/socket.io/dist/index.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Namespace = exports.Socket = exports.Server = void 0;\nconst http = __webpack_require__(/*! http */ \"http\");\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst zlib_1 = __webpack_require__(/*! zlib */ \"zlib\");\nconst accepts = __webpack_require__(/*! accepts */ \"(rsc)/./node_modules/accepts/index.js\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst engine_io_1 = __webpack_require__(/*! engine.io */ \"(rsc)/./node_modules/engine.io/build/engine.io.js\");\nconst client_1 = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/socket.io/dist/client.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst namespace_1 = __webpack_require__(/*! ./namespace */ \"(rsc)/./node_modules/socket.io/dist/namespace.js\");\nObject.defineProperty(exports, \"Namespace\", ({ enumerable: true, get: function () { return namespace_1.Namespace; } }));\nconst parent_namespace_1 = __webpack_require__(/*! ./parent-namespace */ \"(rsc)/./node_modules/socket.io/dist/parent-namespace.js\");\nconst socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/index.js\");\nconst parser = __importStar(__webpack_require__(/*! socket.io-parser */ \"(rsc)/./node_modules/socket.io-parser/build/cjs/index.js\"));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst socket_1 = __webpack_require__(/*! ./socket */ \"(rsc)/./node_modules/socket.io/dist/socket.js\");\nObject.defineProperty(exports, \"Socket\", ({ enumerable: true, get: function () { return socket_1.Socket; } }));\nconst typed_events_1 = __webpack_require__(/*! ./typed-events */ \"(rsc)/./node_modules/socket.io/dist/typed-events.js\");\nconst uws_1 = __webpack_require__(/*! ./uws */ \"(rsc)/./node_modules/socket.io/dist/uws.js\");\nconst cors_1 = __importDefault(__webpack_require__(/*! cors */ \"(rsc)/./node_modules/cors/lib/index.js\"));\nconst debug = (0, debug_1.default)(\"socket.io:server\");\nconst clientVersion = (__webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/socket.io/package.json\").version);\nconst dotMapRegex = /\\.map/;\n/**\n * Represents a Socket.IO server.\n *\n * @example\n * import { Server } from \"socket.io\";\n *\n * const io = new Server();\n *\n * io.on(\"connection\", (socket) => {\n *   console.log(`socket ${socket.id} connected`);\n *\n *   // send an event to the client\n *   socket.emit(\"foo\", \"bar\");\n *\n *   socket.on(\"foobar\", () => {\n *     // an event was received from the client\n *   });\n *\n *   // upon disconnection\n *   socket.on(\"disconnect\", (reason) => {\n *     console.log(`socket ${socket.id} disconnected due to ${reason}`);\n *   });\n * });\n *\n * io.listen(3000);\n */\nclass Server extends typed_events_1.StrictEventEmitter {\n    constructor(srv, opts = {}) {\n        super();\n        /**\n         * @private\n         */\n        this._nsps = new Map();\n        this.parentNsps = new Map();\n        /**\n         * A subset of the {@link parentNsps} map, only containing {@link ParentNamespace} which are based on a regular\n         * expression.\n         *\n         * @private\n         */\n        this.parentNamespacesFromRegExp = new Map();\n        if (\"object\" === typeof srv &&\n            srv instanceof Object &&\n            !srv.listen) {\n            opts = srv;\n            srv = undefined;\n        }\n        this.path(opts.path || \"/socket.io\");\n        this.connectTimeout(opts.connectTimeout || 45000);\n        this.serveClient(false !== opts.serveClient);\n        this._parser = opts.parser || parser;\n        this.encoder = new this._parser.Encoder();\n        this.opts = opts;\n        if (opts.connectionStateRecovery) {\n            opts.connectionStateRecovery = Object.assign({\n                maxDisconnectionDuration: 2 * 60 * 1000,\n                skipMiddlewares: true,\n            }, opts.connectionStateRecovery);\n            this.adapter(opts.adapter || socket_io_adapter_1.SessionAwareAdapter);\n        }\n        else {\n            this.adapter(opts.adapter || socket_io_adapter_1.Adapter);\n        }\n        opts.cleanupEmptyChildNamespaces = !!opts.cleanupEmptyChildNamespaces;\n        this.sockets = this.of(\"/\");\n        if (srv || typeof srv == \"number\")\n            this.attach(srv);\n        if (this.opts.cors) {\n            this._corsMiddleware = (0, cors_1.default)(this.opts.cors);\n        }\n    }\n    get _opts() {\n        return this.opts;\n    }\n    serveClient(v) {\n        if (!arguments.length)\n            return this._serveClient;\n        this._serveClient = v;\n        return this;\n    }\n    /**\n     * Executes the middleware for an incoming namespace not already created on the server.\n     *\n     * @param name - name of incoming namespace\n     * @param auth - the auth parameters\n     * @param fn - callback\n     *\n     * @private\n     */\n    _checkNamespace(name, auth, fn) {\n        if (this.parentNsps.size === 0)\n            return fn(false);\n        const keysIterator = this.parentNsps.keys();\n        const run = () => {\n            const nextFn = keysIterator.next();\n            if (nextFn.done) {\n                return fn(false);\n            }\n            nextFn.value(name, auth, (err, allow) => {\n                if (err || !allow) {\n                    return run();\n                }\n                if (this._nsps.has(name)) {\n                    // the namespace was created in the meantime\n                    debug(\"dynamic namespace %s already exists\", name);\n                    return fn(this._nsps.get(name));\n                }\n                const namespace = this.parentNsps.get(nextFn.value).createChild(name);\n                debug(\"dynamic namespace %s was created\", name);\n                fn(namespace);\n            });\n        };\n        run();\n    }\n    path(v) {\n        if (!arguments.length)\n            return this._path;\n        this._path = v.replace(/\\/$/, \"\");\n        const escapedPath = this._path.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n        this.clientPathRegex = new RegExp(\"^\" +\n            escapedPath +\n            \"/socket\\\\.io(\\\\.msgpack|\\\\.esm)?(\\\\.min)?\\\\.js(\\\\.map)?(?:\\\\?|$)\");\n        return this;\n    }\n    connectTimeout(v) {\n        if (v === undefined)\n            return this._connectTimeout;\n        this._connectTimeout = v;\n        return this;\n    }\n    adapter(v) {\n        if (!arguments.length)\n            return this._adapter;\n        this._adapter = v;\n        for (const nsp of this._nsps.values()) {\n            nsp._initAdapter();\n        }\n        return this;\n    }\n    /**\n     * Attaches socket.io to a server or port.\n     *\n     * @param srv - server or port\n     * @param opts - options passed to engine.io\n     * @return self\n     */\n    listen(srv, opts = {}) {\n        return this.attach(srv, opts);\n    }\n    /**\n     * Attaches socket.io to a server or port.\n     *\n     * @param srv - server or port\n     * @param opts - options passed to engine.io\n     * @return self\n     */\n    attach(srv, opts = {}) {\n        if (\"function\" == typeof srv) {\n            const msg = \"You are trying to attach socket.io to an express \" +\n                \"request handler function. Please pass a http.Server instance.\";\n            throw new Error(msg);\n        }\n        // handle a port as a string\n        if (Number(srv) == srv) {\n            srv = Number(srv);\n        }\n        if (\"number\" == typeof srv) {\n            debug(\"creating http server and binding to %d\", srv);\n            const port = srv;\n            srv = http.createServer((req, res) => {\n                res.writeHead(404);\n                res.end();\n            });\n            srv.listen(port);\n        }\n        // merge the options passed to the Socket.IO server\n        Object.assign(opts, this.opts);\n        // set engine.io path to `/socket.io`\n        opts.path = opts.path || this._path;\n        this.initEngine(srv, opts);\n        return this;\n    }\n    attachApp(app /*: TemplatedApp */, opts = {}) {\n        // merge the options passed to the Socket.IO server\n        Object.assign(opts, this.opts);\n        // set engine.io path to `/socket.io`\n        opts.path = opts.path || this._path;\n        // initialize engine\n        debug(\"creating uWebSockets.js-based engine with opts %j\", opts);\n        const engine = new engine_io_1.uServer(opts);\n        engine.attach(app, opts);\n        // bind to engine events\n        this.bind(engine);\n        if (this._serveClient) {\n            // attach static file serving\n            app.get(`${this._path}/*`, (res, req) => {\n                if (!this.clientPathRegex.test(req.getUrl())) {\n                    req.setYield(true);\n                    return;\n                }\n                const filename = req\n                    .getUrl()\n                    .replace(this._path, \"\")\n                    .replace(/\\?.*$/, \"\")\n                    .replace(/^\\//, \"\");\n                const isMap = dotMapRegex.test(filename);\n                const type = isMap ? \"map\" : \"source\";\n                // Per the standard, ETags must be quoted:\n                // https://tools.ietf.org/html/rfc7232#section-2.3\n                const expectedEtag = '\"' + clientVersion + '\"';\n                const weakEtag = \"W/\" + expectedEtag;\n                const etag = req.getHeader(\"if-none-match\");\n                if (etag) {\n                    if (expectedEtag === etag || weakEtag === etag) {\n                        debug(\"serve client %s 304\", type);\n                        res.writeStatus(\"304 Not Modified\");\n                        res.end();\n                        return;\n                    }\n                }\n                debug(\"serve client %s\", type);\n                res.writeHeader(\"cache-control\", \"public, max-age=0\");\n                res.writeHeader(\"content-type\", \"application/\" + (isMap ? \"json\" : \"javascript\") + \"; charset=utf-8\");\n                res.writeHeader(\"etag\", expectedEtag);\n                const filepath = path.join(__dirname, \"../client-dist/\", filename);\n                (0, uws_1.serveFile)(res, filepath);\n            });\n        }\n        (0, uws_1.patchAdapter)(app);\n    }\n    /**\n     * Initialize engine\n     *\n     * @param srv - the server to attach to\n     * @param opts - options passed to engine.io\n     * @private\n     */\n    initEngine(srv, opts) {\n        // initialize engine\n        debug(\"creating engine.io instance with opts %j\", opts);\n        this.eio = (0, engine_io_1.attach)(srv, opts);\n        // attach static file serving\n        if (this._serveClient)\n            this.attachServe(srv);\n        // Export http server\n        this.httpServer = srv;\n        // bind to engine events\n        this.bind(this.eio);\n    }\n    /**\n     * Attaches the static file serving.\n     *\n     * @param srv http server\n     * @private\n     */\n    attachServe(srv) {\n        debug(\"attaching client serving req handler\");\n        const evs = srv.listeners(\"request\").slice(0);\n        srv.removeAllListeners(\"request\");\n        srv.on(\"request\", (req, res) => {\n            if (this.clientPathRegex.test(req.url)) {\n                if (this._corsMiddleware) {\n                    this._corsMiddleware(req, res, () => {\n                        this.serve(req, res);\n                    });\n                }\n                else {\n                    this.serve(req, res);\n                }\n            }\n            else {\n                for (let i = 0; i < evs.length; i++) {\n                    evs[i].call(srv, req, res);\n                }\n            }\n        });\n    }\n    /**\n     * Handles a request serving of client source and map\n     *\n     * @param req\n     * @param res\n     * @private\n     */\n    serve(req, res) {\n        const filename = req.url.replace(this._path, \"\").replace(/\\?.*$/, \"\");\n        const isMap = dotMapRegex.test(filename);\n        const type = isMap ? \"map\" : \"source\";\n        // Per the standard, ETags must be quoted:\n        // https://tools.ietf.org/html/rfc7232#section-2.3\n        const expectedEtag = '\"' + clientVersion + '\"';\n        const weakEtag = \"W/\" + expectedEtag;\n        const etag = req.headers[\"if-none-match\"];\n        if (etag) {\n            if (expectedEtag === etag || weakEtag === etag) {\n                debug(\"serve client %s 304\", type);\n                res.writeHead(304);\n                res.end();\n                return;\n            }\n        }\n        debug(\"serve client %s\", type);\n        res.setHeader(\"Cache-Control\", \"public, max-age=0\");\n        res.setHeader(\"Content-Type\", \"application/\" + (isMap ? \"json\" : \"javascript\") + \"; charset=utf-8\");\n        res.setHeader(\"ETag\", expectedEtag);\n        Server.sendFile(filename, req, res);\n    }\n    /**\n     * @param filename\n     * @param req\n     * @param res\n     * @private\n     */\n    static sendFile(filename, req, res) {\n        const readStream = (0, fs_1.createReadStream)(path.join(__dirname, \"../client-dist/\", filename));\n        const encoding = accepts(req).encodings([\"br\", \"gzip\", \"deflate\"]);\n        const onError = (err) => {\n            if (err) {\n                res.end();\n            }\n        };\n        switch (encoding) {\n            case \"br\":\n                res.writeHead(200, { \"content-encoding\": \"br\" });\n                (0, stream_1.pipeline)(readStream, (0, zlib_1.createBrotliCompress)(), res, onError);\n                break;\n            case \"gzip\":\n                res.writeHead(200, { \"content-encoding\": \"gzip\" });\n                (0, stream_1.pipeline)(readStream, (0, zlib_1.createGzip)(), res, onError);\n                break;\n            case \"deflate\":\n                res.writeHead(200, { \"content-encoding\": \"deflate\" });\n                (0, stream_1.pipeline)(readStream, (0, zlib_1.createDeflate)(), res, onError);\n                break;\n            default:\n                res.writeHead(200);\n                (0, stream_1.pipeline)(readStream, res, onError);\n        }\n    }\n    /**\n     * Binds socket.io to an engine.io instance.\n     *\n     * @param engine engine.io (or compatible) server\n     * @return self\n     */\n    bind(engine) {\n        // TODO apply strict types to the engine: \"connection\" event, `close()` and a method to serve static content\n        //  this would allow to provide any custom engine, like one based on Deno or Bun built-in HTTP server\n        this.engine = engine;\n        this.engine.on(\"connection\", this.onconnection.bind(this));\n        return this;\n    }\n    /**\n     * Called with each incoming transport connection.\n     *\n     * @param {engine.Socket} conn\n     * @return self\n     * @private\n     */\n    onconnection(conn) {\n        debug(\"incoming connection with id %s\", conn.id);\n        const client = new client_1.Client(this, conn);\n        if (conn.protocol === 3) {\n            // @ts-ignore\n            client.connect(\"/\");\n        }\n        return this;\n    }\n    /**\n     * Looks up a namespace.\n     *\n     * @example\n     * // with a simple string\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // with a regex\n     * const dynamicNsp = io.of(/^\\/dynamic-\\d+$/).on(\"connection\", (socket) => {\n     *   const namespace = socket.nsp; // newNamespace.name === \"/dynamic-101\"\n     *\n     *   // broadcast to all clients in the given sub-namespace\n     *   namespace.emit(\"hello\");\n     * });\n     *\n     * @param name - nsp name\n     * @param fn optional, nsp `connection` ev handler\n     */\n    of(name, fn) {\n        if (typeof name === \"function\" || name instanceof RegExp) {\n            const parentNsp = new parent_namespace_1.ParentNamespace(this);\n            debug(\"initializing parent namespace %s\", parentNsp.name);\n            if (typeof name === \"function\") {\n                this.parentNsps.set(name, parentNsp);\n            }\n            else {\n                this.parentNsps.set((nsp, conn, next) => next(null, name.test(nsp)), parentNsp);\n                this.parentNamespacesFromRegExp.set(name, parentNsp);\n            }\n            if (fn) {\n                // @ts-ignore\n                parentNsp.on(\"connect\", fn);\n            }\n            return parentNsp;\n        }\n        if (String(name)[0] !== \"/\")\n            name = \"/\" + name;\n        let nsp = this._nsps.get(name);\n        if (!nsp) {\n            for (const [regex, parentNamespace] of this.parentNamespacesFromRegExp) {\n                if (regex.test(name)) {\n                    debug(\"attaching namespace %s to parent namespace %s\", name, regex);\n                    return parentNamespace.createChild(name);\n                }\n            }\n            debug(\"initializing namespace %s\", name);\n            nsp = new namespace_1.Namespace(this, name);\n            this._nsps.set(name, nsp);\n            if (name !== \"/\") {\n                // @ts-ignore\n                this.sockets.emitReserved(\"new_namespace\", nsp);\n            }\n        }\n        if (fn)\n            nsp.on(\"connect\", fn);\n        return nsp;\n    }\n    /**\n     * Closes server connection\n     *\n     * @param [fn] optional, called as `fn([err])` on error OR all conns closed\n     */\n    async close(fn) {\n        await Promise.allSettled([...this._nsps.values()].map(async (nsp) => {\n            nsp.sockets.forEach((socket) => {\n                socket._onclose(\"server shutting down\");\n            });\n            await nsp.adapter.close();\n        }));\n        this.engine.close();\n        // restore the Adapter prototype, when the Socket.IO server was attached to a uWebSockets.js server\n        (0, uws_1.restoreAdapter)();\n        if (this.httpServer) {\n            this.httpServer.close(fn);\n        }\n        else {\n            fn && fn();\n        }\n    }\n    /**\n     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.\n     *\n     * @example\n     * io.use((socket, next) => {\n     *   // ...\n     *   next();\n     * });\n     *\n     * @param fn - the middleware function\n     */\n    use(fn) {\n        this.sockets.use(fn);\n        return this;\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @example\n     * // the “foo” event will be broadcast to all connected clients in the “room-101” room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms (a client will be notified at most once)\n     * io.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    to(room) {\n        return this.sockets.to(room);\n    }\n    /**\n     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * // disconnect all clients in the \"room-101\" room\n     * io.in(\"room-101\").disconnectSockets();\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    in(room) {\n        return this.sockets.in(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @example\n     * // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     * io.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms\n     * io.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    except(room) {\n        return this.sockets.except(room);\n    }\n    /**\n     * Sends a `message` event to all clients.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * io.send(\"hello\");\n     *\n     * // this is equivalent to\n     * io.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */\n    send(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.sockets.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a `message` event to all clients. Alias of {@link send}.\n     *\n     * @return self\n     */\n    write(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.sockets.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a message to the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * io.serverSideEmit(\"hello\", \"world\");\n     *\n     * io.on(\"hello\", (arg1) => {\n     *   console.log(arg1); // prints \"world\"\n     * });\n     *\n     * // acknowledgements (without binary content) are supported too:\n     * io.serverSideEmit(\"ping\", (err, responses) => {\n     *  if (err) {\n     *     // some servers did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per server (except the current one)\n     *   }\n     * });\n     *\n     * io.on(\"ping\", (cb) => {\n     *   cb(\"pong\");\n     * });\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments, which may include an acknowledgement callback at the end\n     */\n    serverSideEmit(ev, ...args) {\n        return this.sockets.serverSideEmit(ev, ...args);\n    }\n    /**\n     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * try {\n     *   const responses = await io.serverSideEmitWithAck(\"ping\");\n     *   console.log(responses); // one response per server (except the current one)\n     * } catch (e) {\n     *   // some servers did not acknowledge the event in the given delay\n     * }\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments\n     *\n     * @return a Promise that will be fulfilled when all servers have acknowledged the event\n     */\n    serverSideEmitWithAck(ev, ...args) {\n        return this.sockets.serverSideEmitWithAck(ev, ...args);\n    }\n    /**\n     * Gets a list of socket ids.\n     *\n     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or\n     * {@link Server#fetchSockets} instead.\n     */\n    allSockets() {\n        return this.sockets.allSockets();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    compress(compress) {\n        return this.sockets.compress(compress);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.volatile.emit(\"hello\"); // the clients may or may not receive it\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    get volatile() {\n        return this.sockets.volatile;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * // the “foo” event will be broadcast to all connected clients on this node\n     * io.local.emit(\"foo\", \"bar\");\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    get local() {\n        return this.sockets.local;\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation.\n     *\n     * @example\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @param timeout\n     */\n    timeout(timeout) {\n        return this.sockets.timeout(timeout);\n    }\n    /**\n     * Returns the matching socket instances.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // return all Socket instances\n     * const sockets = await io.fetchSockets();\n     *\n     * // return all Socket instances in the \"room1\" room\n     * const sockets = await io.in(\"room1\").fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   console.log(socket.id);\n     *   console.log(socket.handshake);\n     *   console.log(socket.rooms);\n     *   console.log(socket.data);\n     *\n     *   socket.emit(\"hello\");\n     *   socket.join(\"room1\");\n     *   socket.leave(\"room2\");\n     *   socket.disconnect();\n     * }\n     */\n    fetchSockets() {\n        return this.sockets.fetchSockets();\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     *\n     * // make all socket instances join the \"room1\" room\n     * io.socketsJoin(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room join the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsJoin([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */\n    socketsJoin(room) {\n        return this.sockets.socketsJoin(room);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances leave the \"room1\" room\n     * io.socketsLeave(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room leave the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsLeave([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */\n    socketsLeave(room) {\n        return this.sockets.socketsLeave(room);\n    }\n    /**\n     * Makes the matching socket instances disconnect.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)\n     * io.disconnectSockets();\n     *\n     * // make all socket instances in the \"room1\" room disconnect and close the underlying connections\n     * io.in(\"room1\").disconnectSockets(true);\n     *\n     * @param close - whether to close the underlying connection\n     */\n    disconnectSockets(close = false) {\n        return this.sockets.disconnectSockets(close);\n    }\n}\nexports.Server = Server;\n/**\n * Expose main namespace (/).\n */\nconst emitterMethods = Object.keys(events_1.EventEmitter.prototype).filter(function (key) {\n    return typeof events_1.EventEmitter.prototype[key] === \"function\";\n});\nemitterMethods.forEach(function (fn) {\n    Server.prototype[fn] = function () {\n        return this.sockets[fn].apply(this.sockets, arguments);\n    };\n});\nmodule.exports = (srv, opts) => new Server(srv, opts);\nmodule.exports.Server = Server;\nmodule.exports.Namespace = namespace_1.Namespace;\nmodule.exports.Socket = socket_1.Socket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsY0FBYyxHQUFHLGNBQWM7QUFDbkQsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGFBQWEsbUJBQU8sQ0FBQyxjQUFJO0FBQ3pCLGVBQWUsbUJBQU8sQ0FBQyxrQkFBTTtBQUM3QixnQkFBZ0IsbUJBQU8sQ0FBQyxzREFBUztBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0Isb0JBQW9CLG1CQUFPLENBQUMsb0VBQVc7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsK0RBQVU7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsb0JBQW9CLG1CQUFPLENBQUMscUVBQWE7QUFDekMsNkNBQTRDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3JILDJCQUEyQixtQkFBTyxDQUFDLG1GQUFvQjtBQUN2RCw0QkFBNEIsbUJBQU8sQ0FBQywrRUFBbUI7QUFDdkQsNEJBQTRCLG1CQUFPLENBQUMsa0ZBQWtCO0FBQ3RELGdDQUFnQyxtQkFBTyxDQUFDLDZFQUFPO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLCtEQUFVO0FBQ25DLDBDQUF5QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM1Ryx1QkFBdUIsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDL0MsY0FBYyxtQkFBTyxDQUFDLHlEQUFPO0FBQzdCLCtCQUErQixtQkFBTyxDQUFDLG9EQUFNO0FBQzdDO0FBQ0Esc0JBQXNCLG1HQUFrQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXLHNCQUFzQixPQUFPO0FBQ3JFLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCLHNCQUFzQix1QkFBdUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMEJBQTBCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw0QkFBNEI7QUFDakU7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLCtCQUErQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixhQUFhO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxXQUFXO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLG1DQUFtQztBQUNuQztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsNkJBQTZCO0FBQ25ILFFBQVEsMkJBQTJCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLG1DQUFtQztBQUNuQztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsY0FBYztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHLGNBQWM7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxjQUFjO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHLGNBQWM7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUJBQXFCO0FBQ3JCLHdCQUF3QjtBQUN4QixxQkFBcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3Jzb2xlL0RvY3VtZW50cy9HaXRIdWIvbWFzc2ltaW5vL21hc3NpbWluby9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTmFtZXNwYWNlID0gZXhwb3J0cy5Tb2NrZXQgPSBleHBvcnRzLlNlcnZlciA9IHZvaWQgMDtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKFwiaHR0cFwiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCB6bGliXzEgPSByZXF1aXJlKFwiemxpYlwiKTtcbmNvbnN0IGFjY2VwdHMgPSByZXF1aXJlKFwiYWNjZXB0c1wiKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IGVuZ2luZV9pb18xID0gcmVxdWlyZShcImVuZ2luZS5pb1wiKTtcbmNvbnN0IGNsaWVudF8xID0gcmVxdWlyZShcIi4vY2xpZW50XCIpO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgbmFtZXNwYWNlXzEgPSByZXF1aXJlKFwiLi9uYW1lc3BhY2VcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOYW1lc3BhY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hbWVzcGFjZV8xLk5hbWVzcGFjZTsgfSB9KTtcbmNvbnN0IHBhcmVudF9uYW1lc3BhY2VfMSA9IHJlcXVpcmUoXCIuL3BhcmVudC1uYW1lc3BhY2VcIik7XG5jb25zdCBzb2NrZXRfaW9fYWRhcHRlcl8xID0gcmVxdWlyZShcInNvY2tldC5pby1hZGFwdGVyXCIpO1xuY29uc3QgcGFyc2VyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJzb2NrZXQuaW8tcGFyc2VyXCIpKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IHNvY2tldF8xID0gcmVxdWlyZShcIi4vc29ja2V0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU29ja2V0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzb2NrZXRfMS5Tb2NrZXQ7IH0gfSk7XG5jb25zdCB0eXBlZF9ldmVudHNfMSA9IHJlcXVpcmUoXCIuL3R5cGVkLWV2ZW50c1wiKTtcbmNvbnN0IHV3c18xID0gcmVxdWlyZShcIi4vdXdzXCIpO1xuY29uc3QgY29yc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjb3JzXCIpKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJzb2NrZXQuaW86c2VydmVyXCIpO1xuY29uc3QgY2xpZW50VmVyc2lvbiA9IHJlcXVpcmUoXCIuLi9wYWNrYWdlLmpzb25cIikudmVyc2lvbjtcbmNvbnN0IGRvdE1hcFJlZ2V4ID0gL1xcLm1hcC87XG4vKipcbiAqIFJlcHJlc2VudHMgYSBTb2NrZXQuSU8gc2VydmVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBTZXJ2ZXIgfSBmcm9tIFwic29ja2V0LmlvXCI7XG4gKlxuICogY29uc3QgaW8gPSBuZXcgU2VydmVyKCk7XG4gKlxuICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAqICAgY29uc29sZS5sb2coYHNvY2tldCAke3NvY2tldC5pZH0gY29ubmVjdGVkYCk7XG4gKlxuICogICAvLyBzZW5kIGFuIGV2ZW50IHRvIHRoZSBjbGllbnRcbiAqICAgc29ja2V0LmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gKlxuICogICBzb2NrZXQub24oXCJmb29iYXJcIiwgKCkgPT4ge1xuICogICAgIC8vIGFuIGV2ZW50IHdhcyByZWNlaXZlZCBmcm9tIHRoZSBjbGllbnRcbiAqICAgfSk7XG4gKlxuICogICAvLyB1cG9uIGRpc2Nvbm5lY3Rpb25cbiAqICAgc29ja2V0Lm9uKFwiZGlzY29ubmVjdFwiLCAocmVhc29uKSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coYHNvY2tldCAke3NvY2tldC5pZH0gZGlzY29ubmVjdGVkIGR1ZSB0byAke3JlYXNvbn1gKTtcbiAqICAgfSk7XG4gKiB9KTtcbiAqXG4gKiBpby5saXN0ZW4oMzAwMCk7XG4gKi9cbmNsYXNzIFNlcnZlciBleHRlbmRzIHR5cGVkX2V2ZW50c18xLlN0cmljdEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Ioc3J2LCBvcHRzID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9uc3BzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnBhcmVudE5zcHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHN1YnNldCBvZiB0aGUge0BsaW5rIHBhcmVudE5zcHN9IG1hcCwgb25seSBjb250YWluaW5nIHtAbGluayBQYXJlbnROYW1lc3BhY2V9IHdoaWNoIGFyZSBiYXNlZCBvbiBhIHJlZ3VsYXJcbiAgICAgICAgICogZXhwcmVzc2lvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFyZW50TmFtZXNwYWNlc0Zyb21SZWdFeHAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2Ygc3J2ICYmXG4gICAgICAgICAgICBzcnYgaW5zdGFuY2VvZiBPYmplY3QgJiZcbiAgICAgICAgICAgICFzcnYubGlzdGVuKSB7XG4gICAgICAgICAgICBvcHRzID0gc3J2O1xuICAgICAgICAgICAgc3J2ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0aChvcHRzLnBhdGggfHwgXCIvc29ja2V0LmlvXCIpO1xuICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0KG9wdHMuY29ubmVjdFRpbWVvdXQgfHwgNDUwMDApO1xuICAgICAgICB0aGlzLnNlcnZlQ2xpZW50KGZhbHNlICE9PSBvcHRzLnNlcnZlQ2xpZW50KTtcbiAgICAgICAgdGhpcy5fcGFyc2VyID0gb3B0cy5wYXJzZXIgfHwgcGFyc2VyO1xuICAgICAgICB0aGlzLmVuY29kZXIgPSBuZXcgdGhpcy5fcGFyc2VyLkVuY29kZXIoKTtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgaWYgKG9wdHMuY29ubmVjdGlvblN0YXRlUmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIG9wdHMuY29ubmVjdGlvblN0YXRlUmVjb3ZlcnkgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICBtYXhEaXNjb25uZWN0aW9uRHVyYXRpb246IDIgKiA2MCAqIDEwMDAsXG4gICAgICAgICAgICAgICAgc2tpcE1pZGRsZXdhcmVzOiB0cnVlLFxuICAgICAgICAgICAgfSwgb3B0cy5jb25uZWN0aW9uU3RhdGVSZWNvdmVyeSk7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIob3B0cy5hZGFwdGVyIHx8IHNvY2tldF9pb19hZGFwdGVyXzEuU2Vzc2lvbkF3YXJlQWRhcHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIob3B0cy5hZGFwdGVyIHx8IHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgb3B0cy5jbGVhbnVwRW1wdHlDaGlsZE5hbWVzcGFjZXMgPSAhIW9wdHMuY2xlYW51cEVtcHR5Q2hpbGROYW1lc3BhY2VzO1xuICAgICAgICB0aGlzLnNvY2tldHMgPSB0aGlzLm9mKFwiL1wiKTtcbiAgICAgICAgaWYgKHNydiB8fCB0eXBlb2Ygc3J2ID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aGlzLmF0dGFjaChzcnYpO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmNvcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvcnNNaWRkbGV3YXJlID0gKDAsIGNvcnNfMS5kZWZhdWx0KSh0aGlzLm9wdHMuY29ycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IF9vcHRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRzO1xuICAgIH1cbiAgICBzZXJ2ZUNsaWVudCh2KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXJ2ZUNsaWVudDtcbiAgICAgICAgdGhpcy5fc2VydmVDbGllbnQgPSB2O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIG1pZGRsZXdhcmUgZm9yIGFuIGluY29taW5nIG5hbWVzcGFjZSBub3QgYWxyZWFkeSBjcmVhdGVkIG9uIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAtIG5hbWUgb2YgaW5jb21pbmcgbmFtZXNwYWNlXG4gICAgICogQHBhcmFtIGF1dGggLSB0aGUgYXV0aCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIGZuIC0gY2FsbGJhY2tcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NoZWNrTmFtZXNwYWNlKG5hbWUsIGF1dGgsIGZuKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudE5zcHMuc2l6ZSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBmbihmYWxzZSk7XG4gICAgICAgIGNvbnN0IGtleXNJdGVyYXRvciA9IHRoaXMucGFyZW50TnNwcy5rZXlzKCk7XG4gICAgICAgIGNvbnN0IHJ1biA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRGbiA9IGtleXNJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAobmV4dEZuLmRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dEZuLnZhbHVlKG5hbWUsIGF1dGgsIChlcnIsIGFsbG93KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciB8fCAhYWxsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1bigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbnNwcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5hbWVzcGFjZSB3YXMgY3JlYXRlZCBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJkeW5hbWljIG5hbWVzcGFjZSAlcyBhbHJlYWR5IGV4aXN0c1wiLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKHRoaXMuX25zcHMuZ2V0KG5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZXNwYWNlID0gdGhpcy5wYXJlbnROc3BzLmdldChuZXh0Rm4udmFsdWUpLmNyZWF0ZUNoaWxkKG5hbWUpO1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiZHluYW1pYyBuYW1lc3BhY2UgJXMgd2FzIGNyZWF0ZWRcIiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgZm4obmFtZXNwYWNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBydW4oKTtcbiAgICB9XG4gICAgcGF0aCh2KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXRoO1xuICAgICAgICB0aGlzLl9wYXRoID0gdi5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gICAgICAgIGNvbnN0IGVzY2FwZWRQYXRoID0gdGhpcy5fcGF0aC5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csIFwiXFxcXCQmXCIpO1xuICAgICAgICB0aGlzLmNsaWVudFBhdGhSZWdleCA9IG5ldyBSZWdFeHAoXCJeXCIgK1xuICAgICAgICAgICAgZXNjYXBlZFBhdGggK1xuICAgICAgICAgICAgXCIvc29ja2V0XFxcXC5pbyhcXFxcLm1zZ3BhY2t8XFxcXC5lc20pPyhcXFxcLm1pbik/XFxcXC5qcyhcXFxcLm1hcCk/KD86XFxcXD98JClcIik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25uZWN0VGltZW91dCh2KSB7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdFRpbWVvdXQ7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RUaW1lb3V0ID0gdjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkYXB0ZXIodikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRhcHRlcjtcbiAgICAgICAgdGhpcy5fYWRhcHRlciA9IHY7XG4gICAgICAgIGZvciAoY29uc3QgbnNwIG9mIHRoaXMuX25zcHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIG5zcC5faW5pdEFkYXB0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgc29ja2V0LmlvIHRvIGEgc2VydmVyIG9yIHBvcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3J2IC0gc2VydmVyIG9yIHBvcnRcbiAgICAgKiBAcGFyYW0gb3B0cyAtIG9wdGlvbnMgcGFzc2VkIHRvIGVuZ2luZS5pb1xuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIGxpc3RlbihzcnYsIG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRhY2goc3J2LCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgc29ja2V0LmlvIHRvIGEgc2VydmVyIG9yIHBvcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3J2IC0gc2VydmVyIG9yIHBvcnRcbiAgICAgKiBAcGFyYW0gb3B0cyAtIG9wdGlvbnMgcGFzc2VkIHRvIGVuZ2luZS5pb1xuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIGF0dGFjaChzcnYsIG9wdHMgPSB7fSkge1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBzcnYpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IFwiWW91IGFyZSB0cnlpbmcgdG8gYXR0YWNoIHNvY2tldC5pbyB0byBhbiBleHByZXNzIFwiICtcbiAgICAgICAgICAgICAgICBcInJlcXVlc3QgaGFuZGxlciBmdW5jdGlvbi4gUGxlYXNlIHBhc3MgYSBodHRwLlNlcnZlciBpbnN0YW5jZS5cIjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBhIHBvcnQgYXMgYSBzdHJpbmdcbiAgICAgICAgaWYgKE51bWJlcihzcnYpID09IHNydikge1xuICAgICAgICAgICAgc3J2ID0gTnVtYmVyKHNydik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIHNydikge1xuICAgICAgICAgICAgZGVidWcoXCJjcmVhdGluZyBodHRwIHNlcnZlciBhbmQgYmluZGluZyB0byAlZFwiLCBzcnYpO1xuICAgICAgICAgICAgY29uc3QgcG9ydCA9IHNydjtcbiAgICAgICAgICAgIHNydiA9IGh0dHAuY3JlYXRlU2VydmVyKChyZXEsIHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoNDA0KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNydi5saXN0ZW4ocG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgdGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBTb2NrZXQuSU8gc2VydmVyXG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3B0cywgdGhpcy5vcHRzKTtcbiAgICAgICAgLy8gc2V0IGVuZ2luZS5pbyBwYXRoIHRvIGAvc29ja2V0LmlvYFxuICAgICAgICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgdGhpcy5fcGF0aDtcbiAgICAgICAgdGhpcy5pbml0RW5naW5lKHNydiwgb3B0cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhdHRhY2hBcHAoYXBwIC8qOiBUZW1wbGF0ZWRBcHAgKi8sIG9wdHMgPSB7fSkge1xuICAgICAgICAvLyBtZXJnZSB0aGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIFNvY2tldC5JTyBzZXJ2ZXJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLCB0aGlzLm9wdHMpO1xuICAgICAgICAvLyBzZXQgZW5naW5lLmlvIHBhdGggdG8gYC9zb2NrZXQuaW9gXG4gICAgICAgIG9wdHMucGF0aCA9IG9wdHMucGF0aCB8fCB0aGlzLl9wYXRoO1xuICAgICAgICAvLyBpbml0aWFsaXplIGVuZ2luZVxuICAgICAgICBkZWJ1ZyhcImNyZWF0aW5nIHVXZWJTb2NrZXRzLmpzLWJhc2VkIGVuZ2luZSB3aXRoIG9wdHMgJWpcIiwgb3B0cyk7XG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IG5ldyBlbmdpbmVfaW9fMS51U2VydmVyKG9wdHMpO1xuICAgICAgICBlbmdpbmUuYXR0YWNoKGFwcCwgb3B0cyk7XG4gICAgICAgIC8vIGJpbmQgdG8gZW5naW5lIGV2ZW50c1xuICAgICAgICB0aGlzLmJpbmQoZW5naW5lKTtcbiAgICAgICAgaWYgKHRoaXMuX3NlcnZlQ2xpZW50KSB7XG4gICAgICAgICAgICAvLyBhdHRhY2ggc3RhdGljIGZpbGUgc2VydmluZ1xuICAgICAgICAgICAgYXBwLmdldChgJHt0aGlzLl9wYXRofS8qYCwgKHJlcywgcmVxKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNsaWVudFBhdGhSZWdleC50ZXN0KHJlcS5nZXRVcmwoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxLnNldFlpZWxkKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gcmVxXG4gICAgICAgICAgICAgICAgICAgIC5nZXRVcmwoKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSh0aGlzLl9wYXRoLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFw/LiokLywgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL15cXC8vLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc01hcCA9IGRvdE1hcFJlZ2V4LnRlc3QoZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBpc01hcCA/IFwibWFwXCIgOiBcInNvdXJjZVwiO1xuICAgICAgICAgICAgICAgIC8vIFBlciB0aGUgc3RhbmRhcmQsIEVUYWdzIG11c3QgYmUgcXVvdGVkOlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMyI3NlY3Rpb24tMi4zXG4gICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRFdGFnID0gJ1wiJyArIGNsaWVudFZlcnNpb24gKyAnXCInO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdlYWtFdGFnID0gXCJXL1wiICsgZXhwZWN0ZWRFdGFnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV0YWcgPSByZXEuZ2V0SGVhZGVyKFwiaWYtbm9uZS1tYXRjaFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZXRhZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwZWN0ZWRFdGFnID09PSBldGFnIHx8IHdlYWtFdGFnID09PSBldGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInNlcnZlIGNsaWVudCAlcyAzMDRcIiwgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMud3JpdGVTdGF0dXMoXCIzMDQgTm90IE1vZGlmaWVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlYnVnKFwic2VydmUgY2xpZW50ICVzXCIsIHR5cGUpO1xuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWRlcihcImNhY2hlLWNvbnRyb2xcIiwgXCJwdWJsaWMsIG1heC1hZ2U9MFwiKTtcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkZXIoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9cIiArIChpc01hcCA/IFwianNvblwiIDogXCJqYXZhc2NyaXB0XCIpICsgXCI7IGNoYXJzZXQ9dXRmLThcIik7XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZGVyKFwiZXRhZ1wiLCBleHBlY3RlZEV0YWcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVwYXRoID0gcGF0aC5qb2luKF9fZGlybmFtZSwgXCIuLi9jbGllbnQtZGlzdC9cIiwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICgwLCB1d3NfMS5zZXJ2ZUZpbGUpKHJlcywgZmlsZXBhdGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHV3c18xLnBhdGNoQWRhcHRlcikoYXBwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBlbmdpbmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzcnYgLSB0aGUgc2VydmVyIHRvIGF0dGFjaCB0b1xuICAgICAqIEBwYXJhbSBvcHRzIC0gb3B0aW9ucyBwYXNzZWQgdG8gZW5naW5lLmlvXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0RW5naW5lKHNydiwgb3B0cykge1xuICAgICAgICAvLyBpbml0aWFsaXplIGVuZ2luZVxuICAgICAgICBkZWJ1ZyhcImNyZWF0aW5nIGVuZ2luZS5pbyBpbnN0YW5jZSB3aXRoIG9wdHMgJWpcIiwgb3B0cyk7XG4gICAgICAgIHRoaXMuZWlvID0gKDAsIGVuZ2luZV9pb18xLmF0dGFjaCkoc3J2LCBvcHRzKTtcbiAgICAgICAgLy8gYXR0YWNoIHN0YXRpYyBmaWxlIHNlcnZpbmdcbiAgICAgICAgaWYgKHRoaXMuX3NlcnZlQ2xpZW50KVxuICAgICAgICAgICAgdGhpcy5hdHRhY2hTZXJ2ZShzcnYpO1xuICAgICAgICAvLyBFeHBvcnQgaHR0cCBzZXJ2ZXJcbiAgICAgICAgdGhpcy5odHRwU2VydmVyID0gc3J2O1xuICAgICAgICAvLyBiaW5kIHRvIGVuZ2luZSBldmVudHNcbiAgICAgICAgdGhpcy5iaW5kKHRoaXMuZWlvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgdGhlIHN0YXRpYyBmaWxlIHNlcnZpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3J2IGh0dHAgc2VydmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhdHRhY2hTZXJ2ZShzcnYpIHtcbiAgICAgICAgZGVidWcoXCJhdHRhY2hpbmcgY2xpZW50IHNlcnZpbmcgcmVxIGhhbmRsZXJcIik7XG4gICAgICAgIGNvbnN0IGV2cyA9IHNydi5saXN0ZW5lcnMoXCJyZXF1ZXN0XCIpLnNsaWNlKDApO1xuICAgICAgICBzcnYucmVtb3ZlQWxsTGlzdGVuZXJzKFwicmVxdWVzdFwiKTtcbiAgICAgICAgc3J2Lm9uKFwicmVxdWVzdFwiLCAocmVxLCByZXMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudFBhdGhSZWdleC50ZXN0KHJlcS51cmwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvcnNNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvcnNNaWRkbGV3YXJlKHJlcSwgcmVzLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcnZlKHJlcSwgcmVzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcnZlKHJlcSwgcmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBldnNbaV0uY2FsbChzcnYsIHJlcSwgcmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGEgcmVxdWVzdCBzZXJ2aW5nIG9mIGNsaWVudCBzb3VyY2UgYW5kIG1hcFxuICAgICAqXG4gICAgICogQHBhcmFtIHJlcVxuICAgICAqIEBwYXJhbSByZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNlcnZlKHJlcSwgcmVzKSB7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gcmVxLnVybC5yZXBsYWNlKHRoaXMuX3BhdGgsIFwiXCIpLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpO1xuICAgICAgICBjb25zdCBpc01hcCA9IGRvdE1hcFJlZ2V4LnRlc3QoZmlsZW5hbWUpO1xuICAgICAgICBjb25zdCB0eXBlID0gaXNNYXAgPyBcIm1hcFwiIDogXCJzb3VyY2VcIjtcbiAgICAgICAgLy8gUGVyIHRoZSBzdGFuZGFyZCwgRVRhZ3MgbXVzdCBiZSBxdW90ZWQ6XG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMyI3NlY3Rpb24tMi4zXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkRXRhZyA9ICdcIicgKyBjbGllbnRWZXJzaW9uICsgJ1wiJztcbiAgICAgICAgY29uc3Qgd2Vha0V0YWcgPSBcIlcvXCIgKyBleHBlY3RlZEV0YWc7XG4gICAgICAgIGNvbnN0IGV0YWcgPSByZXEuaGVhZGVyc1tcImlmLW5vbmUtbWF0Y2hcIl07XG4gICAgICAgIGlmIChldGFnKSB7XG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRFdGFnID09PSBldGFnIHx8IHdlYWtFdGFnID09PSBldGFnKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJzZXJ2ZSBjbGllbnQgJXMgMzA0XCIsIHR5cGUpO1xuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoMzA0KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwic2VydmUgY2xpZW50ICVzXCIsIHR5cGUpO1xuICAgICAgICByZXMuc2V0SGVhZGVyKFwiQ2FjaGUtQ29udHJvbFwiLCBcInB1YmxpYywgbWF4LWFnZT0wXCIpO1xuICAgICAgICByZXMuc2V0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vXCIgKyAoaXNNYXAgPyBcImpzb25cIiA6IFwiamF2YXNjcmlwdFwiKSArIFwiOyBjaGFyc2V0PXV0Zi04XCIpO1xuICAgICAgICByZXMuc2V0SGVhZGVyKFwiRVRhZ1wiLCBleHBlY3RlZEV0YWcpO1xuICAgICAgICBTZXJ2ZXIuc2VuZEZpbGUoZmlsZW5hbWUsIHJlcSwgcmVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZpbGVuYW1lXG4gICAgICogQHBhcmFtIHJlcVxuICAgICAqIEBwYXJhbSByZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBzZW5kRmlsZShmaWxlbmFtZSwgcmVxLCByZXMpIHtcbiAgICAgICAgY29uc3QgcmVhZFN0cmVhbSA9ICgwLCBmc18xLmNyZWF0ZVJlYWRTdHJlYW0pKHBhdGguam9pbihfX2Rpcm5hbWUsIFwiLi4vY2xpZW50LWRpc3QvXCIsIGZpbGVuYW1lKSk7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gYWNjZXB0cyhyZXEpLmVuY29kaW5ncyhbXCJiclwiLCBcImd6aXBcIiwgXCJkZWZsYXRlXCJdKTtcbiAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgXCJiclwiOlxuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoMjAwLCB7IFwiY29udGVudC1lbmNvZGluZ1wiOiBcImJyXCIgfSk7XG4gICAgICAgICAgICAgICAgKDAsIHN0cmVhbV8xLnBpcGVsaW5lKShyZWFkU3RyZWFtLCAoMCwgemxpYl8xLmNyZWF0ZUJyb3RsaUNvbXByZXNzKSgpLCByZXMsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImd6aXBcIjpcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkKDIwMCwgeyBcImNvbnRlbnQtZW5jb2RpbmdcIjogXCJnemlwXCIgfSk7XG4gICAgICAgICAgICAgICAgKDAsIHN0cmVhbV8xLnBpcGVsaW5lKShyZWFkU3RyZWFtLCAoMCwgemxpYl8xLmNyZWF0ZUd6aXApKCksIHJlcywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGVmbGF0ZVwiOlxuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoMjAwLCB7IFwiY29udGVudC1lbmNvZGluZ1wiOiBcImRlZmxhdGVcIiB9KTtcbiAgICAgICAgICAgICAgICAoMCwgc3RyZWFtXzEucGlwZWxpbmUpKHJlYWRTdHJlYW0sICgwLCB6bGliXzEuY3JlYXRlRGVmbGF0ZSkoKSwgcmVzLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZCgyMDApO1xuICAgICAgICAgICAgICAgICgwLCBzdHJlYW1fMS5waXBlbGluZSkocmVhZFN0cmVhbSwgcmVzLCBvbkVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kcyBzb2NrZXQuaW8gdG8gYW4gZW5naW5lLmlvIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVuZ2luZSBlbmdpbmUuaW8gKG9yIGNvbXBhdGlibGUpIHNlcnZlclxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIGJpbmQoZW5naW5lKSB7XG4gICAgICAgIC8vIFRPRE8gYXBwbHkgc3RyaWN0IHR5cGVzIHRvIHRoZSBlbmdpbmU6IFwiY29ubmVjdGlvblwiIGV2ZW50LCBgY2xvc2UoKWAgYW5kIGEgbWV0aG9kIHRvIHNlcnZlIHN0YXRpYyBjb250ZW50XG4gICAgICAgIC8vICB0aGlzIHdvdWxkIGFsbG93IHRvIHByb3ZpZGUgYW55IGN1c3RvbSBlbmdpbmUsIGxpa2Ugb25lIGJhc2VkIG9uIERlbm8gb3IgQnVuIGJ1aWx0LWluIEhUVFAgc2VydmVyXG4gICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuICAgICAgICB0aGlzLmVuZ2luZS5vbihcImNvbm5lY3Rpb25cIiwgdGhpcy5vbmNvbm5lY3Rpb24uYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBlYWNoIGluY29taW5nIHRyYW5zcG9ydCBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtlbmdpbmUuU29ja2V0fSBjb25uXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmNvbm5lY3Rpb24oY29ubikge1xuICAgICAgICBkZWJ1ZyhcImluY29taW5nIGNvbm5lY3Rpb24gd2l0aCBpZCAlc1wiLCBjb25uLmlkKTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gbmV3IGNsaWVudF8xLkNsaWVudCh0aGlzLCBjb25uKTtcbiAgICAgICAgaWYgKGNvbm4ucHJvdG9jb2wgPT09IDMpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNsaWVudC5jb25uZWN0KFwiL1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3MgdXAgYSBuYW1lc3BhY2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHdpdGggYSBzaW1wbGUgc3RyaW5nXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGEgcmVnZXhcbiAgICAgKiBjb25zdCBkeW5hbWljTnNwID0gaW8ub2YoL15cXC9keW5hbWljLVxcZCskLykub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIGNvbnN0IG5hbWVzcGFjZSA9IHNvY2tldC5uc3A7IC8vIG5ld05hbWVzcGFjZS5uYW1lID09PSBcIi9keW5hbWljLTEwMVwiXG4gICAgICpcbiAgICAgKiAgIC8vIGJyb2FkY2FzdCB0byBhbGwgY2xpZW50cyBpbiB0aGUgZ2l2ZW4gc3ViLW5hbWVzcGFjZVxuICAgICAqICAgbmFtZXNwYWNlLmVtaXQoXCJoZWxsb1wiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gbnNwIG5hbWVcbiAgICAgKiBAcGFyYW0gZm4gb3B0aW9uYWwsIG5zcCBgY29ubmVjdGlvbmAgZXYgaGFuZGxlclxuICAgICAqL1xuICAgIG9mKG5hbWUsIGZuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiIHx8IG5hbWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE5zcCA9IG5ldyBwYXJlbnRfbmFtZXNwYWNlXzEuUGFyZW50TmFtZXNwYWNlKHRoaXMpO1xuICAgICAgICAgICAgZGVidWcoXCJpbml0aWFsaXppbmcgcGFyZW50IG5hbWVzcGFjZSAlc1wiLCBwYXJlbnROc3AubmFtZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50TnNwcy5zZXQobmFtZSwgcGFyZW50TnNwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50TnNwcy5zZXQoKG5zcCwgY29ubiwgbmV4dCkgPT4gbmV4dChudWxsLCBuYW1lLnRlc3QobnNwKSksIHBhcmVudE5zcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROYW1lc3BhY2VzRnJvbVJlZ0V4cC5zZXQobmFtZSwgcGFyZW50TnNwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBwYXJlbnROc3Aub24oXCJjb25uZWN0XCIsIGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnROc3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFN0cmluZyhuYW1lKVswXSAhPT0gXCIvXCIpXG4gICAgICAgICAgICBuYW1lID0gXCIvXCIgKyBuYW1lO1xuICAgICAgICBsZXQgbnNwID0gdGhpcy5fbnNwcy5nZXQobmFtZSk7XG4gICAgICAgIGlmICghbnNwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtyZWdleCwgcGFyZW50TmFtZXNwYWNlXSBvZiB0aGlzLnBhcmVudE5hbWVzcGFjZXNGcm9tUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJhdHRhY2hpbmcgbmFtZXNwYWNlICVzIHRvIHBhcmVudCBuYW1lc3BhY2UgJXNcIiwgbmFtZSwgcmVnZXgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50TmFtZXNwYWNlLmNyZWF0ZUNoaWxkKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlYnVnKFwiaW5pdGlhbGl6aW5nIG5hbWVzcGFjZSAlc1wiLCBuYW1lKTtcbiAgICAgICAgICAgIG5zcCA9IG5ldyBuYW1lc3BhY2VfMS5OYW1lc3BhY2UodGhpcywgbmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9uc3BzLnNldChuYW1lLCBuc3ApO1xuICAgICAgICAgICAgaWYgKG5hbWUgIT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0cy5lbWl0UmVzZXJ2ZWQoXCJuZXdfbmFtZXNwYWNlXCIsIG5zcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZuKVxuICAgICAgICAgICAgbnNwLm9uKFwiY29ubmVjdFwiLCBmbik7XG4gICAgICAgIHJldHVybiBuc3A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyBzZXJ2ZXIgY29ubmVjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIFtmbl0gb3B0aW9uYWwsIGNhbGxlZCBhcyBgZm4oW2Vycl0pYCBvbiBlcnJvciBPUiBhbGwgY29ubnMgY2xvc2VkXG4gICAgICovXG4gICAgYXN5bmMgY2xvc2UoZm4pIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFsuLi50aGlzLl9uc3BzLnZhbHVlcygpXS5tYXAoYXN5bmMgKG5zcCkgPT4ge1xuICAgICAgICAgICAgbnNwLnNvY2tldHMuZm9yRWFjaCgoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgc29ja2V0Ll9vbmNsb3NlKFwic2VydmVyIHNodXR0aW5nIGRvd25cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IG5zcC5hZGFwdGVyLmNsb3NlKCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbiAgICAgICAgLy8gcmVzdG9yZSB0aGUgQWRhcHRlciBwcm90b3R5cGUsIHdoZW4gdGhlIFNvY2tldC5JTyBzZXJ2ZXIgd2FzIGF0dGFjaGVkIHRvIGEgdVdlYlNvY2tldHMuanMgc2VydmVyXG4gICAgICAgICgwLCB1d3NfMS5yZXN0b3JlQWRhcHRlcikoKTtcbiAgICAgICAgaWYgKHRoaXMuaHR0cFNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5odHRwU2VydmVyLmNsb3NlKGZuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZuICYmIGZuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgbWlkZGxld2FyZSwgd2hpY2ggaXMgYSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgZm9yIGV2ZXJ5IGluY29taW5nIHtAbGluayBTb2NrZXR9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby51c2UoKHNvY2tldCwgbmV4dCkgPT4ge1xuICAgICAqICAgLy8gLi4uXG4gICAgICogICBuZXh0KCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm4gLSB0aGUgbWlkZGxld2FyZSBmdW5jdGlvblxuICAgICAqL1xuICAgIHVzZShmbikge1xuICAgICAgICB0aGlzLnNvY2tldHMudXNlKGZuKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gZW1pdHRpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHRoZSDigJxmb2/igJ0gZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzIGluIHRoZSDigJxyb29tLTEwMeKAnSByb29tXG4gICAgICogaW8udG8oXCJyb29tLTEwMVwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBhbiBhcnJheSBvZiByb29tcyAoYSBjbGllbnQgd2lsbCBiZSBub3RpZmllZCBhdCBtb3N0IG9uY2UpXG4gICAgICogaW8udG8oW1wicm9vbS0xMDFcIiwgXCJyb29tLTEwMlwiXSkuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggbXVsdGlwbGUgY2hhaW5lZCBjYWxsc1xuICAgICAqIGlvLnRvKFwicm9vbS0xMDFcIikudG8oXCJyb29tLTEwMlwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIHRvKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy50byhyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBlbWl0dGluZy4gU2ltaWxhciB0byBgdG8oKWAsIGJ1dCBtaWdodCBmZWVsIGNsZWFyZXIgaW4gc29tZSBjYXNlczpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZGlzY29ubmVjdCBhbGwgY2xpZW50cyBpbiB0aGUgXCJyb29tLTEwMVwiIHJvb21cbiAgICAgKiBpby5pbihcInJvb20tMTAxXCIpLmRpc2Nvbm5lY3RTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgaW4ocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLmluKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGNsdWRlcyBhIHJvb20gd2hlbiBlbWl0dGluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gdGhlIFwiZm9vXCIgZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzLCBleGNlcHQgdGhlIG9uZXMgdGhhdCBhcmUgaW4gdGhlIFwicm9vbS0xMDFcIiByb29tXG4gICAgICogaW8uZXhjZXB0KFwicm9vbS0xMDFcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBpby5leGNlcHQoW1wicm9vbS0xMDFcIiwgXCJyb29tLTEwMlwiXSkuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggbXVsdGlwbGUgY2hhaW5lZCBjYWxsc1xuICAgICAqIGlvLmV4Y2VwdChcInJvb20tMTAxXCIpLmV4Y2VwdChcInJvb20tMTAyXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZXhjZXB0KHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5leGNlcHQocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50IHRvIGFsbCBjbGllbnRzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWltaWNzIHRoZSBXZWJTb2NrZXQuc2VuZCgpIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlNvY2tldC9zZW5kXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLnNlbmQoXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqIC8vIHRoaXMgaXMgZXF1aXZhbGVudCB0b1xuICAgICAqIGlvLmVtaXQoXCJtZXNzYWdlXCIsIFwiaGVsbG9cIik7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBzZW5kKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gVGhpcyB0eXBlLWNhc3QgaXMgbmVlZGVkIGJlY2F1c2UgRW1pdEV2ZW50cyBsaWtlbHkgZG9lc24ndCBoYXZlIGBtZXNzYWdlYCBhcyBhIGtleS5cbiAgICAgICAgLy8gaWYgeW91IHNwZWNpZnkgdGhlIEVtaXRFdmVudHMsIHRoZSB0eXBlIG9mIGFyZ3Mgd2lsbCBiZSBuZXZlci5cbiAgICAgICAgdGhpcy5zb2NrZXRzLmVtaXQoXCJtZXNzYWdlXCIsIC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQgdG8gYWxsIGNsaWVudHMuIEFsaWFzIG9mIHtAbGluayBzZW5kfS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIHdyaXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gVGhpcyB0eXBlLWNhc3QgaXMgbmVlZGVkIGJlY2F1c2UgRW1pdEV2ZW50cyBsaWtlbHkgZG9lc24ndCBoYXZlIGBtZXNzYWdlYCBhcyBhIGtleS5cbiAgICAgICAgLy8gaWYgeW91IHNwZWNpZnkgdGhlIEVtaXRFdmVudHMsIHRoZSB0eXBlIG9mIGFyZ3Mgd2lsbCBiZSBuZXZlci5cbiAgICAgICAgdGhpcy5zb2NrZXRzLmVtaXQoXCJtZXNzYWdlXCIsIC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBvdGhlciBTb2NrZXQuSU8gc2VydmVycyBvZiB0aGUgY2x1c3Rlci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8uc2VydmVyU2lkZUVtaXQoXCJoZWxsb1wiLCBcIndvcmxkXCIpO1xuICAgICAqXG4gICAgICogaW8ub24oXCJoZWxsb1wiLCAoYXJnMSkgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coYXJnMSk7IC8vIHByaW50cyBcIndvcmxkXCJcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIGFja25vd2xlZGdlbWVudHMgKHdpdGhvdXQgYmluYXJ5IGNvbnRlbnQpIGFyZSBzdXBwb3J0ZWQgdG9vOlxuICAgICAqIGlvLnNlcnZlclNpZGVFbWl0KFwicGluZ1wiLCAoZXJyLCByZXNwb25zZXMpID0+IHtcbiAgICAgKiAgaWYgKGVycikge1xuICAgICAqICAgICAvLyBzb21lIHNlcnZlcnMgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogICB9IGVsc2Uge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXNwb25zZXMpOyAvLyBvbmUgcmVzcG9uc2UgcGVyIHNlcnZlciAoZXhjZXB0IHRoZSBjdXJyZW50IG9uZSlcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGlvLm9uKFwicGluZ1wiLCAoY2IpID0+IHtcbiAgICAgKiAgIGNiKFwicG9uZ1wiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBldiAtIHRoZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIGFyZ3MgLSBhbiBhcnJheSBvZiBhcmd1bWVudHMsIHdoaWNoIG1heSBpbmNsdWRlIGFuIGFja25vd2xlZGdlbWVudCBjYWxsYmFjayBhdCB0aGUgZW5kXG4gICAgICovXG4gICAgc2VydmVyU2lkZUVtaXQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5zZXJ2ZXJTaWRlRW1pdChldiwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSBhbmQgZXhwZWN0IGFuIGFja25vd2xlZGdlbWVudCBmcm9tIHRoZSBvdGhlciBTb2NrZXQuSU8gc2VydmVycyBvZiB0aGUgY2x1c3Rlci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdHJ5IHtcbiAgICAgKiAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IGlvLnNlcnZlclNpZGVFbWl0V2l0aEFjayhcInBpbmdcIik7XG4gICAgICogICBjb25zb2xlLmxvZyhyZXNwb25zZXMpOyAvLyBvbmUgcmVzcG9uc2UgcGVyIHNlcnZlciAoZXhjZXB0IHRoZSBjdXJyZW50IG9uZSlcbiAgICAgKiB9IGNhdGNoIChlKSB7XG4gICAgICogICAvLyBzb21lIHNlcnZlcnMgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogfVxuICAgICAqXG4gICAgICogQHBhcmFtIGV2IC0gdGhlIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0gYXJncyAtIGFuIGFycmF5IG9mIGFyZ3VtZW50c1xuICAgICAqXG4gICAgICogQHJldHVybiBhIFByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIGFsbCBzZXJ2ZXJzIGhhdmUgYWNrbm93bGVkZ2VkIHRoZSBldmVudFxuICAgICAqL1xuICAgIHNlcnZlclNpZGVFbWl0V2l0aEFjayhldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLnNlcnZlclNpZGVFbWl0V2l0aEFjayhldiwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBsaXN0IG9mIHNvY2tldCBpZHMuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCB0aGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZSwgcGxlYXNlIHVzZSB7QGxpbmsgU2VydmVyI3NlcnZlclNpZGVFbWl0fSBvclxuICAgICAqIHtAbGluayBTZXJ2ZXIjZmV0Y2hTb2NrZXRzfSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFsbFNvY2tldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuYWxsU29ja2V0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5jb21wcmVzcyhmYWxzZSkuZW1pdChcImhlbGxvXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIGNvbXByZXNzIC0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgY29tcHJlc3MoY29tcHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5jb21wcmVzcyhjb21wcmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IGRhdGEgbWF5IGJlIGxvc3QgaWYgdGhlIGNsaWVudCBpcyBub3QgcmVhZHkgdG9cbiAgICAgKiByZWNlaXZlIG1lc3NhZ2VzIChiZWNhdXNlIG9mIG5ldHdvcmsgc2xvd25lc3Mgb3Igb3RoZXIgaXNzdWVzLCBvciBiZWNhdXNlIHRoZXnigJlyZSBjb25uZWN0ZWQgdGhyb3VnaCBsb25nIHBvbGxpbmdcbiAgICAgKiBhbmQgaXMgaW4gdGhlIG1pZGRsZSBvZiBhIHJlcXVlc3QtcmVzcG9uc2UgY3ljbGUpLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby52b2xhdGlsZS5lbWl0KFwiaGVsbG9cIik7IC8vIHRoZSBjbGllbnRzIG1heSBvciBtYXkgbm90IHJlY2VpdmUgaXRcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBnZXQgdm9sYXRpbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMudm9sYXRpbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IGRhdGEgd2lsbCBvbmx5IGJlIGJyb2FkY2FzdCB0byB0aGUgY3VycmVudCBub2RlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cyBvbiB0aGlzIG5vZGVcbiAgICAgKiBpby5sb2NhbC5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGdldCBsb2NhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5sb2NhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgbmV4dCBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLnRpbWVvdXQoMTAwMCkuZW1pdChcInNvbWUtZXZlbnRcIiwgKGVyciwgcmVzcG9uc2VzKSA9PiB7XG4gICAgICogICBpZiAoZXJyKSB7XG4gICAgICogICAgIC8vIHNvbWUgY2xpZW50cyBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiAgIH0gZWxzZSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlcyk7IC8vIG9uZSByZXNwb25zZSBwZXIgY2xpZW50XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGltZW91dFxuICAgICAqL1xuICAgIHRpbWVvdXQodGltZW91dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLnRpbWVvdXQodGltZW91dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIHdpdGhpbiBhIGNsdXN0ZXIgb2YgbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBBZGFwdGVyfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gcmV0dXJuIGFsbCBTb2NrZXQgaW5zdGFuY2VzXG4gICAgICogY29uc3Qgc29ja2V0cyA9IGF3YWl0IGlvLmZldGNoU29ja2V0cygpO1xuICAgICAqXG4gICAgICogLy8gcmV0dXJuIGFsbCBTb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbVxuICAgICAqIGNvbnN0IHNvY2tldHMgPSBhd2FpdCBpby5pbihcInJvb20xXCIpLmZldGNoU29ja2V0cygpO1xuICAgICAqXG4gICAgICogZm9yIChjb25zdCBzb2NrZXQgb2Ygc29ja2V0cykge1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmlkKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5oYW5kc2hha2UpO1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LnJvb21zKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5kYXRhKTtcbiAgICAgKlxuICAgICAqICAgc29ja2V0LmVtaXQoXCJoZWxsb1wiKTtcbiAgICAgKiAgIHNvY2tldC5qb2luKFwicm9vbTFcIik7XG4gICAgICogICBzb2NrZXQubGVhdmUoXCJyb29tMlwiKTtcbiAgICAgKiAgIHNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICogfVxuICAgICAqL1xuICAgIGZldGNoU29ja2V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5mZXRjaFNvY2tldHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgam9pbiB0aGUgc3BlY2lmaWVkIHJvb21zLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBqb2luIHRoZSBcInJvb20xXCIgcm9vbVxuICAgICAqIGlvLnNvY2tldHNKb2luKFwicm9vbTFcIik7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbSBqb2luIHRoZSBcInJvb20yXCIgYW5kIFwicm9vbTNcIiByb29tc1xuICAgICAqIGlvLmluKFwicm9vbTFcIikuc29ja2V0c0pvaW4oW1wicm9vbTJcIiwgXCJyb29tM1wiXSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKi9cbiAgICBzb2NrZXRzSm9pbihyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuc29ja2V0c0pvaW4ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGxlYXZlIHRoZSBzcGVjaWZpZWQgcm9vbXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIHdpdGhpbiBhIGNsdXN0ZXIgb2YgbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBBZGFwdGVyfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBsZWF2ZSB0aGUgXCJyb29tMVwiIHJvb21cbiAgICAgKiBpby5zb2NrZXRzTGVhdmUoXCJyb29tMVwiKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tIGxlYXZlIHRoZSBcInJvb20yXCIgYW5kIFwicm9vbTNcIiByb29tc1xuICAgICAqIGlvLmluKFwicm9vbTFcIikuc29ja2V0c0xlYXZlKFtcInJvb20yXCIsIFwicm9vbTNcIl0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICovXG4gICAgc29ja2V0c0xlYXZlKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5zb2NrZXRzTGVhdmUocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGRpc2Nvbm5lY3QuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIHdpdGhpbiBhIGNsdXN0ZXIgb2YgbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBBZGFwdGVyfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBkaXNjb25uZWN0ICh0aGUgY29ubmVjdGlvbnMgbWlnaHQgYmUga2VwdCBhbGl2ZSBmb3Igb3RoZXIgbmFtZXNwYWNlcylcbiAgICAgKiBpby5kaXNjb25uZWN0U29ja2V0cygpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBpbiB0aGUgXCJyb29tMVwiIHJvb20gZGlzY29ubmVjdCBhbmQgY2xvc2UgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbnNcbiAgICAgKiBpby5pbihcInJvb20xXCIpLmRpc2Nvbm5lY3RTb2NrZXRzKHRydWUpO1xuICAgICAqXG4gICAgICogQHBhcmFtIGNsb3NlIC0gd2hldGhlciB0byBjbG9zZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uXG4gICAgICovXG4gICAgZGlzY29ubmVjdFNvY2tldHMoY2xvc2UgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLmRpc2Nvbm5lY3RTb2NrZXRzKGNsb3NlKTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlciA9IFNlcnZlcjtcbi8qKlxuICogRXhwb3NlIG1haW4gbmFtZXNwYWNlICgvKS5cbiAqL1xuY29uc3QgZW1pdHRlck1ldGhvZHMgPSBPYmplY3Qua2V5cyhldmVudHNfMS5FdmVudEVtaXR0ZXIucHJvdG90eXBlKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0eXBlb2YgZXZlbnRzXzEuRXZlbnRFbWl0dGVyLnByb3RvdHlwZVtrZXldID09PSBcImZ1bmN0aW9uXCI7XG59KTtcbmVtaXR0ZXJNZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgU2VydmVyLnByb3RvdHlwZVtmbl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHNbZm5dLmFwcGx5KHRoaXMuc29ja2V0cywgYXJndW1lbnRzKTtcbiAgICB9O1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IChzcnYsIG9wdHMpID0+IG5ldyBTZXJ2ZXIoc3J2LCBvcHRzKTtcbm1vZHVsZS5leHBvcnRzLlNlcnZlciA9IFNlcnZlcjtcbm1vZHVsZS5leHBvcnRzLk5hbWVzcGFjZSA9IG5hbWVzcGFjZV8xLk5hbWVzcGFjZTtcbm1vZHVsZS5leHBvcnRzLlNvY2tldCA9IHNvY2tldF8xLlNvY2tldDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/namespace.js":
/*!**************************************************!*\
  !*** ./node_modules/socket.io/dist/namespace.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Namespace = exports.RESERVED_EVENTS = void 0;\nconst socket_1 = __webpack_require__(/*! ./socket */ \"(rsc)/./node_modules/socket.io/dist/socket.js\");\nconst typed_events_1 = __webpack_require__(/*! ./typed-events */ \"(rsc)/./node_modules/socket.io/dist/typed-events.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst broadcast_operator_1 = __webpack_require__(/*! ./broadcast-operator */ \"(rsc)/./node_modules/socket.io/dist/broadcast-operator.js\");\nconst debug = (0, debug_1.default)(\"socket.io:namespace\");\nexports.RESERVED_EVENTS = new Set([\"connect\", \"connection\", \"new_namespace\"]);\n/**\n * A Namespace is a communication channel that allows you to split the logic of your application over a single shared\n * connection.\n *\n * Each namespace has its own:\n *\n * - event handlers\n *\n * ```\n * io.of(\"/orders\").on(\"connection\", (socket) => {\n *   socket.on(\"order:list\", () => {});\n *   socket.on(\"order:create\", () => {});\n * });\n *\n * io.of(\"/users\").on(\"connection\", (socket) => {\n *   socket.on(\"user:list\", () => {});\n * });\n * ```\n *\n * - rooms\n *\n * ```\n * const orderNamespace = io.of(\"/orders\");\n *\n * orderNamespace.on(\"connection\", (socket) => {\n *   socket.join(\"room1\");\n *   orderNamespace.to(\"room1\").emit(\"hello\");\n * });\n *\n * const userNamespace = io.of(\"/users\");\n *\n * userNamespace.on(\"connection\", (socket) => {\n *   socket.join(\"room1\"); // distinct from the room in the \"orders\" namespace\n *   userNamespace.to(\"room1\").emit(\"holà\");\n * });\n * ```\n *\n * - middlewares\n *\n * ```\n * const orderNamespace = io.of(\"/orders\");\n *\n * orderNamespace.use((socket, next) => {\n *   // ensure the socket has access to the \"orders\" namespace\n * });\n *\n * const userNamespace = io.of(\"/users\");\n *\n * userNamespace.use((socket, next) => {\n *   // ensure the socket has access to the \"users\" namespace\n * });\n * ```\n */\nclass Namespace extends typed_events_1.StrictEventEmitter {\n    /**\n     * Namespace constructor.\n     *\n     * @param server instance\n     * @param name\n     */\n    constructor(server, name) {\n        super();\n        /**\n         * A map of currently connected sockets.\n         */\n        this.sockets = new Map();\n        /**\n         * A map of currently connecting sockets.\n         */\n        this._preConnectSockets = new Map();\n        this._fns = [];\n        /** @private */\n        this._ids = 0;\n        this.server = server;\n        this.name = name;\n        this._initAdapter();\n    }\n    /**\n     * Initializes the `Adapter` for this nsp.\n     * Run upon changing adapter by `Server#adapter`\n     * in addition to the constructor.\n     *\n     * @private\n     */\n    _initAdapter() {\n        // @ts-ignore\n        this.adapter = new (this.server.adapter())(this);\n    }\n    /**\n     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.use((socket, next) => {\n     *   // ...\n     *   next();\n     * });\n     *\n     * @param fn - the middleware function\n     */\n    use(fn) {\n        this._fns.push(fn);\n        return this;\n    }\n    /**\n     * Executes the middleware for an incoming client.\n     *\n     * @param socket - the socket that will get added\n     * @param fn - last fn call in the middleware\n     * @private\n     */\n    run(socket, fn) {\n        if (!this._fns.length)\n            return fn();\n        const fns = this._fns.slice(0);\n        function run(i) {\n            fns[i](socket, (err) => {\n                // upon error, short-circuit\n                if (err)\n                    return fn(err);\n                // if no middleware left, summon callback\n                if (!fns[i + 1])\n                    return fn();\n                // go on to next\n                run(i + 1);\n            });\n        }\n        run(0);\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // the “foo” event will be broadcast to all connected clients in the “room-101” room\n     * myNamespace.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms (a client will be notified at most once)\n     * myNamespace.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * myNamespace.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    to(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).to(room);\n    }\n    /**\n     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // disconnect all clients in the \"room-101\" room\n     * myNamespace.in(\"room-101\").disconnectSockets();\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    in(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).in(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     * myNamespace.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms\n     * myNamespace.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * myNamespace.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    except(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).except(room);\n    }\n    /**\n     * Adds a new client.\n     *\n     * @return {Socket}\n     * @private\n     */\n    async _add(client, auth, fn) {\n        var _a;\n        debug(\"adding socket to nsp %s\", this.name);\n        const socket = await this._createSocket(client, auth);\n        this._preConnectSockets.set(socket.id, socket);\n        if (\n        // @ts-ignore\n        ((_a = this.server.opts.connectionStateRecovery) === null || _a === void 0 ? void 0 : _a.skipMiddlewares) &&\n            socket.recovered &&\n            client.conn.readyState === \"open\") {\n            return this._doConnect(socket, fn);\n        }\n        this.run(socket, (err) => {\n            process.nextTick(() => {\n                if (\"open\" !== client.conn.readyState) {\n                    debug(\"next called after client was closed - ignoring socket\");\n                    socket._cleanup();\n                    return;\n                }\n                if (err) {\n                    debug(\"middleware error, sending CONNECT_ERROR packet to the client\");\n                    socket._cleanup();\n                    if (client.conn.protocol === 3) {\n                        return socket._error(err.data || err.message);\n                    }\n                    else {\n                        return socket._error({\n                            message: err.message,\n                            data: err.data,\n                        });\n                    }\n                }\n                this._doConnect(socket, fn);\n            });\n        });\n    }\n    async _createSocket(client, auth) {\n        const sessionId = auth.pid;\n        const offset = auth.offset;\n        if (\n        // @ts-ignore\n        this.server.opts.connectionStateRecovery &&\n            typeof sessionId === \"string\" &&\n            typeof offset === \"string\") {\n            let session;\n            try {\n                session = await this.adapter.restoreSession(sessionId, offset);\n            }\n            catch (e) {\n                debug(\"error while restoring session: %s\", e);\n            }\n            if (session) {\n                debug(\"connection state recovered for sid %s\", session.sid);\n                return new socket_1.Socket(this, client, auth, session);\n            }\n        }\n        return new socket_1.Socket(this, client, auth);\n    }\n    _doConnect(socket, fn) {\n        this._preConnectSockets.delete(socket.id);\n        this.sockets.set(socket.id, socket);\n        // it's paramount that the internal `onconnect` logic\n        // fires before user-set events to prevent state order\n        // violations (such as a disconnection before the connection\n        // logic is complete)\n        socket._onconnect();\n        if (fn)\n            fn(socket);\n        // fire user-set events\n        this.emitReserved(\"connect\", socket);\n        this.emitReserved(\"connection\", socket);\n    }\n    /**\n     * Removes a client. Called by each `Socket`.\n     *\n     * @private\n     */\n    _remove(socket) {\n        this.sockets.delete(socket.id) || this._preConnectSockets.delete(socket.id);\n    }\n    /**\n     * Emits to all connected clients.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.emit(\"hello\", \"world\");\n     *\n     * // all serializable datastructures are supported (no need to call JSON.stringify)\n     * myNamespace.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n     *\n     * // with an acknowledgement from the clients\n     * myNamespace.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @return Always true\n     */\n    emit(ev, ...args) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).emit(ev, ...args);\n    }\n    /**\n     * Sends a `message` event to all clients.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.send(\"hello\");\n     *\n     * // this is equivalent to\n     * myNamespace.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */\n    send(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a `message` event to all clients. Sends a `message` event. Alias of {@link send}.\n     *\n     * @return self\n     */\n    write(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a message to the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.serverSideEmit(\"hello\", \"world\");\n     *\n     * myNamespace.on(\"hello\", (arg1) => {\n     *   console.log(arg1); // prints \"world\"\n     * });\n     *\n     * // acknowledgements (without binary content) are supported too:\n     * myNamespace.serverSideEmit(\"ping\", (err, responses) => {\n     *  if (err) {\n     *     // some servers did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per server (except the current one)\n     *   }\n     * });\n     *\n     * myNamespace.on(\"ping\", (cb) => {\n     *   cb(\"pong\");\n     * });\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments, which may include an acknowledgement callback at the end\n     */\n    serverSideEmit(ev, ...args) {\n        if (exports.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${String(ev)}\" is a reserved event name`);\n        }\n        args.unshift(ev);\n        this.adapter.serverSideEmit(args);\n        return true;\n    }\n    /**\n     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * try {\n     *   const responses = await myNamespace.serverSideEmitWithAck(\"ping\");\n     *   console.log(responses); // one response per server (except the current one)\n     * } catch (e) {\n     *   // some servers did not acknowledge the event in the given delay\n     * }\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments\n     *\n     * @return a Promise that will be fulfilled when all servers have acknowledged the event\n     */\n    serverSideEmitWithAck(ev, ...args) {\n        return new Promise((resolve, reject) => {\n            args.push((err, responses) => {\n                if (err) {\n                    err.responses = responses;\n                    return reject(err);\n                }\n                else {\n                    return resolve(responses);\n                }\n            });\n            this.serverSideEmit(ev, ...args);\n        });\n    }\n    /**\n     * Called when a packet is received from another Socket.IO server\n     *\n     * @param args - an array of arguments, which may include an acknowledgement callback at the end\n     *\n     * @private\n     */\n    _onServerSideEmit(args) {\n        super.emitUntyped.apply(this, args);\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @deprecated this method will be removed in the next major release, please use {@link Namespace#serverSideEmit} or\n     * {@link Namespace#fetchSockets} instead.\n     */\n    allSockets() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).allSockets();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     */\n    compress(compress) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).compress(compress);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.volatile.emit(\"hello\"); // the clients may or may not receive it\n     *\n     * @return self\n     */\n    get volatile() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).volatile;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // the “foo” event will be broadcast to all connected clients on this node\n     * myNamespace.local.emit(\"foo\", \"bar\");\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    get local() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).local;\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @param timeout\n     */\n    timeout(timeout) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).timeout(timeout);\n    }\n    /**\n     * Returns the matching socket instances.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // return all Socket instances\n     * const sockets = await myNamespace.fetchSockets();\n     *\n     * // return all Socket instances in the \"room1\" room\n     * const sockets = await myNamespace.in(\"room1\").fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   console.log(socket.id);\n     *   console.log(socket.handshake);\n     *   console.log(socket.rooms);\n     *   console.log(socket.data);\n     *\n     *   socket.emit(\"hello\");\n     *   socket.join(\"room1\");\n     *   socket.leave(\"room2\");\n     *   socket.disconnect();\n     * }\n     */\n    fetchSockets() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).fetchSockets();\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // make all socket instances join the \"room1\" room\n     * myNamespace.socketsJoin(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room join the \"room2\" and \"room3\" rooms\n     * myNamespace.in(\"room1\").socketsJoin([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */\n    socketsJoin(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsJoin(room);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // make all socket instances leave the \"room1\" room\n     * myNamespace.socketsLeave(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room leave the \"room2\" and \"room3\" rooms\n     * myNamespace.in(\"room1\").socketsLeave([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */\n    socketsLeave(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsLeave(room);\n    }\n    /**\n     * Makes the matching socket instances disconnect.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)\n     * myNamespace.disconnectSockets();\n     *\n     * // make all socket instances in the \"room1\" room disconnect and close the underlying connections\n     * myNamespace.in(\"room1\").disconnectSockets(true);\n     *\n     * @param close - whether to close the underlying connection\n     */\n    disconnectSockets(close = false) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).disconnectSockets(close);\n    }\n}\nexports.Namespace = Namespace;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvbmFtZXNwYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsdUJBQXVCO0FBQzNDLGlCQUFpQixtQkFBTyxDQUFDLCtEQUFVO0FBQ25DLHVCQUF1QixtQkFBTyxDQUFDLDJFQUFnQjtBQUMvQyxnQ0FBZ0MsbUJBQU8sQ0FBQyw2RUFBTztBQUMvQyw2QkFBNkIsbUJBQU8sQ0FBQyx1RkFBc0I7QUFDM0Q7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsdUNBQXVDO0FBQ3ZDLElBQUk7QUFDSjtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG1DQUFtQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLG1DQUFtQztBQUNuQztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsV0FBVztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsbUNBQW1DO0FBQ25DO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsZ0NBQWdDO0FBQ3RILFFBQVEsOEJBQThCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxtQ0FBbUM7QUFDbkM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHLGNBQWM7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsY0FBYztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsY0FBYztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsY0FBYztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcnNvbGUvRG9jdW1lbnRzL0dpdEh1Yi9tYXNzaW1pbm8vbWFzc2ltaW5vL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9uYW1lc3BhY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5hbWVzcGFjZSA9IGV4cG9ydHMuUkVTRVJWRURfRVZFTlRTID0gdm9pZCAwO1xuY29uc3Qgc29ja2V0XzEgPSByZXF1aXJlKFwiLi9zb2NrZXRcIik7XG5jb25zdCB0eXBlZF9ldmVudHNfMSA9IHJlcXVpcmUoXCIuL3R5cGVkLWV2ZW50c1wiKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGJyb2FkY2FzdF9vcGVyYXRvcl8xID0gcmVxdWlyZShcIi4vYnJvYWRjYXN0LW9wZXJhdG9yXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcInNvY2tldC5pbzpuYW1lc3BhY2VcIik7XG5leHBvcnRzLlJFU0VSVkVEX0VWRU5UUyA9IG5ldyBTZXQoW1wiY29ubmVjdFwiLCBcImNvbm5lY3Rpb25cIiwgXCJuZXdfbmFtZXNwYWNlXCJdKTtcbi8qKlxuICogQSBOYW1lc3BhY2UgaXMgYSBjb21tdW5pY2F0aW9uIGNoYW5uZWwgdGhhdCBhbGxvd3MgeW91IHRvIHNwbGl0IHRoZSBsb2dpYyBvZiB5b3VyIGFwcGxpY2F0aW9uIG92ZXIgYSBzaW5nbGUgc2hhcmVkXG4gKiBjb25uZWN0aW9uLlxuICpcbiAqIEVhY2ggbmFtZXNwYWNlIGhhcyBpdHMgb3duOlxuICpcbiAqIC0gZXZlbnQgaGFuZGxlcnNcbiAqXG4gKiBgYGBcbiAqIGlvLm9mKFwiL29yZGVyc1wiKS5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICogICBzb2NrZXQub24oXCJvcmRlcjpsaXN0XCIsICgpID0+IHt9KTtcbiAqICAgc29ja2V0Lm9uKFwib3JkZXI6Y3JlYXRlXCIsICgpID0+IHt9KTtcbiAqIH0pO1xuICpcbiAqIGlvLm9mKFwiL3VzZXJzXCIpLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gKiAgIHNvY2tldC5vbihcInVzZXI6bGlzdFwiLCAoKSA9PiB7fSk7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIC0gcm9vbXNcbiAqXG4gKiBgYGBcbiAqIGNvbnN0IG9yZGVyTmFtZXNwYWNlID0gaW8ub2YoXCIvb3JkZXJzXCIpO1xuICpcbiAqIG9yZGVyTmFtZXNwYWNlLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gKiAgIHNvY2tldC5qb2luKFwicm9vbTFcIik7XG4gKiAgIG9yZGVyTmFtZXNwYWNlLnRvKFwicm9vbTFcIikuZW1pdChcImhlbGxvXCIpO1xuICogfSk7XG4gKlxuICogY29uc3QgdXNlck5hbWVzcGFjZSA9IGlvLm9mKFwiL3VzZXJzXCIpO1xuICpcbiAqIHVzZXJOYW1lc3BhY2Uub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAqICAgc29ja2V0LmpvaW4oXCJyb29tMVwiKTsgLy8gZGlzdGluY3QgZnJvbSB0aGUgcm9vbSBpbiB0aGUgXCJvcmRlcnNcIiBuYW1lc3BhY2VcbiAqICAgdXNlck5hbWVzcGFjZS50byhcInJvb20xXCIpLmVtaXQoXCJob2zDoFwiKTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogLSBtaWRkbGV3YXJlc1xuICpcbiAqIGBgYFxuICogY29uc3Qgb3JkZXJOYW1lc3BhY2UgPSBpby5vZihcIi9vcmRlcnNcIik7XG4gKlxuICogb3JkZXJOYW1lc3BhY2UudXNlKChzb2NrZXQsIG5leHQpID0+IHtcbiAqICAgLy8gZW5zdXJlIHRoZSBzb2NrZXQgaGFzIGFjY2VzcyB0byB0aGUgXCJvcmRlcnNcIiBuYW1lc3BhY2VcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHVzZXJOYW1lc3BhY2UgPSBpby5vZihcIi91c2Vyc1wiKTtcbiAqXG4gKiB1c2VyTmFtZXNwYWNlLnVzZSgoc29ja2V0LCBuZXh0KSA9PiB7XG4gKiAgIC8vIGVuc3VyZSB0aGUgc29ja2V0IGhhcyBhY2Nlc3MgdG8gdGhlIFwidXNlcnNcIiBuYW1lc3BhY2VcbiAqIH0pO1xuICogYGBgXG4gKi9cbmNsYXNzIE5hbWVzcGFjZSBleHRlbmRzIHR5cGVkX2V2ZW50c18xLlN0cmljdEV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogTmFtZXNwYWNlIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlcnZlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2VydmVyLCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBvZiBjdXJyZW50bHkgY29ubmVjdGVkIHNvY2tldHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNvY2tldHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBvZiBjdXJyZW50bHkgY29ubmVjdGluZyBzb2NrZXRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcHJlQ29ubmVjdFNvY2tldHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2ZucyA9IFtdO1xuICAgICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgICAgdGhpcy5faWRzID0gMDtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX2luaXRBZGFwdGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBgQWRhcHRlcmAgZm9yIHRoaXMgbnNwLlxuICAgICAqIFJ1biB1cG9uIGNoYW5naW5nIGFkYXB0ZXIgYnkgYFNlcnZlciNhZGFwdGVyYFxuICAgICAqIGluIGFkZGl0aW9uIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRBZGFwdGVyKCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuYWRhcHRlciA9IG5ldyAodGhpcy5zZXJ2ZXIuYWRhcHRlcigpKSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgbWlkZGxld2FyZSwgd2hpY2ggaXMgYSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgZm9yIGV2ZXJ5IGluY29taW5nIHtAbGluayBTb2NrZXR9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIG15TmFtZXNwYWNlLnVzZSgoc29ja2V0LCBuZXh0KSA9PiB7XG4gICAgICogICAvLyAuLi5cbiAgICAgKiAgIG5leHQoKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiAtIHRoZSBtaWRkbGV3YXJlIGZ1bmN0aW9uXG4gICAgICovXG4gICAgdXNlKGZuKSB7XG4gICAgICAgIHRoaXMuX2Zucy5wdXNoKGZuKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBtaWRkbGV3YXJlIGZvciBhbiBpbmNvbWluZyBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc29ja2V0IC0gdGhlIHNvY2tldCB0aGF0IHdpbGwgZ2V0IGFkZGVkXG4gICAgICogQHBhcmFtIGZuIC0gbGFzdCBmbiBjYWxsIGluIHRoZSBtaWRkbGV3YXJlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBydW4oc29ja2V0LCBmbikge1xuICAgICAgICBpZiAoIXRoaXMuX2Zucy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgY29uc3QgZm5zID0gdGhpcy5fZm5zLnNsaWNlKDApO1xuICAgICAgICBmdW5jdGlvbiBydW4oaSkge1xuICAgICAgICAgICAgZm5zW2ldKHNvY2tldCwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHVwb24gZXJyb3IsIHNob3J0LWNpcmN1aXRcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oZXJyKTtcbiAgICAgICAgICAgICAgICAvLyBpZiBubyBtaWRkbGV3YXJlIGxlZnQsIHN1bW1vbiBjYWxsYmFja1xuICAgICAgICAgICAgICAgIGlmICghZm5zW2kgKyAxXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgICAgICAgICAgLy8gZ28gb24gdG8gbmV4dFxuICAgICAgICAgICAgICAgIHJ1bihpICsgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBydW4oMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gZW1pdHRpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogLy8gdGhlIOKAnGZvb+KAnSBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMgaW4gdGhlIOKAnHJvb20tMTAx4oCdIHJvb21cbiAgICAgKiBteU5hbWVzcGFjZS50byhcInJvb20tMTAxXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGFuIGFycmF5IG9mIHJvb21zIChhIGNsaWVudCB3aWxsIGJlIG5vdGlmaWVkIGF0IG1vc3Qgb25jZSlcbiAgICAgKiBteU5hbWVzcGFjZS50byhbXCJyb29tLTEwMVwiLCBcInJvb20tMTAyXCJdKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBtdWx0aXBsZSBjaGFpbmVkIGNhbGxzXG4gICAgICogbXlOYW1lc3BhY2UudG8oXCJyb29tLTEwMVwiKS50byhcInJvb20tMTAyXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgdG8ocm9vbSkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikudG8ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gZW1pdHRpbmcuIFNpbWlsYXIgdG8gYHRvKClgLCBidXQgbWlnaHQgZmVlbCBjbGVhcmVyIGluIHNvbWUgY2FzZXM6XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogLy8gZGlzY29ubmVjdCBhbGwgY2xpZW50cyBpbiB0aGUgXCJyb29tLTEwMVwiIHJvb21cbiAgICAgKiBteU5hbWVzcGFjZS5pbihcInJvb20tMTAxXCIpLmRpc2Nvbm5lY3RTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgaW4ocm9vbSkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikuaW4ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4Y2x1ZGVzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIC8vIHRoZSBcImZvb1wiIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cywgZXhjZXB0IHRoZSBvbmVzIHRoYXQgYXJlIGluIHRoZSBcInJvb20tMTAxXCIgcm9vbVxuICAgICAqIG15TmFtZXNwYWNlLmV4Y2VwdChcInJvb20tMTAxXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogbXlOYW1lc3BhY2UuZXhjZXB0KFtcInJvb20tMTAxXCIsIFwicm9vbS0xMDJcIl0pLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIG11bHRpcGxlIGNoYWluZWQgY2FsbHNcbiAgICAgKiBteU5hbWVzcGFjZS5leGNlcHQoXCJyb29tLTEwMVwiKS5leGNlcHQoXCJyb29tLTEwMlwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGV4Y2VwdChyb29tKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5leGNlcHQocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgY2xpZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7U29ja2V0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgX2FkZChjbGllbnQsIGF1dGgsIGZuKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZGVidWcoXCJhZGRpbmcgc29ja2V0IHRvIG5zcCAlc1wiLCB0aGlzLm5hbWUpO1xuICAgICAgICBjb25zdCBzb2NrZXQgPSBhd2FpdCB0aGlzLl9jcmVhdGVTb2NrZXQoY2xpZW50LCBhdXRoKTtcbiAgICAgICAgdGhpcy5fcHJlQ29ubmVjdFNvY2tldHMuc2V0KHNvY2tldC5pZCwgc29ja2V0KTtcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICgoX2EgPSB0aGlzLnNlcnZlci5vcHRzLmNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2tpcE1pZGRsZXdhcmVzKSAmJlxuICAgICAgICAgICAgc29ja2V0LnJlY292ZXJlZCAmJlxuICAgICAgICAgICAgY2xpZW50LmNvbm4ucmVhZHlTdGF0ZSA9PT0gXCJvcGVuXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kb0Nvbm5lY3Qoc29ja2V0LCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ydW4oc29ja2V0LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXCJvcGVuXCIgIT09IGNsaWVudC5jb25uLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJuZXh0IGNhbGxlZCBhZnRlciBjbGllbnQgd2FzIGNsb3NlZCAtIGlnbm9yaW5nIHNvY2tldFwiKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Ll9jbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcIm1pZGRsZXdhcmUgZXJyb3IsIHNlbmRpbmcgQ09OTkVDVF9FUlJPUiBwYWNrZXQgdG8gdGhlIGNsaWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Ll9jbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGllbnQuY29ubi5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldC5fZXJyb3IoZXJyLmRhdGEgfHwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldC5fZXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGVyci5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9Db25uZWN0KHNvY2tldCwgZm4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfY3JlYXRlU29ja2V0KGNsaWVudCwgYXV0aCkge1xuICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSBhdXRoLnBpZDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gYXV0aC5vZmZzZXQ7XG4gICAgICAgIGlmIChcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLnNlcnZlci5vcHRzLmNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5ICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2Vzc2lvbklkID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2Zmc2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsZXQgc2Vzc2lvbjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbiA9IGF3YWl0IHRoaXMuYWRhcHRlci5yZXN0b3JlU2Vzc2lvbihzZXNzaW9uSWQsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiZXJyb3Igd2hpbGUgcmVzdG9yaW5nIHNlc3Npb246ICVzXCIsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gc3RhdGUgcmVjb3ZlcmVkIGZvciBzaWQgJXNcIiwgc2Vzc2lvbi5zaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc29ja2V0XzEuU29ja2V0KHRoaXMsIGNsaWVudCwgYXV0aCwgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBzb2NrZXRfMS5Tb2NrZXQodGhpcywgY2xpZW50LCBhdXRoKTtcbiAgICB9XG4gICAgX2RvQ29ubmVjdChzb2NrZXQsIGZuKSB7XG4gICAgICAgIHRoaXMuX3ByZUNvbm5lY3RTb2NrZXRzLmRlbGV0ZShzb2NrZXQuaWQpO1xuICAgICAgICB0aGlzLnNvY2tldHMuc2V0KHNvY2tldC5pZCwgc29ja2V0KTtcbiAgICAgICAgLy8gaXQncyBwYXJhbW91bnQgdGhhdCB0aGUgaW50ZXJuYWwgYG9uY29ubmVjdGAgbG9naWNcbiAgICAgICAgLy8gZmlyZXMgYmVmb3JlIHVzZXItc2V0IGV2ZW50cyB0byBwcmV2ZW50IHN0YXRlIG9yZGVyXG4gICAgICAgIC8vIHZpb2xhdGlvbnMgKHN1Y2ggYXMgYSBkaXNjb25uZWN0aW9uIGJlZm9yZSB0aGUgY29ubmVjdGlvblxuICAgICAgICAvLyBsb2dpYyBpcyBjb21wbGV0ZSlcbiAgICAgICAgc29ja2V0Ll9vbmNvbm5lY3QoKTtcbiAgICAgICAgaWYgKGZuKVxuICAgICAgICAgICAgZm4oc29ja2V0KTtcbiAgICAgICAgLy8gZmlyZSB1c2VyLXNldCBldmVudHNcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJjb25uZWN0XCIsIHNvY2tldCk7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiY29ubmVjdGlvblwiLCBzb2NrZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY2xpZW50LiBDYWxsZWQgYnkgZWFjaCBgU29ja2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZShzb2NrZXQpIHtcbiAgICAgICAgdGhpcy5zb2NrZXRzLmRlbGV0ZShzb2NrZXQuaWQpIHx8IHRoaXMuX3ByZUNvbm5lY3RTb2NrZXRzLmRlbGV0ZShzb2NrZXQuaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogbXlOYW1lc3BhY2UuZW1pdChcImhlbGxvXCIsIFwid29ybGRcIik7XG4gICAgICpcbiAgICAgKiAvLyBhbGwgc2VyaWFsaXphYmxlIGRhdGFzdHJ1Y3R1cmVzIGFyZSBzdXBwb3J0ZWQgKG5vIG5lZWQgdG8gY2FsbCBKU09OLnN0cmluZ2lmeSlcbiAgICAgKiBteU5hbWVzcGFjZS5lbWl0KFwiaGVsbG9cIiwgMSwgXCIyXCIsIHsgMzogW1wiNFwiXSwgNTogVWludDhBcnJheS5mcm9tKFs2XSkgfSk7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGFuIGFja25vd2xlZGdlbWVudCBmcm9tIHRoZSBjbGllbnRzXG4gICAgICogbXlOYW1lc3BhY2UudGltZW91dCgxMDAwKS5lbWl0KFwic29tZS1ldmVudFwiLCAoZXJyLCByZXNwb25zZXMpID0+IHtcbiAgICAgKiAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgLy8gc29tZSBjbGllbnRzIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgfSBlbHNlIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzcG9uc2VzKTsgLy8gb25lIHJlc3BvbnNlIHBlciBjbGllbnRcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gQWx3YXlzIHRydWVcbiAgICAgKi9cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQgdG8gYWxsIGNsaWVudHMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtaW1pY3MgdGhlIFdlYlNvY2tldC5zZW5kKCkgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViU29ja2V0L3NlbmRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiBteU5hbWVzcGFjZS5zZW5kKFwiaGVsbG9cIik7XG4gICAgICpcbiAgICAgKiAvLyB0aGlzIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgKiBteU5hbWVzcGFjZS5lbWl0KFwibWVzc2FnZVwiLCBcImhlbGxvXCIpO1xuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgc2VuZCguLi5hcmdzKSB7XG4gICAgICAgIC8vIFRoaXMgdHlwZS1jYXN0IGlzIG5lZWRlZCBiZWNhdXNlIEVtaXRFdmVudHMgbGlrZWx5IGRvZXNuJ3QgaGF2ZSBgbWVzc2FnZWAgYXMgYSBrZXkuXG4gICAgICAgIC8vIGlmIHlvdSBzcGVjaWZ5IHRoZSBFbWl0RXZlbnRzLCB0aGUgdHlwZSBvZiBhcmdzIHdpbGwgYmUgbmV2ZXIuXG4gICAgICAgIHRoaXMuZW1pdChcIm1lc3NhZ2VcIiwgLi4uYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudCB0byBhbGwgY2xpZW50cy4gU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuIEFsaWFzIG9mIHtAbGluayBzZW5kfS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIHdyaXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gVGhpcyB0eXBlLWNhc3QgaXMgbmVlZGVkIGJlY2F1c2UgRW1pdEV2ZW50cyBsaWtlbHkgZG9lc24ndCBoYXZlIGBtZXNzYWdlYCBhcyBhIGtleS5cbiAgICAgICAgLy8gaWYgeW91IHNwZWNpZnkgdGhlIEVtaXRFdmVudHMsIHRoZSB0eXBlIG9mIGFyZ3Mgd2lsbCBiZSBuZXZlci5cbiAgICAgICAgdGhpcy5lbWl0KFwibWVzc2FnZVwiLCAuLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgb3RoZXIgU29ja2V0LklPIHNlcnZlcnMgb2YgdGhlIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogbXlOYW1lc3BhY2Uuc2VydmVyU2lkZUVtaXQoXCJoZWxsb1wiLCBcIndvcmxkXCIpO1xuICAgICAqXG4gICAgICogbXlOYW1lc3BhY2Uub24oXCJoZWxsb1wiLCAoYXJnMSkgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coYXJnMSk7IC8vIHByaW50cyBcIndvcmxkXCJcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIGFja25vd2xlZGdlbWVudHMgKHdpdGhvdXQgYmluYXJ5IGNvbnRlbnQpIGFyZSBzdXBwb3J0ZWQgdG9vOlxuICAgICAqIG15TmFtZXNwYWNlLnNlcnZlclNpZGVFbWl0KFwicGluZ1wiLCAoZXJyLCByZXNwb25zZXMpID0+IHtcbiAgICAgKiAgaWYgKGVycikge1xuICAgICAqICAgICAvLyBzb21lIHNlcnZlcnMgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogICB9IGVsc2Uge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXNwb25zZXMpOyAvLyBvbmUgcmVzcG9uc2UgcGVyIHNlcnZlciAoZXhjZXB0IHRoZSBjdXJyZW50IG9uZSlcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIG15TmFtZXNwYWNlLm9uKFwicGluZ1wiLCAoY2IpID0+IHtcbiAgICAgKiAgIGNiKFwicG9uZ1wiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBldiAtIHRoZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIGFyZ3MgLSBhbiBhcnJheSBvZiBhcmd1bWVudHMsIHdoaWNoIG1heSBpbmNsdWRlIGFuIGFja25vd2xlZGdlbWVudCBjYWxsYmFjayBhdCB0aGUgZW5kXG4gICAgICovXG4gICAgc2VydmVyU2lkZUVtaXQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGV4cG9ydHMuUkVTRVJWRURfRVZFTlRTLmhhcyhldikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke1N0cmluZyhldil9XCIgaXMgYSByZXNlcnZlZCBldmVudCBuYW1lYCk7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy51bnNoaWZ0KGV2KTtcbiAgICAgICAgdGhpcy5hZGFwdGVyLnNlcnZlclNpZGVFbWl0KGFyZ3MpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIGFuZCBleHBlY3QgYW4gYWNrbm93bGVkZ2VtZW50IGZyb20gdGhlIG90aGVyIFNvY2tldC5JTyBzZXJ2ZXJzIG9mIHRoZSBjbHVzdGVyLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIHRyeSB7XG4gICAgICogICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBteU5hbWVzcGFjZS5zZXJ2ZXJTaWRlRW1pdFdpdGhBY2soXCJwaW5nXCIpO1xuICAgICAqICAgY29uc29sZS5sb2cocmVzcG9uc2VzKTsgLy8gb25lIHJlc3BvbnNlIHBlciBzZXJ2ZXIgKGV4Y2VwdCB0aGUgY3VycmVudCBvbmUpXG4gICAgICogfSBjYXRjaCAoZSkge1xuICAgICAqICAgLy8gc29tZSBzZXJ2ZXJzIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldiAtIHRoZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIGFyZ3MgLSBhbiBhcnJheSBvZiBhcmd1bWVudHNcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiBhbGwgc2VydmVycyBoYXZlIGFja25vd2xlZGdlZCB0aGUgZXZlbnRcbiAgICAgKi9cbiAgICBzZXJ2ZXJTaWRlRW1pdFdpdGhBY2soZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGFyZ3MucHVzaCgoZXJyLCByZXNwb25zZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyci5yZXNwb25zZXMgPSByZXNwb25zZXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3BvbnNlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNlcnZlclNpZGVFbWl0KGV2LCAuLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgcGFja2V0IGlzIHJlY2VpdmVkIGZyb20gYW5vdGhlciBTb2NrZXQuSU8gc2VydmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIGFuIGFycmF5IG9mIGFyZ3VtZW50cywgd2hpY2ggbWF5IGluY2x1ZGUgYW4gYWNrbm93bGVkZ2VtZW50IGNhbGxiYWNrIGF0IHRoZSBlbmRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uU2VydmVyU2lkZUVtaXQoYXJncykge1xuICAgICAgICBzdXBlci5lbWl0VW50eXBlZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2YgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIHRoaXMgbWV0aG9kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLCBwbGVhc2UgdXNlIHtAbGluayBOYW1lc3BhY2Ujc2VydmVyU2lkZUVtaXR9IG9yXG4gICAgICoge0BsaW5rIE5hbWVzcGFjZSNmZXRjaFNvY2tldHN9IGluc3RlYWQuXG4gICAgICovXG4gICAgYWxsU29ja2V0cygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLmFsbFNvY2tldHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29tcHJlc3MgZmxhZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiBteU5hbWVzcGFjZS5jb21wcmVzcyhmYWxzZSkuZW1pdChcImhlbGxvXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIGNvbXByZXNzIC0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBjb21wcmVzcyhjb21wcmVzcykge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikuY29tcHJlc3MoY29tcHJlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIG1heSBiZSBsb3N0IGlmIHRoZSBjbGllbnQgaXMgbm90IHJlYWR5IHRvXG4gICAgICogcmVjZWl2ZSBtZXNzYWdlcyAoYmVjYXVzZSBvZiBuZXR3b3JrIHNsb3duZXNzIG9yIG90aGVyIGlzc3Vlcywgb3IgYmVjYXVzZSB0aGV54oCZcmUgY29ubmVjdGVkIHRocm91Z2ggbG9uZyBwb2xsaW5nXG4gICAgICogYW5kIGlzIGluIHRoZSBtaWRkbGUgb2YgYSByZXF1ZXN0LXJlc3BvbnNlIGN5Y2xlKS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiBteU5hbWVzcGFjZS52b2xhdGlsZS5lbWl0KFwiaGVsbG9cIik7IC8vIHRoZSBjbGllbnRzIG1heSBvciBtYXkgbm90IHJlY2VpdmUgaXRcbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIGdldCB2b2xhdGlsZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLnZvbGF0aWxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIHdpbGwgb25seSBiZSBicm9hZGNhc3QgdG8gdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cyBvbiB0aGlzIG5vZGVcbiAgICAgKiBteU5hbWVzcGFjZS5sb2NhbC5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGdldCBsb2NhbCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLmxvY2FsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSBuZXh0IG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiBteU5hbWVzcGFjZS50aW1lb3V0KDEwMDApLmVtaXQoXCJzb21lLWV2ZW50XCIsIChlcnIsIHJlc3BvbnNlcykgPT4ge1xuICAgICAqICAgaWYgKGVycikge1xuICAgICAqICAgICAvLyBzb21lIGNsaWVudHMgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogICB9IGVsc2Uge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXNwb25zZXMpOyAvLyBvbmUgcmVzcG9uc2UgcGVyIGNsaWVudFxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHRpbWVvdXRcbiAgICAgKi9cbiAgICB0aW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLnRpbWVvdXQodGltZW91dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIHdpdGhpbiBhIGNsdXN0ZXIgb2YgbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBBZGFwdGVyfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm4gYWxsIFNvY2tldCBpbnN0YW5jZXNcbiAgICAgKiBjb25zdCBzb2NrZXRzID0gYXdhaXQgbXlOYW1lc3BhY2UuZmV0Y2hTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm4gYWxsIFNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tXG4gICAgICogY29uc3Qgc29ja2V0cyA9IGF3YWl0IG15TmFtZXNwYWNlLmluKFwicm9vbTFcIikuZmV0Y2hTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiBmb3IgKGNvbnN0IHNvY2tldCBvZiBzb2NrZXRzKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuaWQpO1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmhhbmRzaGFrZSk7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQucm9vbXMpO1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmRhdGEpO1xuICAgICAqXG4gICAgICogICBzb2NrZXQuZW1pdChcImhlbGxvXCIpO1xuICAgICAqICAgc29ja2V0LmpvaW4oXCJyb29tMVwiKTtcbiAgICAgKiAgIHNvY2tldC5sZWF2ZShcInJvb20yXCIpO1xuICAgICAqICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgZmV0Y2hTb2NrZXRzKCkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikuZmV0Y2hTb2NrZXRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGpvaW4gdGhlIHNwZWNpZmllZCByb29tcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgam9pbiB0aGUgXCJyb29tMVwiIHJvb21cbiAgICAgKiBteU5hbWVzcGFjZS5zb2NrZXRzSm9pbihcInJvb20xXCIpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBpbiB0aGUgXCJyb29tMVwiIHJvb20gam9pbiB0aGUgXCJyb29tMlwiIGFuZCBcInJvb20zXCIgcm9vbXNcbiAgICAgKiBteU5hbWVzcGFjZS5pbihcInJvb20xXCIpLnNvY2tldHNKb2luKFtcInJvb20yXCIsIFwicm9vbTNcIl0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICovXG4gICAgc29ja2V0c0pvaW4ocm9vbSkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikuc29ja2V0c0pvaW4ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGxlYXZlIHRoZSBzcGVjaWZpZWQgcm9vbXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIHdpdGhpbiBhIGNsdXN0ZXIgb2YgbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBBZGFwdGVyfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGxlYXZlIHRoZSBcInJvb20xXCIgcm9vbVxuICAgICAqIG15TmFtZXNwYWNlLnNvY2tldHNMZWF2ZShcInJvb20xXCIpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBpbiB0aGUgXCJyb29tMVwiIHJvb20gbGVhdmUgdGhlIFwicm9vbTJcIiBhbmQgXCJyb29tM1wiIHJvb21zXG4gICAgICogbXlOYW1lc3BhY2UuaW4oXCJyb29tMVwiKS5zb2NrZXRzTGVhdmUoW1wicm9vbTJcIiwgXCJyb29tM1wiXSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKi9cbiAgICBzb2NrZXRzTGVhdmUocm9vbSkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikuc29ja2V0c0xlYXZlKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBkaXNjb25uZWN0LlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBkaXNjb25uZWN0ICh0aGUgY29ubmVjdGlvbnMgbWlnaHQgYmUga2VwdCBhbGl2ZSBmb3Igb3RoZXIgbmFtZXNwYWNlcylcbiAgICAgKiBteU5hbWVzcGFjZS5kaXNjb25uZWN0U29ja2V0cygpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBpbiB0aGUgXCJyb29tMVwiIHJvb20gZGlzY29ubmVjdCBhbmQgY2xvc2UgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbnNcbiAgICAgKiBteU5hbWVzcGFjZS5pbihcInJvb20xXCIpLmRpc2Nvbm5lY3RTb2NrZXRzKHRydWUpO1xuICAgICAqXG4gICAgICogQHBhcmFtIGNsb3NlIC0gd2hldGhlciB0byBjbG9zZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uXG4gICAgICovXG4gICAgZGlzY29ubmVjdFNvY2tldHMoY2xvc2UgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikuZGlzY29ubmVjdFNvY2tldHMoY2xvc2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuTmFtZXNwYWNlID0gTmFtZXNwYWNlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/namespace.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/parent-namespace.js":
/*!*********************************************************!*\
  !*** ./node_modules/socket.io/dist/parent-namespace.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ParentNamespace = void 0;\nconst namespace_1 = __webpack_require__(/*! ./namespace */ \"(rsc)/./node_modules/socket.io/dist/namespace.js\");\nconst socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/index.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst debug = (0, debug_1.default)(\"socket.io:parent-namespace\");\n/**\n * A parent namespace is a special {@link Namespace} that holds a list of child namespaces which were created either\n * with a regular expression or with a function.\n *\n * @example\n * const parentNamespace = io.of(/\\/dynamic-\\d+/);\n *\n * parentNamespace.on(\"connection\", (socket) => {\n *   const childNamespace = socket.nsp;\n * }\n *\n * // will reach all the clients that are in one of the child namespaces, like \"/dynamic-101\"\n * parentNamespace.emit(\"hello\", \"world\");\n *\n */\nclass ParentNamespace extends namespace_1.Namespace {\n    constructor(server) {\n        super(server, \"/_\" + ParentNamespace.count++);\n        this.children = new Set();\n    }\n    /**\n     * @private\n     */\n    _initAdapter() {\n        this.adapter = new ParentBroadcastAdapter(this);\n    }\n    emit(ev, ...args) {\n        this.children.forEach((nsp) => {\n            nsp.emit(ev, ...args);\n        });\n        return true;\n    }\n    createChild(name) {\n        debug(\"creating child namespace %s\", name);\n        const namespace = new namespace_1.Namespace(this.server, name);\n        this[\"_fns\"].forEach((fn) => namespace.use(fn));\n        this.listeners(\"connect\").forEach((listener) => namespace.on(\"connect\", listener));\n        this.listeners(\"connection\").forEach((listener) => namespace.on(\"connection\", listener));\n        this.children.add(namespace);\n        if (this.server._opts.cleanupEmptyChildNamespaces) {\n            const remove = namespace._remove;\n            namespace._remove = (socket) => {\n                remove.call(namespace, socket);\n                if (namespace.sockets.size === 0) {\n                    debug(\"closing child namespace %s\", name);\n                    namespace.adapter.close();\n                    this.server._nsps.delete(namespace.name);\n                    this.children.delete(namespace);\n                }\n            };\n        }\n        this.server._nsps.set(name, namespace);\n        // @ts-ignore\n        this.server.sockets.emitReserved(\"new_namespace\", namespace);\n        return namespace;\n    }\n    fetchSockets() {\n        // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\n        // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\n        // the behavior for namespaces created with a function is less clear\n        // note²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\n        // may exist on one node but not exist on another (since it is created upon client connection)\n        throw new Error(\"fetchSockets() is not supported on parent namespaces\");\n    }\n}\nexports.ParentNamespace = ParentNamespace;\nParentNamespace.count = 0;\n/**\n * A dummy adapter that only supports broadcasting to child (concrete) namespaces.\n * @private file\n */\nclass ParentBroadcastAdapter extends socket_io_adapter_1.Adapter {\n    broadcast(packet, opts) {\n        this.nsp.children.forEach((nsp) => {\n            nsp.adapter.broadcast(packet, opts);\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvcGFyZW50LW5hbWVzcGFjZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QixvQkFBb0IsbUJBQU8sQ0FBQyxxRUFBYTtBQUN6Qyw0QkFBNEIsbUJBQU8sQ0FBQywrRUFBbUI7QUFDdkQsZ0NBQWdDLG1CQUFPLENBQUMsNkVBQU87QUFDL0M7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3Jzb2xlL0RvY3VtZW50cy9HaXRIdWIvbWFzc2ltaW5vL21hc3NpbWluby9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvcGFyZW50LW5hbWVzcGFjZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFyZW50TmFtZXNwYWNlID0gdm9pZCAwO1xuY29uc3QgbmFtZXNwYWNlXzEgPSByZXF1aXJlKFwiLi9uYW1lc3BhY2VcIik7XG5jb25zdCBzb2NrZXRfaW9fYWRhcHRlcl8xID0gcmVxdWlyZShcInNvY2tldC5pby1hZGFwdGVyXCIpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcInNvY2tldC5pbzpwYXJlbnQtbmFtZXNwYWNlXCIpO1xuLyoqXG4gKiBBIHBhcmVudCBuYW1lc3BhY2UgaXMgYSBzcGVjaWFsIHtAbGluayBOYW1lc3BhY2V9IHRoYXQgaG9sZHMgYSBsaXN0IG9mIGNoaWxkIG5hbWVzcGFjZXMgd2hpY2ggd2VyZSBjcmVhdGVkIGVpdGhlclxuICogd2l0aCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciB3aXRoIGEgZnVuY3Rpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHBhcmVudE5hbWVzcGFjZSA9IGlvLm9mKC9cXC9keW5hbWljLVxcZCsvKTtcbiAqXG4gKiBwYXJlbnROYW1lc3BhY2Uub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAqICAgY29uc3QgY2hpbGROYW1lc3BhY2UgPSBzb2NrZXQubnNwO1xuICogfVxuICpcbiAqIC8vIHdpbGwgcmVhY2ggYWxsIHRoZSBjbGllbnRzIHRoYXQgYXJlIGluIG9uZSBvZiB0aGUgY2hpbGQgbmFtZXNwYWNlcywgbGlrZSBcIi9keW5hbWljLTEwMVwiXG4gKiBwYXJlbnROYW1lc3BhY2UuZW1pdChcImhlbGxvXCIsIFwid29ybGRcIik7XG4gKlxuICovXG5jbGFzcyBQYXJlbnROYW1lc3BhY2UgZXh0ZW5kcyBuYW1lc3BhY2VfMS5OYW1lc3BhY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZlcikge1xuICAgICAgICBzdXBlcihzZXJ2ZXIsIFwiL19cIiArIFBhcmVudE5hbWVzcGFjZS5jb3VudCsrKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEFkYXB0ZXIoKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlciA9IG5ldyBQYXJlbnRCcm9hZGNhc3RBZGFwdGVyKHRoaXMpO1xuICAgIH1cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgobnNwKSA9PiB7XG4gICAgICAgICAgICBuc3AuZW1pdChldiwgLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY3JlYXRlQ2hpbGQobmFtZSkge1xuICAgICAgICBkZWJ1ZyhcImNyZWF0aW5nIGNoaWxkIG5hbWVzcGFjZSAlc1wiLCBuYW1lKTtcbiAgICAgICAgY29uc3QgbmFtZXNwYWNlID0gbmV3IG5hbWVzcGFjZV8xLk5hbWVzcGFjZSh0aGlzLnNlcnZlciwgbmFtZSk7XG4gICAgICAgIHRoaXNbXCJfZm5zXCJdLmZvckVhY2goKGZuKSA9PiBuYW1lc3BhY2UudXNlKGZuKSk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzKFwiY29ubmVjdFwiKS5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbmFtZXNwYWNlLm9uKFwiY29ubmVjdFwiLCBsaXN0ZW5lcikpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyhcImNvbm5lY3Rpb25cIikuZm9yRWFjaCgobGlzdGVuZXIpID0+IG5hbWVzcGFjZS5vbihcImNvbm5lY3Rpb25cIiwgbGlzdGVuZXIpKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5hZGQobmFtZXNwYWNlKTtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyLl9vcHRzLmNsZWFudXBFbXB0eUNoaWxkTmFtZXNwYWNlcykge1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlID0gbmFtZXNwYWNlLl9yZW1vdmU7XG4gICAgICAgICAgICBuYW1lc3BhY2UuX3JlbW92ZSA9IChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgICAgICByZW1vdmUuY2FsbChuYW1lc3BhY2UsIHNvY2tldCk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVzcGFjZS5zb2NrZXRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJjbG9zaW5nIGNoaWxkIG5hbWVzcGFjZSAlc1wiLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlLmFkYXB0ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXIuX25zcHMuZGVsZXRlKG5hbWVzcGFjZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5kZWxldGUobmFtZXNwYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VydmVyLl9uc3BzLnNldChuYW1lLCBuYW1lc3BhY2UpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuc2VydmVyLnNvY2tldHMuZW1pdFJlc2VydmVkKFwibmV3X25hbWVzcGFjZVwiLCBuYW1lc3BhY2UpO1xuICAgICAgICByZXR1cm4gbmFtZXNwYWNlO1xuICAgIH1cbiAgICBmZXRjaFNvY2tldHMoKSB7XG4gICAgICAgIC8vIG5vdGU6IHdlIGNvdWxkIG1ha2UgdGhlIGZldGNoU29ja2V0cygpIG1ldGhvZCB3b3JrIGZvciBkeW5hbWljIG5hbWVzcGFjZXMgY3JlYXRlZCB3aXRoIGEgcmVnZXggKGJ5IHNlbmRpbmcgdGhlXG4gICAgICAgIC8vIHJlZ2V4IHRvIHRoZSBvdGhlciBTb2NrZXQuSU8gc2VydmVycywgYW5kIHJldHVybmluZyB0aGUgc29ja2V0cyBvZiBlYWNoIG1hdGNoaW5nIG5hbWVzcGFjZSBmb3IgZXhhbXBsZSksIGJ1dFxuICAgICAgICAvLyB0aGUgYmVoYXZpb3IgZm9yIG5hbWVzcGFjZXMgY3JlYXRlZCB3aXRoIGEgZnVuY3Rpb24gaXMgbGVzcyBjbGVhclxuICAgICAgICAvLyBub3RlwrI6IHdlIGNhbm5vdCBsb29wIG92ZXIgZWFjaCBjaGlsZHJlbiBuYW1lc3BhY2UsIGJlY2F1c2Ugd2l0aCBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgYSBnaXZlbiBuYW1lc3BhY2VcbiAgICAgICAgLy8gbWF5IGV4aXN0IG9uIG9uZSBub2RlIGJ1dCBub3QgZXhpc3Qgb24gYW5vdGhlciAoc2luY2UgaXQgaXMgY3JlYXRlZCB1cG9uIGNsaWVudCBjb25uZWN0aW9uKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmZXRjaFNvY2tldHMoKSBpcyBub3Qgc3VwcG9ydGVkIG9uIHBhcmVudCBuYW1lc3BhY2VzXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuUGFyZW50TmFtZXNwYWNlID0gUGFyZW50TmFtZXNwYWNlO1xuUGFyZW50TmFtZXNwYWNlLmNvdW50ID0gMDtcbi8qKlxuICogQSBkdW1teSBhZGFwdGVyIHRoYXQgb25seSBzdXBwb3J0cyBicm9hZGNhc3RpbmcgdG8gY2hpbGQgKGNvbmNyZXRlKSBuYW1lc3BhY2VzLlxuICogQHByaXZhdGUgZmlsZVxuICovXG5jbGFzcyBQYXJlbnRCcm9hZGNhc3RBZGFwdGVyIGV4dGVuZHMgc29ja2V0X2lvX2FkYXB0ZXJfMS5BZGFwdGVyIHtcbiAgICBicm9hZGNhc3QocGFja2V0LCBvcHRzKSB7XG4gICAgICAgIHRoaXMubnNwLmNoaWxkcmVuLmZvckVhY2goKG5zcCkgPT4ge1xuICAgICAgICAgICAgbnNwLmFkYXB0ZXIuYnJvYWRjYXN0KHBhY2tldCwgb3B0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/parent-namespace.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/socket-types.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io/dist/socket-types.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RESERVED_EVENTS = void 0;\nexports.RESERVED_EVENTS = new Set([\n    \"connect\",\n    \"connect_error\",\n    \"disconnect\",\n    \"disconnecting\",\n    \"newListener\",\n    \"removeListener\",\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3Qvc29ja2V0LXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3Jzb2xlL0RvY3VtZW50cy9HaXRIdWIvbWFzc2ltaW5vL21hc3NpbWluby9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3Qvc29ja2V0LXR5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SRVNFUlZFRF9FVkVOVFMgPSB2b2lkIDA7XG5leHBvcnRzLlJFU0VSVkVEX0VWRU5UUyA9IG5ldyBTZXQoW1xuICAgIFwiY29ubmVjdFwiLFxuICAgIFwiY29ubmVjdF9lcnJvclwiLFxuICAgIFwiZGlzY29ubmVjdFwiLFxuICAgIFwiZGlzY29ubmVjdGluZ1wiLFxuICAgIFwibmV3TGlzdGVuZXJcIixcbiAgICBcInJlbW92ZUxpc3RlbmVyXCIsXG5dKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/socket-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/socket.js":
/*!***********************************************!*\
  !*** ./node_modules/socket.io/dist/socket.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Socket = void 0;\nconst socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ \"(rsc)/./node_modules/socket.io-parser/build/cjs/index.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst typed_events_1 = __webpack_require__(/*! ./typed-events */ \"(rsc)/./node_modules/socket.io/dist/typed-events.js\");\nconst base64id_1 = __importDefault(__webpack_require__(/*! base64id */ \"(rsc)/./node_modules/base64id/lib/base64id.js\"));\nconst broadcast_operator_1 = __webpack_require__(/*! ./broadcast-operator */ \"(rsc)/./node_modules/socket.io/dist/broadcast-operator.js\");\nconst socket_types_1 = __webpack_require__(/*! ./socket-types */ \"(rsc)/./node_modules/socket.io/dist/socket-types.js\");\nconst debug = (0, debug_1.default)(\"socket.io:socket\");\nconst RECOVERABLE_DISCONNECT_REASONS = new Set([\n    \"transport error\",\n    \"transport close\",\n    \"forced close\",\n    \"ping timeout\",\n    \"server shutting down\",\n    \"forced server close\",\n]);\nfunction noop() { }\n/**\n * This is the main object for interacting with a client.\n *\n * A Socket belongs to a given {@link Namespace} and uses an underlying {@link Client} to communicate.\n *\n * Within each {@link Namespace}, you can also define arbitrary channels (called \"rooms\") that the {@link Socket} can\n * join and leave. That provides a convenient way to broadcast to a group of socket instances.\n *\n * @example\n * io.on(\"connection\", (socket) => {\n *   console.log(`socket ${socket.id} connected`);\n *\n *   // send an event to the client\n *   socket.emit(\"foo\", \"bar\");\n *\n *   socket.on(\"foobar\", () => {\n *     // an event was received from the client\n *   });\n *\n *   // join the room named \"room1\"\n *   socket.join(\"room1\");\n *\n *   // broadcast to everyone in the room named \"room1\"\n *   io.to(\"room1\").emit(\"hello\");\n *\n *   // upon disconnection\n *   socket.on(\"disconnect\", (reason) => {\n *     console.log(`socket ${socket.id} disconnected due to ${reason}`);\n *   });\n * });\n */\nclass Socket extends typed_events_1.StrictEventEmitter {\n    /**\n     * Interface to a `Client` for a given `Namespace`.\n     *\n     * @param {Namespace} nsp\n     * @param {Client} client\n     * @param {Object} auth\n     * @package\n     */\n    constructor(nsp, client, auth, previousSession) {\n        super();\n        this.nsp = nsp;\n        this.client = client;\n        /**\n         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\n         * be transmitted to the client, the data attribute and the rooms will be restored.\n         */\n        this.recovered = false;\n        /**\n         * Additional information that can be attached to the Socket instance and which will be used in the\n         * {@link Server.fetchSockets()} method.\n         */\n        this.data = {};\n        /**\n         * Whether the socket is currently connected or not.\n         *\n         * @example\n         * io.use((socket, next) => {\n         *   console.log(socket.connected); // false\n         *   next();\n         * });\n         *\n         * io.on(\"connection\", (socket) => {\n         *   console.log(socket.connected); // true\n         * });\n         */\n        this.connected = false;\n        this.acks = new Map();\n        this.fns = [];\n        this.flags = {};\n        this.server = nsp.server;\n        this.adapter = this.nsp.adapter;\n        if (previousSession) {\n            this.id = previousSession.sid;\n            this.pid = previousSession.pid;\n            previousSession.rooms.forEach((room) => this.join(room));\n            this.data = previousSession.data;\n            previousSession.missedPackets.forEach((packet) => {\n                this.packet({\n                    type: socket_io_parser_1.PacketType.EVENT,\n                    data: packet,\n                });\n            });\n            this.recovered = true;\n        }\n        else {\n            if (client.conn.protocol === 3) {\n                // @ts-ignore\n                this.id = nsp.name !== \"/\" ? nsp.name + \"#\" + client.id : client.id;\n            }\n            else {\n                this.id = base64id_1.default.generateId(); // don't reuse the Engine.IO id because it's sensitive information\n            }\n            if (this.server._opts.connectionStateRecovery) {\n                this.pid = base64id_1.default.generateId();\n            }\n        }\n        this.handshake = this.buildHandshake(auth);\n        // prevents crash when the socket receives an \"error\" event without listener\n        this.on(\"error\", noop);\n    }\n    /**\n     * Builds the `handshake` BC object\n     *\n     * @private\n     */\n    buildHandshake(auth) {\n        var _a, _b, _c, _d;\n        return {\n            headers: ((_a = this.request) === null || _a === void 0 ? void 0 : _a.headers) || {},\n            time: new Date() + \"\",\n            address: this.conn.remoteAddress,\n            xdomain: !!((_b = this.request) === null || _b === void 0 ? void 0 : _b.headers.origin),\n            // @ts-ignore\n            secure: !this.request || !!this.request.connection.encrypted,\n            issued: +new Date(),\n            url: (_c = this.request) === null || _c === void 0 ? void 0 : _c.url,\n            // @ts-ignore\n            query: ((_d = this.request) === null || _d === void 0 ? void 0 : _d._query) || {},\n            auth,\n        };\n    }\n    /**\n     * Emits to this client.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.emit(\"hello\", \"world\");\n     *\n     *   // all serializable datastructures are supported (no need to call JSON.stringify)\n     *   socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Buffer.from([6]) });\n     *\n     *   // with an acknowledgement from the client\n     *   socket.emit(\"hello\", \"world\", (val) => {\n     *     // ...\n     *   });\n     * });\n     *\n     * @return Always returns `true`.\n     */\n    emit(ev, ...args) {\n        if (socket_types_1.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${String(ev)}\" is a reserved event name`);\n        }\n        const data = [ev, ...args];\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: data,\n        };\n        // access last argument to see if it's an ACK callback\n        if (typeof data[data.length - 1] === \"function\") {\n            const id = this.nsp._ids++;\n            debug(\"emitting packet with ack id %d\", id);\n            this.registerAckCallback(id, data.pop());\n            packet.id = id;\n        }\n        const flags = Object.assign({}, this.flags);\n        this.flags = {};\n        // @ts-ignore\n        if (this.nsp.server.opts.connectionStateRecovery) {\n            // this ensures the packet is stored and can be transmitted upon reconnection\n            this.adapter.broadcast(packet, {\n                rooms: new Set([this.id]),\n                except: new Set(),\n                flags,\n            });\n        }\n        else {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet, flags);\n        }\n        return true;\n    }\n    /**\n     * Emits an event and waits for an acknowledgement\n     *\n     * @example\n     * io.on(\"connection\", async (socket) => {\n     *   // without timeout\n     *   const response = await socket.emitWithAck(\"hello\", \"world\");\n     *\n     *   // with a specific timeout\n     *   try {\n     *     const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n     *   } catch (err) {\n     *     // the client did not acknowledge the event in the given delay\n     *   }\n     * });\n     *\n     * @return a Promise that will be fulfilled when the client acknowledges the event\n     */\n    emitWithAck(ev, ...args) {\n        // the timeout flag is optional\n        const withErr = this.flags.timeout !== undefined;\n        return new Promise((resolve, reject) => {\n            args.push((arg1, arg2) => {\n                if (withErr) {\n                    return arg1 ? reject(arg1) : resolve(arg2);\n                }\n                else {\n                    return resolve(arg1);\n                }\n            });\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * @private\n     */\n    registerAckCallback(id, ack) {\n        const timeout = this.flags.timeout;\n        if (timeout === undefined) {\n            this.acks.set(id, ack);\n            return;\n        }\n        const timer = setTimeout(() => {\n            debug(\"event with ack id %d has timed out after %d ms\", id, timeout);\n            this.acks.delete(id);\n            ack.call(this, new Error(\"operation has timed out\"));\n        }, timeout);\n        this.acks.set(id, (...args) => {\n            clearTimeout(timer);\n            ack.apply(this, [null, ...args]);\n        });\n    }\n    /**\n     * Targets a room when broadcasting.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the “foo” event will be broadcast to all connected clients in the “room-101” room, except this socket\n     *   socket.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     *   // the code above is equivalent to:\n     *   io.to(\"room-101\").except(socket.id).emit(\"foo\", \"bar\");\n     *\n     *   // with an array of rooms (a client will be notified at most once)\n     *   socket.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     *   // with multiple chained calls\n     *   socket.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    to(room) {\n        return this.newBroadcastOperator().to(room);\n    }\n    /**\n     * Targets a room when broadcasting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // disconnect all clients in the \"room-101\" room, except this socket\n     *   socket.in(\"room-101\").disconnectSockets();\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    in(room) {\n        return this.newBroadcastOperator().in(room);\n    }\n    /**\n     * Excludes a room when broadcasting.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     *   // and this socket\n     *   socket.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     *   // with an array of rooms\n     *   socket.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     *   // with multiple chained calls\n     *   socket.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    except(room) {\n        return this.newBroadcastOperator().except(room);\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.send(\"hello\");\n     *\n     *   // this is equivalent to\n     *   socket.emit(\"message\", \"hello\");\n     * });\n     *\n     * @return self\n     */\n    send(...args) {\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a `message` event. Alias of {@link send}.\n     *\n     * @return self\n     */\n    write(...args) {\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param {Object} packet - packet object\n     * @param {Object} opts - options\n     * @private\n     */\n    packet(packet, opts = {}) {\n        packet.nsp = this.nsp.name;\n        opts.compress = false !== opts.compress;\n        this.client._packet(packet, opts);\n    }\n    /**\n     * Joins a room.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // join a single room\n     *   socket.join(\"room1\");\n     *\n     *   // join multiple rooms\n     *   socket.join([\"room1\", \"room2\"]);\n     * });\n     *\n     * @param {String|Array} rooms - room or array of rooms\n     * @return a Promise or nothing, depending on the adapter\n     */\n    join(rooms) {\n        debug(\"join room %s\", rooms);\n        return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [rooms]));\n    }\n    /**\n     * Leaves a room.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // leave a single room\n     *   socket.leave(\"room1\");\n     *\n     *   // leave multiple rooms\n     *   socket.leave(\"room1\").leave(\"room2\");\n     * });\n     *\n     * @param {String} room\n     * @return a Promise or nothing, depending on the adapter\n     */\n    leave(room) {\n        debug(\"leave room %s\", room);\n        return this.adapter.del(this.id, room);\n    }\n    /**\n     * Leave all rooms.\n     *\n     * @private\n     */\n    leaveAll() {\n        this.adapter.delAll(this.id);\n    }\n    /**\n     * Called by `Namespace` upon successful\n     * middleware execution (ie: authorization).\n     * Socket is added to namespace array before\n     * call to join, so adapters can access it.\n     *\n     * @private\n     */\n    _onconnect() {\n        debug(\"socket connected - writing packet\");\n        this.connected = true;\n        this.join(this.id);\n        if (this.conn.protocol === 3) {\n            this.packet({ type: socket_io_parser_1.PacketType.CONNECT });\n        }\n        else {\n            this.packet({\n                type: socket_io_parser_1.PacketType.CONNECT,\n                data: { sid: this.id, pid: this.pid },\n            });\n        }\n    }\n    /**\n     * Called with each packet. Called by `Client`.\n     *\n     * @param {Object} packet\n     * @private\n     */\n    _onpacket(packet) {\n        debug(\"got packet %j\", packet);\n        switch (packet.type) {\n            case socket_io_parser_1.PacketType.EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n        }\n    }\n    /**\n     * Called upon event packet.\n     *\n     * @param {Packet} packet - packet object\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        debug(\"emitting event %j\", args);\n        if (null != packet.id) {\n            debug(\"attaching ack callback to event\");\n            args.push(this.ack(packet.id));\n        }\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        this.dispatch(args);\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @param {Number} id - packet id\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function () {\n            // prevent double callbacks\n            if (sent)\n                return;\n            const args = Array.prototype.slice.call(arguments);\n            debug(\"sending ack %j\", args);\n            self.packet({\n                id: id,\n                type: socket_io_parser_1.PacketType.ACK,\n                data: args,\n            });\n            sent = true;\n        };\n    }\n    /**\n     * Called upon ack packet.\n     *\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks.get(packet.id);\n        if (\"function\" == typeof ack) {\n            debug(\"calling ack %s with %j\", packet.id, packet.data);\n            ack.apply(this, packet.data);\n            this.acks.delete(packet.id);\n        }\n        else {\n            debug(\"bad ack %s\", packet.id);\n        }\n    }\n    /**\n     * Called upon client disconnect packet.\n     *\n     * @private\n     */\n    ondisconnect() {\n        debug(\"got disconnect packet\");\n        this._onclose(\"client namespace disconnect\");\n    }\n    /**\n     * Handles a client error.\n     *\n     * @private\n     */\n    _onerror(err) {\n        // FIXME the meaning of the \"error\" event is overloaded:\n        //  - it can be sent by the client (`socket.emit(\"error\")`)\n        //  - it can be emitted when the connection encounters an error (an invalid packet for example)\n        //  - it can be emitted when a packet is rejected in a middleware (`socket.use()`)\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Called upon closing. Called by `Client`.\n     *\n     * @param {String} reason\n     * @param description\n     * @throw {Error} optional error object\n     *\n     * @private\n     */\n    _onclose(reason, description) {\n        if (!this.connected)\n            return this;\n        debug(\"closing socket - reason %s\", reason);\n        this.emitReserved(\"disconnecting\", reason, description);\n        if (this.server._opts.connectionStateRecovery &&\n            RECOVERABLE_DISCONNECT_REASONS.has(reason)) {\n            debug(\"connection state recovery is enabled for sid %s\", this.id);\n            this.adapter.persistSession({\n                sid: this.id,\n                pid: this.pid,\n                rooms: [...this.rooms],\n                data: this.data,\n            });\n        }\n        this._cleanup();\n        this.client._remove(this);\n        this.connected = false;\n        this.emitReserved(\"disconnect\", reason, description);\n        return;\n    }\n    /**\n     * Makes the socket leave all the rooms it was part of and prevents it from joining any other room\n     *\n     * @private\n     */\n    _cleanup() {\n        this.leaveAll();\n        this.nsp._remove(this);\n        this.join = noop;\n    }\n    /**\n     * Produces an `error` packet.\n     *\n     * @param {Object} err - error object\n     *\n     * @private\n     */\n    _error(err) {\n        this.packet({ type: socket_io_parser_1.PacketType.CONNECT_ERROR, data: err });\n    }\n    /**\n     * Disconnects this client.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // disconnect this socket (the connection might be kept alive for other namespaces)\n     *   socket.disconnect();\n     *\n     *   // disconnect this socket and close the underlying connection\n     *   socket.disconnect(true);\n     * })\n     *\n     * @param {Boolean} close - if `true`, closes the underlying connection\n     * @return self\n     */\n    disconnect(close = false) {\n        if (!this.connected)\n            return this;\n        if (close) {\n            this.client._disconnect();\n        }\n        else {\n            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });\n            this._onclose(\"server namespace disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.compress(false).emit(\"hello\");\n     * });\n     *\n     * @param {Boolean} compress - if `true`, compresses the sending data\n     * @return {Socket} self\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.volatile.emit(\"hello\"); // the client may or may not receive it\n     * });\n     *\n     * @return {Socket} self\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the\n     * sender.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the “foo” event will be broadcast to all connected clients, except this socket\n     *   socket.broadcast.emit(\"foo\", \"bar\");\n     * });\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    get broadcast() {\n        return this.newBroadcastOperator();\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the “foo” event will be broadcast to all connected clients on this node, except this socket\n     *   socket.local.emit(\"foo\", \"bar\");\n     * });\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    get local() {\n        return this.newBroadcastOperator().local;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n     * given number of milliseconds have elapsed without an acknowledgement from the client:\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.timeout(5000).emit(\"my-event\", (err) => {\n     *     if (err) {\n     *       // the client did not acknowledge the event in the given delay\n     *     }\n     *   });\n     * });\n     *\n     * @returns self\n     */\n    timeout(timeout) {\n        this.flags.timeout = timeout;\n        return this;\n    }\n    /**\n     * Dispatch incoming event to socket listeners.\n     *\n     * @param {Array} event - event that will get emitted\n     * @private\n     */\n    dispatch(event) {\n        debug(\"dispatching an event %j\", event);\n        this.run(event, (err) => {\n            process.nextTick(() => {\n                if (err) {\n                    return this._onerror(err);\n                }\n                if (this.connected) {\n                    super.emitUntyped.apply(this, event);\n                }\n                else {\n                    debug(\"ignore packet received after disconnection\");\n                }\n            });\n        });\n    }\n    /**\n     * Sets up socket middleware.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.use(([event, ...args], next) => {\n     *     if (isUnauthorized(event)) {\n     *       return next(new Error(\"unauthorized event\"));\n     *     }\n     *     // do not forget to call next\n     *     next();\n     *   });\n     *\n     *   socket.on(\"error\", (err) => {\n     *     if (err && err.message === \"unauthorized event\") {\n     *       socket.disconnect();\n     *     }\n     *   });\n     * });\n     *\n     * @param {Function} fn - middleware function (event, next)\n     * @return {Socket} self\n     */\n    use(fn) {\n        this.fns.push(fn);\n        return this;\n    }\n    /**\n     * Executes the middleware for an incoming event.\n     *\n     * @param {Array} event - event that will get emitted\n     * @param {Function} fn - last fn call in the middleware\n     * @private\n     */\n    run(event, fn) {\n        if (!this.fns.length)\n            return fn();\n        const fns = this.fns.slice(0);\n        function run(i) {\n            fns[i](event, (err) => {\n                // upon error, short-circuit\n                if (err)\n                    return fn(err);\n                // if no middleware left, summon callback\n                if (!fns[i + 1])\n                    return fn();\n                // go on to next\n                run(i + 1);\n            });\n        }\n        run(0);\n    }\n    /**\n     * Whether the socket is currently disconnected\n     */\n    get disconnected() {\n        return !this.connected;\n    }\n    /**\n     * A reference to the request that originated the underlying Engine.IO Socket.\n     */\n    get request() {\n        return this.client.request;\n    }\n    /**\n     * A reference to the underlying Client transport connection (Engine.IO Socket object).\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   console.log(socket.conn.transport.name); // prints \"polling\" or \"websocket\"\n     *\n     *   socket.conn.once(\"upgrade\", () => {\n     *     console.log(socket.conn.transport.name); // prints \"websocket\"\n     *   });\n     * });\n     */\n    get conn() {\n        return this.client.conn;\n    }\n    /**\n     * Returns the rooms the socket is currently in.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   console.log(socket.rooms); // Set { <socket.id> }\n     *\n     *   socket.join(\"room1\");\n     *\n     *   console.log(socket.rooms); // Set { <socket.id>, \"room1\" }\n     * });\n     */\n    get rooms() {\n        return this.adapter.socketRooms(this.id) || new Set();\n    }\n    /**\n     * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to\n     * the callback.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.onAny((event, ...args) => {\n     *     console.log(`got event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to\n     * the callback. The listener is added to the beginning of the listeners array.\n     *\n     * @param listener\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is received.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   const catchAllListener = (event, ...args) => {\n     *     console.log(`got event ${event}`);\n     *   }\n     *\n     *   socket.onAny(catchAllListener);\n     *\n     *   // remove a specific listener\n     *   socket.offAny(catchAllListener);\n     *\n     *   // or remove all listeners\n     *   socket.offAny();\n     * });\n     *\n     * @param listener\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n    /**\n     * Adds a listener that will be fired when any event is sent. The event name is passed as the first argument to\n     * the callback.\n     *\n     * Note: acknowledgements sent to the client are not included.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.onAnyOutgoing((event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */\n    onAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.prependAnyOutgoing((event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */\n    prependAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is sent.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   const catchAllListener = (event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   }\n     *\n     *   socket.onAnyOutgoing(catchAllListener);\n     *\n     *   // remove a specific listener\n     *   socket.offAnyOutgoing(catchAllListener);\n     *\n     *   // or remove all listeners\n     *   socket.offAnyOutgoing();\n     * });\n     *\n     * @param listener - the catch-all listener\n     */\n    offAnyOutgoing(listener) {\n        if (!this._anyOutgoingListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyOutgoingListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyOutgoingListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAnyOutgoing() {\n        return this._anyOutgoingListeners || [];\n    }\n    /**\n     * Notify the listeners for each packet sent (emit or broadcast)\n     *\n     * @param packet\n     *\n     * @private\n     */\n    notifyOutgoingListeners(packet) {\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n            const listeners = this._anyOutgoingListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, packet.data);\n            }\n        }\n    }\n    newBroadcastOperator() {\n        const flags = Object.assign({}, this.flags);\n        this.flags = {};\n        return new broadcast_operator_1.BroadcastOperator(this.adapter, new Set(), new Set([this.id]), flags);\n    }\n}\nexports.Socket = Socket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3Qvc29ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLDJCQUEyQixtQkFBTyxDQUFDLGtGQUFrQjtBQUNyRCxnQ0FBZ0MsbUJBQU8sQ0FBQyw2RUFBTztBQUMvQyx1QkFBdUIsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDL0MsbUNBQW1DLG1CQUFPLENBQUMsK0RBQVU7QUFDckQsNkJBQTZCLG1CQUFPLENBQUMsdUZBQXNCO0FBQzNELHVCQUF1QixtQkFBTyxDQUFDLDJFQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUIsd0JBQXdCLGNBQWM7QUFDdkY7QUFDQSxnQkFBZ0IsZ0JBQWdCLG9FQUFvRSxjQUFjO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXLHNCQUFzQixPQUFPO0FBQ3JFLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsK0JBQStCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQTZDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhEQUE4RDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnREFBZ0Q7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLFFBQVE7QUFDUjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBLGVBQWUsVUFBVTtBQUN6QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNO0FBQzFDLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsTUFBTTtBQUMzQyxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxNQUFNO0FBQzNDLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxNQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcnNvbGUvRG9jdW1lbnRzL0dpdEh1Yi9tYXNzaW1pbm8vbWFzc2ltaW5vL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9zb2NrZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNvY2tldCA9IHZvaWQgMDtcbmNvbnN0IHNvY2tldF9pb19wYXJzZXJfMSA9IHJlcXVpcmUoXCJzb2NrZXQuaW8tcGFyc2VyXCIpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgdHlwZWRfZXZlbnRzXzEgPSByZXF1aXJlKFwiLi90eXBlZC1ldmVudHNcIik7XG5jb25zdCBiYXNlNjRpZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJiYXNlNjRpZFwiKSk7XG5jb25zdCBicm9hZGNhc3Rfb3BlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL2Jyb2FkY2FzdC1vcGVyYXRvclwiKTtcbmNvbnN0IHNvY2tldF90eXBlc18xID0gcmVxdWlyZShcIi4vc29ja2V0LXR5cGVzXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcInNvY2tldC5pbzpzb2NrZXRcIik7XG5jb25zdCBSRUNPVkVSQUJMRV9ESVNDT05ORUNUX1JFQVNPTlMgPSBuZXcgU2V0KFtcbiAgICBcInRyYW5zcG9ydCBlcnJvclwiLFxuICAgIFwidHJhbnNwb3J0IGNsb3NlXCIsXG4gICAgXCJmb3JjZWQgY2xvc2VcIixcbiAgICBcInBpbmcgdGltZW91dFwiLFxuICAgIFwic2VydmVyIHNodXR0aW5nIGRvd25cIixcbiAgICBcImZvcmNlZCBzZXJ2ZXIgY2xvc2VcIixcbl0pO1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxuLyoqXG4gKiBUaGlzIGlzIHRoZSBtYWluIG9iamVjdCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhIGNsaWVudC5cbiAqXG4gKiBBIFNvY2tldCBiZWxvbmdzIHRvIGEgZ2l2ZW4ge0BsaW5rIE5hbWVzcGFjZX0gYW5kIHVzZXMgYW4gdW5kZXJseWluZyB7QGxpbmsgQ2xpZW50fSB0byBjb21tdW5pY2F0ZS5cbiAqXG4gKiBXaXRoaW4gZWFjaCB7QGxpbmsgTmFtZXNwYWNlfSwgeW91IGNhbiBhbHNvIGRlZmluZSBhcmJpdHJhcnkgY2hhbm5lbHMgKGNhbGxlZCBcInJvb21zXCIpIHRoYXQgdGhlIHtAbGluayBTb2NrZXR9IGNhblxuICogam9pbiBhbmQgbGVhdmUuIFRoYXQgcHJvdmlkZXMgYSBjb252ZW5pZW50IHdheSB0byBicm9hZGNhc3QgdG8gYSBncm91cCBvZiBzb2NrZXQgaW5zdGFuY2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICogICBjb25zb2xlLmxvZyhgc29ja2V0ICR7c29ja2V0LmlkfSBjb25uZWN0ZWRgKTtcbiAqXG4gKiAgIC8vIHNlbmQgYW4gZXZlbnQgdG8gdGhlIGNsaWVudFxuICogICBzb2NrZXQuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAqXG4gKiAgIHNvY2tldC5vbihcImZvb2JhclwiLCAoKSA9PiB7XG4gKiAgICAgLy8gYW4gZXZlbnQgd2FzIHJlY2VpdmVkIGZyb20gdGhlIGNsaWVudFxuICogICB9KTtcbiAqXG4gKiAgIC8vIGpvaW4gdGhlIHJvb20gbmFtZWQgXCJyb29tMVwiXG4gKiAgIHNvY2tldC5qb2luKFwicm9vbTFcIik7XG4gKlxuICogICAvLyBicm9hZGNhc3QgdG8gZXZlcnlvbmUgaW4gdGhlIHJvb20gbmFtZWQgXCJyb29tMVwiXG4gKiAgIGlvLnRvKFwicm9vbTFcIikuZW1pdChcImhlbGxvXCIpO1xuICpcbiAqICAgLy8gdXBvbiBkaXNjb25uZWN0aW9uXG4gKiAgIHNvY2tldC5vbihcImRpc2Nvbm5lY3RcIiwgKHJlYXNvbikgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGBzb2NrZXQgJHtzb2NrZXQuaWR9IGRpc2Nvbm5lY3RlZCBkdWUgdG8gJHtyZWFzb259YCk7XG4gKiAgIH0pO1xuICogfSk7XG4gKi9cbmNsYXNzIFNvY2tldCBleHRlbmRzIHR5cGVkX2V2ZW50c18xLlN0cmljdEV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogSW50ZXJmYWNlIHRvIGEgYENsaWVudGAgZm9yIGEgZ2l2ZW4gYE5hbWVzcGFjZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05hbWVzcGFjZX0gbnNwXG4gICAgICogQHBhcmFtIHtDbGllbnR9IGNsaWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdXRoXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihuc3AsIGNsaWVudCwgYXV0aCwgcHJldmlvdXNTZXNzaW9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubnNwID0gbnNwO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNvbm5lY3Rpb24gc3RhdGUgd2FzIHJlY292ZXJlZCBhZnRlciBhIHRlbXBvcmFyeSBkaXNjb25uZWN0aW9uLiBJbiB0aGF0IGNhc2UsIGFueSBtaXNzZWQgcGFja2V0cyB3aWxsXG4gICAgICAgICAqIGJlIHRyYW5zbWl0dGVkIHRvIHRoZSBjbGllbnQsIHRoZSBkYXRhIGF0dHJpYnV0ZSBhbmQgdGhlIHJvb21zIHdpbGwgYmUgcmVzdG9yZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlY292ZXJlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byB0aGUgU29ja2V0IGluc3RhbmNlIGFuZCB3aGljaCB3aWxsIGJlIHVzZWQgaW4gdGhlXG4gICAgICAgICAqIHtAbGluayBTZXJ2ZXIuZmV0Y2hTb2NrZXRzKCl9IG1ldGhvZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgc29ja2V0IGlzIGN1cnJlbnRseSBjb25uZWN0ZWQgb3Igbm90LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBpby51c2UoKHNvY2tldCwgbmV4dCkgPT4ge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5jb25uZWN0ZWQpOyAvLyBmYWxzZVxuICAgICAgICAgKiAgIG5leHQoKTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmNvbm5lY3RlZCk7IC8vIHRydWVcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFja3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZm5zID0gW107XG4gICAgICAgIHRoaXMuZmxhZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBuc3Auc2VydmVyO1xuICAgICAgICB0aGlzLmFkYXB0ZXIgPSB0aGlzLm5zcC5hZGFwdGVyO1xuICAgICAgICBpZiAocHJldmlvdXNTZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gcHJldmlvdXNTZXNzaW9uLnNpZDtcbiAgICAgICAgICAgIHRoaXMucGlkID0gcHJldmlvdXNTZXNzaW9uLnBpZDtcbiAgICAgICAgICAgIHByZXZpb3VzU2Vzc2lvbi5yb29tcy5mb3JFYWNoKChyb29tKSA9PiB0aGlzLmpvaW4ocm9vbSkpO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gcHJldmlvdXNTZXNzaW9uLmRhdGE7XG4gICAgICAgICAgICBwcmV2aW91c1Nlc3Npb24ubWlzc2VkUGFja2V0cy5mb3JFYWNoKChwYWNrZXQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhY2tldCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkVWRU5ULFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwYWNrZXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjbGllbnQuY29ubi5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0aGlzLmlkID0gbnNwLm5hbWUgIT09IFwiL1wiID8gbnNwLm5hbWUgKyBcIiNcIiArIGNsaWVudC5pZCA6IGNsaWVudC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaWQgPSBiYXNlNjRpZF8xLmRlZmF1bHQuZ2VuZXJhdGVJZCgpOyAvLyBkb24ndCByZXVzZSB0aGUgRW5naW5lLklPIGlkIGJlY2F1c2UgaXQncyBzZW5zaXRpdmUgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNlcnZlci5fb3B0cy5jb25uZWN0aW9uU3RhdGVSZWNvdmVyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGlkID0gYmFzZTY0aWRfMS5kZWZhdWx0LmdlbmVyYXRlSWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRzaGFrZSA9IHRoaXMuYnVpbGRIYW5kc2hha2UoYXV0aCk7XG4gICAgICAgIC8vIHByZXZlbnRzIGNyYXNoIHdoZW4gdGhlIHNvY2tldCByZWNlaXZlcyBhbiBcImVycm9yXCIgZXZlbnQgd2l0aG91dCBsaXN0ZW5lclxuICAgICAgICB0aGlzLm9uKFwiZXJyb3JcIiwgbm9vcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyB0aGUgYGhhbmRzaGFrZWAgQkMgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJ1aWxkSGFuZHNoYWtlKGF1dGgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVhZGVyczogKChfYSA9IHRoaXMucmVxdWVzdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYWRlcnMpIHx8IHt9LFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKSArIFwiXCIsXG4gICAgICAgICAgICBhZGRyZXNzOiB0aGlzLmNvbm4ucmVtb3RlQWRkcmVzcyxcbiAgICAgICAgICAgIHhkb21haW46ICEhKChfYiA9IHRoaXMucmVxdWVzdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlYWRlcnMub3JpZ2luKSxcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHNlY3VyZTogIXRoaXMucmVxdWVzdCB8fCAhIXRoaXMucmVxdWVzdC5jb25uZWN0aW9uLmVuY3J5cHRlZCxcbiAgICAgICAgICAgIGlzc3VlZDogK25ldyBEYXRlKCksXG4gICAgICAgICAgICB1cmw6IChfYyA9IHRoaXMucmVxdWVzdCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybCxcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHF1ZXJ5OiAoKF9kID0gdGhpcy5yZXF1ZXN0KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuX3F1ZXJ5KSB8fCB7fSxcbiAgICAgICAgICAgIGF1dGgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIHRvIHRoaXMgY2xpZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgc29ja2V0LmVtaXQoXCJoZWxsb1wiLCBcIndvcmxkXCIpO1xuICAgICAqXG4gICAgICogICAvLyBhbGwgc2VyaWFsaXphYmxlIGRhdGFzdHJ1Y3R1cmVzIGFyZSBzdXBwb3J0ZWQgKG5vIG5lZWQgdG8gY2FsbCBKU09OLnN0cmluZ2lmeSlcbiAgICAgKiAgIHNvY2tldC5lbWl0KFwiaGVsbG9cIiwgMSwgXCIyXCIsIHsgMzogW1wiNFwiXSwgNTogQnVmZmVyLmZyb20oWzZdKSB9KTtcbiAgICAgKlxuICAgICAqICAgLy8gd2l0aCBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSB0aGUgY2xpZW50XG4gICAgICogICBzb2NrZXQuZW1pdChcImhlbGxvXCIsIFwid29ybGRcIiwgKHZhbCkgPT4ge1xuICAgICAqICAgICAvLyAuLi5cbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHJldHVybiBBbHdheXMgcmV0dXJucyBgdHJ1ZWAuXG4gICAgICovXG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICBpZiAoc29ja2V0X3R5cGVzXzEuUkVTRVJWRURfRVZFTlRTLmhhcyhldikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke1N0cmluZyhldil9XCIgaXMgYSByZXNlcnZlZCBldmVudCBuYW1lYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IFtldiwgLi4uYXJnc107XG4gICAgICAgIGNvbnN0IHBhY2tldCA9IHtcbiAgICAgICAgICAgIHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkVWRU5ULFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gYWNjZXNzIGxhc3QgYXJndW1lbnQgdG8gc2VlIGlmIGl0J3MgYW4gQUNLIGNhbGxiYWNrXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gdGhpcy5uc3AuX2lkcysrO1xuICAgICAgICAgICAgZGVidWcoXCJlbWl0dGluZyBwYWNrZXQgd2l0aCBhY2sgaWQgJWRcIiwgaWQpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlckFja0NhbGxiYWNrKGlkLCBkYXRhLnBvcCgpKTtcbiAgICAgICAgICAgIHBhY2tldC5pZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5mbGFncyk7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSB7fTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAodGhpcy5uc3Auc2VydmVyLm9wdHMuY29ubmVjdGlvblN0YXRlUmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgZW5zdXJlcyB0aGUgcGFja2V0IGlzIHN0b3JlZCBhbmQgY2FuIGJlIHRyYW5zbWl0dGVkIHVwb24gcmVjb25uZWN0aW9uXG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIuYnJvYWRjYXN0KHBhY2tldCwge1xuICAgICAgICAgICAgICAgIHJvb21zOiBuZXcgU2V0KFt0aGlzLmlkXSksXG4gICAgICAgICAgICAgICAgZXhjZXB0OiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5T3V0Z29pbmdMaXN0ZW5lcnMocGFja2V0KTtcbiAgICAgICAgICAgIHRoaXMucGFja2V0KHBhY2tldCwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBhbmQgd2FpdHMgZm9yIGFuIGFja25vd2xlZGdlbWVudFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgYXN5bmMgKHNvY2tldCkgPT4ge1xuICAgICAqICAgLy8gd2l0aG91dCB0aW1lb3V0XG4gICAgICogICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNvY2tldC5lbWl0V2l0aEFjayhcImhlbGxvXCIsIFwid29ybGRcIik7XG4gICAgICpcbiAgICAgKiAgIC8vIHdpdGggYSBzcGVjaWZpYyB0aW1lb3V0XG4gICAgICogICB0cnkge1xuICAgICAqICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNvY2tldC50aW1lb3V0KDEwMDApLmVtaXRXaXRoQWNrKFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAgICAgKiAgIH0gY2F0Y2ggKGVycikge1xuICAgICAqICAgICAvLyB0aGUgY2xpZW50IGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHJldHVybiBhIFByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBjbGllbnQgYWNrbm93bGVkZ2VzIHRoZSBldmVudFxuICAgICAqL1xuICAgIGVtaXRXaXRoQWNrKGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIHRoZSB0aW1lb3V0IGZsYWcgaXMgb3B0aW9uYWxcbiAgICAgICAgY29uc3Qgd2l0aEVyciA9IHRoaXMuZmxhZ3MudGltZW91dCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgYXJncy5wdXNoKChhcmcxLCBhcmcyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHdpdGhFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZzEgPyByZWplY3QoYXJnMSkgOiByZXNvbHZlKGFyZzIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoYXJnMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZWdpc3RlckFja0NhbGxiYWNrKGlkLCBhY2spIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuZmxhZ3MudGltZW91dDtcbiAgICAgICAgaWYgKHRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hY2tzLnNldChpZCwgYWNrKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJldmVudCB3aXRoIGFjayBpZCAlZCBoYXMgdGltZWQgb3V0IGFmdGVyICVkIG1zXCIsIGlkLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuYWNrcy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgYWNrLmNhbGwodGhpcywgbmV3IEVycm9yKFwib3BlcmF0aW9uIGhhcyB0aW1lZCBvdXRcIikpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgdGhpcy5hY2tzLnNldChpZCwgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICBhY2suYXBwbHkodGhpcywgW251bGwsIC4uLmFyZ3NdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gYnJvYWRjYXN0aW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgLy8gdGhlIOKAnGZvb+KAnSBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMgaW4gdGhlIOKAnHJvb20tMTAx4oCdIHJvb20sIGV4Y2VwdCB0aGlzIHNvY2tldFxuICAgICAqICAgc29ja2V0LnRvKFwicm9vbS0xMDFcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqICAgLy8gdGhlIGNvZGUgYWJvdmUgaXMgZXF1aXZhbGVudCB0bzpcbiAgICAgKiAgIGlvLnRvKFwicm9vbS0xMDFcIikuZXhjZXB0KHNvY2tldC5pZCkuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqICAgLy8gd2l0aCBhbiBhcnJheSBvZiByb29tcyAoYSBjbGllbnQgd2lsbCBiZSBub3RpZmllZCBhdCBtb3N0IG9uY2UpXG4gICAgICogICBzb2NrZXQudG8oW1wicm9vbS0xMDFcIiwgXCJyb29tLTEwMlwiXSkuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqICAgLy8gd2l0aCBtdWx0aXBsZSBjaGFpbmVkIGNhbGxzXG4gICAgICogICBzb2NrZXQudG8oXCJyb29tLTEwMVwiKS50byhcInJvb20tMTAyXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgdG8ocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdCcm9hZGNhc3RPcGVyYXRvcigpLnRvKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYXJnZXRzIGEgcm9vbSB3aGVuIGJyb2FkY2FzdGluZy4gU2ltaWxhciB0byBgdG8oKWAsIGJ1dCBtaWdodCBmZWVsIGNsZWFyZXIgaW4gc29tZSBjYXNlczpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIC8vIGRpc2Nvbm5lY3QgYWxsIGNsaWVudHMgaW4gdGhlIFwicm9vbS0xMDFcIiByb29tLCBleGNlcHQgdGhpcyBzb2NrZXRcbiAgICAgKiAgIHNvY2tldC5pbihcInJvb20tMTAxXCIpLmRpc2Nvbm5lY3RTb2NrZXRzKCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgaW4ocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdCcm9hZGNhc3RPcGVyYXRvcigpLmluKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGNsdWRlcyBhIHJvb20gd2hlbiBicm9hZGNhc3RpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICAvLyB0aGUgXCJmb29cIiBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMsIGV4Y2VwdCB0aGUgb25lcyB0aGF0IGFyZSBpbiB0aGUgXCJyb29tLTEwMVwiIHJvb21cbiAgICAgKiAgIC8vIGFuZCB0aGlzIHNvY2tldFxuICAgICAqICAgc29ja2V0LmV4Y2VwdChcInJvb20tMTAxXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAgIC8vIHdpdGggYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiAgIHNvY2tldC5leGNlcHQoW1wicm9vbS0xMDFcIiwgXCJyb29tLTEwMlwiXSkuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqICAgLy8gd2l0aCBtdWx0aXBsZSBjaGFpbmVkIGNhbGxzXG4gICAgICogICBzb2NrZXQuZXhjZXB0KFwicm9vbS0xMDFcIikuZXhjZXB0KFwicm9vbS0xMDJcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBleGNlcHQocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdCcm9hZGNhc3RPcGVyYXRvcigpLmV4Y2VwdChyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtaW1pY3MgdGhlIFdlYlNvY2tldC5zZW5kKCkgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViU29ja2V0L3NlbmRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIHNvY2tldC5zZW5kKFwiaGVsbG9cIik7XG4gICAgICpcbiAgICAgKiAgIC8vIHRoaXMgaXMgZXF1aXZhbGVudCB0b1xuICAgICAqICAgc29ja2V0LmVtaXQoXCJtZXNzYWdlXCIsIFwiaGVsbG9cIik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBzZW5kKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwibWVzc2FnZVwiLCAuLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LiBBbGlhcyBvZiB7QGxpbmsgc2VuZH0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICB3cml0ZSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuZW1pdChcIm1lc3NhZ2VcIiwgLi4uYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gcGFja2V0IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcGFja2V0KHBhY2tldCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHBhY2tldC5uc3AgPSB0aGlzLm5zcC5uYW1lO1xuICAgICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdHMuY29tcHJlc3M7XG4gICAgICAgIHRoaXMuY2xpZW50Ll9wYWNrZXQocGFja2V0LCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSm9pbnMgYSByb29tLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgLy8gam9pbiBhIHNpbmdsZSByb29tXG4gICAgICogICBzb2NrZXQuam9pbihcInJvb20xXCIpO1xuICAgICAqXG4gICAgICogICAvLyBqb2luIG11bHRpcGxlIHJvb21zXG4gICAgICogICBzb2NrZXQuam9pbihbXCJyb29tMVwiLCBcInJvb20yXCJdKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSByb29tcyAtIHJvb20gb3IgYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgUHJvbWlzZSBvciBub3RoaW5nLCBkZXBlbmRpbmcgb24gdGhlIGFkYXB0ZXJcbiAgICAgKi9cbiAgICBqb2luKHJvb21zKSB7XG4gICAgICAgIGRlYnVnKFwiam9pbiByb29tICVzXCIsIHJvb21zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlci5hZGRBbGwodGhpcy5pZCwgbmV3IFNldChBcnJheS5pc0FycmF5KHJvb21zKSA/IHJvb21zIDogW3Jvb21zXSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZWF2ZXMgYSByb29tLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgLy8gbGVhdmUgYSBzaW5nbGUgcm9vbVxuICAgICAqICAgc29ja2V0LmxlYXZlKFwicm9vbTFcIik7XG4gICAgICpcbiAgICAgKiAgIC8vIGxlYXZlIG11bHRpcGxlIHJvb21zXG4gICAgICogICBzb2NrZXQubGVhdmUoXCJyb29tMVwiKS5sZWF2ZShcInJvb20yXCIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJvb21cbiAgICAgKiBAcmV0dXJuIGEgUHJvbWlzZSBvciBub3RoaW5nLCBkZXBlbmRpbmcgb24gdGhlIGFkYXB0ZXJcbiAgICAgKi9cbiAgICBsZWF2ZShyb29tKSB7XG4gICAgICAgIGRlYnVnKFwibGVhdmUgcm9vbSAlc1wiLCByb29tKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlci5kZWwodGhpcy5pZCwgcm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlYXZlIGFsbCByb29tcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbGVhdmVBbGwoKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlci5kZWxBbGwodGhpcy5pZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCBieSBgTmFtZXNwYWNlYCB1cG9uIHN1Y2Nlc3NmdWxcbiAgICAgKiBtaWRkbGV3YXJlIGV4ZWN1dGlvbiAoaWU6IGF1dGhvcml6YXRpb24pLlxuICAgICAqIFNvY2tldCBpcyBhZGRlZCB0byBuYW1lc3BhY2UgYXJyYXkgYmVmb3JlXG4gICAgICogY2FsbCB0byBqb2luLCBzbyBhZGFwdGVycyBjYW4gYWNjZXNzIGl0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25jb25uZWN0KCkge1xuICAgICAgICBkZWJ1ZyhcInNvY2tldCBjb25uZWN0ZWQgLSB3cml0aW5nIHBhY2tldFwiKTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmpvaW4odGhpcy5pZCk7XG4gICAgICAgIGlmICh0aGlzLmNvbm4ucHJvdG9jb2wgPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMucGFja2V0KHsgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQ09OTkVDVCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFja2V0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNULFxuICAgICAgICAgICAgICAgIGRhdGE6IHsgc2lkOiB0aGlzLmlkLCBwaWQ6IHRoaXMucGlkIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBlYWNoIHBhY2tldC4gQ2FsbGVkIGJ5IGBDbGllbnRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29ucGFja2V0KHBhY2tldCkge1xuICAgICAgICBkZWJ1ZyhcImdvdCBwYWNrZXQgJWpcIiwgcGFja2V0KTtcbiAgICAgICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5FVkVOVDpcbiAgICAgICAgICAgICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQklOQVJZX0VWRU5UOlxuICAgICAgICAgICAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5BQ0s6XG4gICAgICAgICAgICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5CSU5BUllfQUNLOlxuICAgICAgICAgICAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRElTQ09OTkVDVDpcbiAgICAgICAgICAgICAgICB0aGlzLm9uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGV2ZW50IHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFja2V0fSBwYWNrZXQgLSBwYWNrZXQgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmV2ZW50KHBhY2tldCkge1xuICAgICAgICBjb25zdCBhcmdzID0gcGFja2V0LmRhdGEgfHwgW107XG4gICAgICAgIGRlYnVnKFwiZW1pdHRpbmcgZXZlbnQgJWpcIiwgYXJncyk7XG4gICAgICAgIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuICAgICAgICAgICAgZGVidWcoXCJhdHRhY2hpbmcgYWNrIGNhbGxiYWNrIHRvIGV2ZW50XCIpO1xuICAgICAgICAgICAgYXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hbnlMaXN0ZW5lcnMgJiYgdGhpcy5fYW55TGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fYW55TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWQgLSBwYWNrZXQgaWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFjayhpZCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IHNlbnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuICAgICAgICAgICAgaWYgKHNlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBkZWJ1ZyhcInNlbmRpbmcgYWNrICVqXCIsIGFyZ3MpO1xuICAgICAgICAgICAgc2VsZi5wYWNrZXQoe1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5BQ0ssXG4gICAgICAgICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VudCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGFjayBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uYWNrKHBhY2tldCkge1xuICAgICAgICBjb25zdCBhY2sgPSB0aGlzLmFja3MuZ2V0KHBhY2tldC5pZCk7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGFjaykge1xuICAgICAgICAgICAgZGVidWcoXCJjYWxsaW5nIGFjayAlcyB3aXRoICVqXCIsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgYWNrLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMuYWNrcy5kZWxldGUocGFja2V0LmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKFwiYmFkIGFjayAlc1wiLCBwYWNrZXQuaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGNsaWVudCBkaXNjb25uZWN0IHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25kaXNjb25uZWN0KCkge1xuICAgICAgICBkZWJ1ZyhcImdvdCBkaXNjb25uZWN0IHBhY2tldFwiKTtcbiAgICAgICAgdGhpcy5fb25jbG9zZShcImNsaWVudCBuYW1lc3BhY2UgZGlzY29ubmVjdFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhIGNsaWVudCBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uZXJyb3IoZXJyKSB7XG4gICAgICAgIC8vIEZJWE1FIHRoZSBtZWFuaW5nIG9mIHRoZSBcImVycm9yXCIgZXZlbnQgaXMgb3ZlcmxvYWRlZDpcbiAgICAgICAgLy8gIC0gaXQgY2FuIGJlIHNlbnQgYnkgdGhlIGNsaWVudCAoYHNvY2tldC5lbWl0KFwiZXJyb3JcIilgKVxuICAgICAgICAvLyAgLSBpdCBjYW4gYmUgZW1pdHRlZCB3aGVuIHRoZSBjb25uZWN0aW9uIGVuY291bnRlcnMgYW4gZXJyb3IgKGFuIGludmFsaWQgcGFja2V0IGZvciBleGFtcGxlKVxuICAgICAgICAvLyAgLSBpdCBjYW4gYmUgZW1pdHRlZCB3aGVuIGEgcGFja2V0IGlzIHJlamVjdGVkIGluIGEgbWlkZGxld2FyZSAoYHNvY2tldC51c2UoKWApXG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgZXJyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gY2xvc2luZy4gQ2FsbGVkIGJ5IGBDbGllbnRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvblxuICAgICAqIEB0aHJvdyB7RXJyb3J9IG9wdGlvbmFsIGVycm9yIG9iamVjdFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25jbG9zZShyZWFzb24sIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgZGVidWcoXCJjbG9zaW5nIHNvY2tldCAtIHJlYXNvbiAlc1wiLCByZWFzb24pO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRpc2Nvbm5lY3RpbmdcIiwgcmVhc29uLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIGlmICh0aGlzLnNlcnZlci5fb3B0cy5jb25uZWN0aW9uU3RhdGVSZWNvdmVyeSAmJlxuICAgICAgICAgICAgUkVDT1ZFUkFCTEVfRElTQ09OTkVDVF9SRUFTT05TLmhhcyhyZWFzb24pKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gc3RhdGUgcmVjb3ZlcnkgaXMgZW5hYmxlZCBmb3Igc2lkICVzXCIsIHRoaXMuaWQpO1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnBlcnNpc3RTZXNzaW9uKHtcbiAgICAgICAgICAgICAgICBzaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgcGlkOiB0aGlzLnBpZCxcbiAgICAgICAgICAgICAgICByb29tczogWy4uLnRoaXMucm9vbXNdLFxuICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgdGhpcy5jbGllbnQuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJkaXNjb25uZWN0XCIsIHJlYXNvbiwgZGVzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBzb2NrZXQgbGVhdmUgYWxsIHRoZSByb29tcyBpdCB3YXMgcGFydCBvZiBhbmQgcHJldmVudHMgaXQgZnJvbSBqb2luaW5nIGFueSBvdGhlciByb29tXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jbGVhbnVwKCkge1xuICAgICAgICB0aGlzLmxlYXZlQWxsKCk7XG4gICAgICAgIHRoaXMubnNwLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMuam9pbiA9IG5vb3A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGFuIGBlcnJvcmAgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVyciAtIGVycm9yIG9iamVjdFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZXJyb3IoZXJyKSB7XG4gICAgICAgIHRoaXMucGFja2V0KHsgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQ09OTkVDVF9FUlJPUiwgZGF0YTogZXJyIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyB0aGlzIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIC8vIGRpc2Nvbm5lY3QgdGhpcyBzb2NrZXQgKHRoZSBjb25uZWN0aW9uIG1pZ2h0IGJlIGtlcHQgYWxpdmUgZm9yIG90aGVyIG5hbWVzcGFjZXMpXG4gICAgICogICBzb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgICAqXG4gICAgICogICAvLyBkaXNjb25uZWN0IHRoaXMgc29ja2V0IGFuZCBjbG9zZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uXG4gICAgICogICBzb2NrZXQuZGlzY29ubmVjdCh0cnVlKTtcbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjbG9zZSAtIGlmIGB0cnVlYCwgY2xvc2VzIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25cbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KGNsb3NlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoY2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50Ll9kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkRJU0NPTk5FQ1QgfSk7XG4gICAgICAgICAgICB0aGlzLl9vbmNsb3NlKFwic2VydmVyIG5hbWVzcGFjZSBkaXNjb25uZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgc29ja2V0LmNvbXByZXNzKGZhbHNlKS5lbWl0KFwiaGVsbG9cIik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbXByZXNzIC0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAgICAgKi9cbiAgICBjb21wcmVzcyhjb21wcmVzcykge1xuICAgICAgICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIG1heSBiZSBsb3N0IGlmIHRoZSBjbGllbnQgaXMgbm90IHJlYWR5IHRvXG4gICAgICogcmVjZWl2ZSBtZXNzYWdlcyAoYmVjYXVzZSBvZiBuZXR3b3JrIHNsb3duZXNzIG9yIG90aGVyIGlzc3Vlcywgb3IgYmVjYXVzZSB0aGV54oCZcmUgY29ubmVjdGVkIHRocm91Z2ggbG9uZyBwb2xsaW5nXG4gICAgICogYW5kIGlzIGluIHRoZSBtaWRkbGUgb2YgYSByZXF1ZXN0LXJlc3BvbnNlIGN5Y2xlKS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIHNvY2tldC52b2xhdGlsZS5lbWl0KFwiaGVsbG9cIik7IC8vIHRoZSBjbGllbnQgbWF5IG9yIG1heSBub3QgcmVjZWl2ZSBpdFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gICAgICovXG4gICAgZ2V0IHZvbGF0aWxlKCkge1xuICAgICAgICB0aGlzLmZsYWdzLnZvbGF0aWxlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IGRhdGEgd2lsbCBvbmx5IGJlIGJyb2FkY2FzdCB0byBldmVyeSBzb2NrZXRzIGJ1dCB0aGVcbiAgICAgKiBzZW5kZXIuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cywgZXhjZXB0IHRoaXMgc29ja2V0XG4gICAgICogICBzb2NrZXQuYnJvYWRjYXN0LmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZ2V0IGJyb2FkY2FzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3QnJvYWRjYXN0T3BlcmF0b3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSB3aWxsIG9ubHkgYmUgYnJvYWRjYXN0IHRvIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cyBvbiB0aGlzIG5vZGUsIGV4Y2VwdCB0aGlzIHNvY2tldFxuICAgICAqICAgc29ja2V0LmxvY2FsLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZ2V0IGxvY2FsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdCcm9hZGNhc3RPcGVyYXRvcigpLmxvY2FsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIGFuIGVycm9yIHdoZW4gdGhlXG4gICAgICogZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgd2l0aG91dCBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSB0aGUgY2xpZW50OlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgc29ja2V0LnRpbWVvdXQoNTAwMCkuZW1pdChcIm15LWV2ZW50XCIsIChlcnIpID0+IHtcbiAgICAgKiAgICAgaWYgKGVycikge1xuICAgICAqICAgICAgIC8vIHRoZSBjbGllbnQgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogICAgIH1cbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHJldHVybnMgc2VsZlxuICAgICAqL1xuICAgIHRpbWVvdXQodGltZW91dCkge1xuICAgICAgICB0aGlzLmZsYWdzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2ggaW5jb21pbmcgZXZlbnQgdG8gc29ja2V0IGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGV2ZW50IC0gZXZlbnQgdGhhdCB3aWxsIGdldCBlbWl0dGVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkaXNwYXRjaChldmVudCkge1xuICAgICAgICBkZWJ1ZyhcImRpc3BhdGNoaW5nIGFuIGV2ZW50ICVqXCIsIGV2ZW50KTtcbiAgICAgICAgdGhpcy5ydW4oZXZlbnQsIChlcnIpID0+IHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyLmVtaXRVbnR5cGVkLmFwcGx5KHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiaWdub3JlIHBhY2tldCByZWNlaXZlZCBhZnRlciBkaXNjb25uZWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBzb2NrZXQgbWlkZGxld2FyZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIHNvY2tldC51c2UoKFtldmVudCwgLi4uYXJnc10sIG5leHQpID0+IHtcbiAgICAgKiAgICAgaWYgKGlzVW5hdXRob3JpemVkKGV2ZW50KSkge1xuICAgICAqICAgICAgIHJldHVybiBuZXh0KG5ldyBFcnJvcihcInVuYXV0aG9yaXplZCBldmVudFwiKSk7XG4gICAgICogICAgIH1cbiAgICAgKiAgICAgLy8gZG8gbm90IGZvcmdldCB0byBjYWxsIG5leHRcbiAgICAgKiAgICAgbmV4dCgpO1xuICAgICAqICAgfSk7XG4gICAgICpcbiAgICAgKiAgIHNvY2tldC5vbihcImVycm9yXCIsIChlcnIpID0+IHtcbiAgICAgKiAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gXCJ1bmF1dGhvcml6ZWQgZXZlbnRcIikge1xuICAgICAqICAgICAgIHNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICogICAgIH1cbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBtaWRkbGV3YXJlIGZ1bmN0aW9uIChldmVudCwgbmV4dClcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAgICAgKi9cbiAgICB1c2UoZm4pIHtcbiAgICAgICAgdGhpcy5mbnMucHVzaChmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgbWlkZGxld2FyZSBmb3IgYW4gaW5jb21pbmcgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBldmVudCAtIGV2ZW50IHRoYXQgd2lsbCBnZXQgZW1pdHRlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gbGFzdCBmbiBjYWxsIGluIHRoZSBtaWRkbGV3YXJlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBydW4oZXZlbnQsIGZuKSB7XG4gICAgICAgIGlmICghdGhpcy5mbnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgIGNvbnN0IGZucyA9IHRoaXMuZm5zLnNsaWNlKDApO1xuICAgICAgICBmdW5jdGlvbiBydW4oaSkge1xuICAgICAgICAgICAgZm5zW2ldKGV2ZW50LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdXBvbiBlcnJvciwgc2hvcnQtY2lyY3VpdFxuICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihlcnIpO1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vIG1pZGRsZXdhcmUgbGVmdCwgc3VtbW9uIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgaWYgKCFmbnNbaSArIDFdKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgICAgICAgICAvLyBnbyBvbiB0byBuZXh0XG4gICAgICAgICAgICAgICAgcnVuKGkgKyAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJ1bigwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgc29ja2V0IGlzIGN1cnJlbnRseSBkaXNjb25uZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29ubmVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgcmVxdWVzdCB0aGF0IG9yaWdpbmF0ZWQgdGhlIHVuZGVybHlpbmcgRW5naW5lLklPIFNvY2tldC5cbiAgICAgKi9cbiAgICBnZXQgcmVxdWVzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSB1bmRlcmx5aW5nIENsaWVudCB0cmFuc3BvcnQgY29ubmVjdGlvbiAoRW5naW5lLklPIFNvY2tldCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmNvbm4udHJhbnNwb3J0Lm5hbWUpOyAvLyBwcmludHMgXCJwb2xsaW5nXCIgb3IgXCJ3ZWJzb2NrZXRcIlxuICAgICAqXG4gICAgICogICBzb2NrZXQuY29ubi5vbmNlKFwidXBncmFkZVwiLCAoKSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHNvY2tldC5jb25uLnRyYW5zcG9ydC5uYW1lKTsgLy8gcHJpbnRzIFwid2Vic29ja2V0XCJcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGdldCBjb25uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY29ubjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcm9vbXMgdGhlIHNvY2tldCBpcyBjdXJyZW50bHkgaW4uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQucm9vbXMpOyAvLyBTZXQgeyA8c29ja2V0LmlkPiB9XG4gICAgICpcbiAgICAgKiAgIHNvY2tldC5qb2luKFwicm9vbTFcIik7XG4gICAgICpcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5yb29tcyk7IC8vIFNldCB7IDxzb2NrZXQuaWQ+LCBcInJvb20xXCIgfVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGdldCByb29tcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlci5zb2NrZXRSb29tcyh0aGlzLmlkKSB8fCBuZXcgU2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgcmVjZWl2ZWQuIFRoZSBldmVudCBuYW1lIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG9cbiAgICAgKiB0aGUgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBzb2NrZXQub25BbnkoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGBnb3QgZXZlbnQgJHtldmVudH1gKTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgb25BbnkobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fYW55TGlzdGVuZXJzID0gdGhpcy5fYW55TGlzdGVuZXJzIHx8IFtdO1xuICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIHJlY2VpdmVkLiBUaGUgZXZlbnQgbmFtZSBpcyBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvXG4gICAgICogdGhlIGNhbGxiYWNrLiBUaGUgbGlzdGVuZXIgaXMgYWRkZWQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdGVuZXJzIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgcHJlcGVuZEFueShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnMgfHwgW107XG4gICAgICAgIHRoaXMuX2FueUxpc3RlbmVycy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyByZWNlaXZlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIGNvbnN0IGNhdGNoQWxsTGlzdGVuZXIgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYGdvdCBldmVudCAke2V2ZW50fWApO1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogICBzb2NrZXQub25BbnkoY2F0Y2hBbGxMaXN0ZW5lcik7XG4gICAgICpcbiAgICAgKiAgIC8vIHJlbW92ZSBhIHNwZWNpZmljIGxpc3RlbmVyXG4gICAgICogICBzb2NrZXQub2ZmQW55KGNhdGNoQWxsTGlzdGVuZXIpO1xuICAgICAqXG4gICAgICogICAvLyBvciByZW1vdmUgYWxsIGxpc3RlbmVyc1xuICAgICAqICAgc29ja2V0Lm9mZkFueSgpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgb2ZmQW55KGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5fYW55TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2FueUxpc3RlbmVycztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyID09PSBsaXN0ZW5lcnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYW55TGlzdGVuZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRoYXQgYXJlIGxpc3RlbmluZyBmb3IgYW55IGV2ZW50IHRoYXQgaXMgc3BlY2lmaWVkLiBUaGlzIGFycmF5IGNhbiBiZSBtYW5pcHVsYXRlZCxcbiAgICAgKiBlLmcuIHRvIHJlbW92ZSBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgbGlzdGVuZXJzQW55KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW55TGlzdGVuZXJzIHx8IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIHNlbnQuIFRoZSBldmVudCBuYW1lIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG9cbiAgICAgKiB0aGUgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBOb3RlOiBhY2tub3dsZWRnZW1lbnRzIHNlbnQgdG8gdGhlIGNsaWVudCBhcmUgbm90IGluY2x1ZGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgc29ja2V0Lm9uQW55T3V0Z29pbmcoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGBzZW50IGV2ZW50ICR7ZXZlbnR9YCk7XG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqL1xuICAgIG9uQW55T3V0Z29pbmcobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMgPSB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIGVtaXR0ZWQuIFRoZSBldmVudCBuYW1lIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlXG4gICAgICogY2FsbGJhY2suIFRoZSBsaXN0ZW5lciBpcyBhZGRlZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBzb2NrZXQucHJlcGVuZEFueU91dGdvaW5nKChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhgc2VudCBldmVudCAke2V2ZW50fWApO1xuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBwcmVwZW5kQW55T3V0Z29pbmcobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMgPSB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgc2VudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIGNvbnN0IGNhdGNoQWxsTGlzdGVuZXIgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYHNlbnQgZXZlbnQgJHtldmVudH1gKTtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqICAgc29ja2V0Lm9uQW55T3V0Z29pbmcoY2F0Y2hBbGxMaXN0ZW5lcik7XG4gICAgICpcbiAgICAgKiAgIC8vIHJlbW92ZSBhIHNwZWNpZmljIGxpc3RlbmVyXG4gICAgICogICBzb2NrZXQub2ZmQW55T3V0Z29pbmcoY2F0Y2hBbGxMaXN0ZW5lcik7XG4gICAgICpcbiAgICAgKiAgIC8vIG9yIHJlbW92ZSBhbGwgbGlzdGVuZXJzXG4gICAgICogICBzb2NrZXQub2ZmQW55T3V0Z29pbmcoKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIHRoZSBjYXRjaC1hbGwgbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvZmZBbnlPdXRnb2luZyhsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIXRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIgPT09IGxpc3RlbmVyc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0aGF0IGFyZSBsaXN0ZW5pbmcgZm9yIGFueSBldmVudCB0aGF0IGlzIHNwZWNpZmllZC4gVGhpcyBhcnJheSBjYW4gYmUgbWFuaXB1bGF0ZWQsXG4gICAgICogZS5nLiB0byByZW1vdmUgbGlzdGVuZXJzLlxuICAgICAqL1xuICAgIGxpc3RlbmVyc0FueU91dGdvaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMgfHwgW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmeSB0aGUgbGlzdGVuZXJzIGZvciBlYWNoIHBhY2tldCBzZW50IChlbWl0IG9yIGJyb2FkY2FzdClcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWNrZXRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbm90aWZ5T3V0Z29pbmdMaXN0ZW5lcnMocGFja2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyAmJiB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXdCcm9hZGNhc3RPcGVyYXRvcigpIHtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZsYWdzKTtcbiAgICAgICAgdGhpcy5mbGFncyA9IHt9O1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlciwgbmV3IFNldCgpLCBuZXcgU2V0KFt0aGlzLmlkXSksIGZsYWdzKTtcbiAgICB9XG59XG5leHBvcnRzLlNvY2tldCA9IFNvY2tldDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/socket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/typed-events.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io/dist/typed-events.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StrictEventEmitter = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\n/**\n * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type\n * parameters for mappings of event names to event data types, and strictly\n * types method calls to the `EventEmitter` according to these event maps.\n *\n * @typeParam ListenEvents - `EventsMap` of user-defined events that can be\n * listened to with `on` or `once`\n * @typeParam EmitEvents - `EventsMap` of user-defined events that can be\n * emitted with `emit`\n * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be\n * emitted by socket.io with `emitReserved`, and can be listened to with\n * `listen`.\n */\nclass StrictEventEmitter extends events_1.EventEmitter {\n    /**\n     * Adds the `listener` function as an event listener for `ev`.\n     *\n     * @param ev Name of the event\n     * @param listener Callback function\n     */\n    on(ev, listener) {\n        return super.on(ev, listener);\n    }\n    /**\n     * Adds a one-time `listener` function as an event listener for `ev`.\n     *\n     * @param ev Name of the event\n     * @param listener Callback function\n     */\n    once(ev, listener) {\n        return super.once(ev, listener);\n    }\n    /**\n     * Emits an event.\n     *\n     * @param ev Name of the event\n     * @param args Values to send to listeners of this event\n     */\n    emit(ev, ...args) {\n        return super.emit(ev, ...args);\n    }\n    /**\n     * Emits a reserved event.\n     *\n     * This method is `protected`, so that only a class extending\n     * `StrictEventEmitter` can emit its own reserved events.\n     *\n     * @param ev Reserved event name\n     * @param args Arguments to emit along with the event\n     */\n    emitReserved(ev, ...args) {\n        return super.emit(ev, ...args);\n    }\n    /**\n     * Emits an event.\n     *\n     * This method is `protected`, so that only a class extending\n     * `StrictEventEmitter` can get around the strict typing. This is useful for\n     * calling `emit.apply`, which can be called as `emitUntyped.apply`.\n     *\n     * @param ev Event name\n     * @param args Arguments to emit along with the event\n     */\n    emitUntyped(ev, ...args) {\n        return super.emit(ev, ...args);\n    }\n    /**\n     * Returns the listeners listening to an event.\n     *\n     * @param event Event name\n     * @returns Array of listeners subscribed to `event`\n     */\n    listeners(event) {\n        return super.listeners(event);\n    }\n}\nexports.StrictEventEmitter = StrictEventEmitter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvdHlwZWQtZXZlbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQixpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcnNvbGUvRG9jdW1lbnRzL0dpdEh1Yi9tYXNzaW1pbm8vbWFzc2ltaW5vL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC90eXBlZC1ldmVudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0cmljdEV2ZW50RW1pdHRlciA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbi8qKlxuICogU3RyaWN0bHkgdHlwZWQgdmVyc2lvbiBvZiBhbiBgRXZlbnRFbWl0dGVyYC4gQSBgVHlwZWRFdmVudEVtaXR0ZXJgIHRha2VzIHR5cGVcbiAqIHBhcmFtZXRlcnMgZm9yIG1hcHBpbmdzIG9mIGV2ZW50IG5hbWVzIHRvIGV2ZW50IGRhdGEgdHlwZXMsIGFuZCBzdHJpY3RseVxuICogdHlwZXMgbWV0aG9kIGNhbGxzIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBhY2NvcmRpbmcgdG8gdGhlc2UgZXZlbnQgbWFwcy5cbiAqXG4gKiBAdHlwZVBhcmFtIExpc3RlbkV2ZW50cyAtIGBFdmVudHNNYXBgIG9mIHVzZXItZGVmaW5lZCBldmVudHMgdGhhdCBjYW4gYmVcbiAqIGxpc3RlbmVkIHRvIHdpdGggYG9uYCBvciBgb25jZWBcbiAqIEB0eXBlUGFyYW0gRW1pdEV2ZW50cyAtIGBFdmVudHNNYXBgIG9mIHVzZXItZGVmaW5lZCBldmVudHMgdGhhdCBjYW4gYmVcbiAqIGVtaXR0ZWQgd2l0aCBgZW1pdGBcbiAqIEB0eXBlUGFyYW0gUmVzZXJ2ZWRFdmVudHMgLSBgRXZlbnRzTWFwYCBvZiByZXNlcnZlZCBldmVudHMsIHRoYXQgY2FuIGJlXG4gKiBlbWl0dGVkIGJ5IHNvY2tldC5pbyB3aXRoIGBlbWl0UmVzZXJ2ZWRgLCBhbmQgY2FuIGJlIGxpc3RlbmVkIHRvIHdpdGhcbiAqIGBsaXN0ZW5gLlxuICovXG5jbGFzcyBTdHJpY3RFdmVudEVtaXR0ZXIgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGBsaXN0ZW5lcmAgZnVuY3Rpb24gYXMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGBldmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgTmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBvbihldiwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLm9uKGV2LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBvbmUtdGltZSBgbGlzdGVuZXJgIGZ1bmN0aW9uIGFzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciBgZXZgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2IE5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIGxpc3RlbmVyIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICovXG4gICAgb25jZShldiwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLm9uY2UoZXYsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgTmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0gYXJncyBWYWx1ZXMgdG8gc2VuZCB0byBsaXN0ZW5lcnMgb2YgdGhpcyBldmVudFxuICAgICAqL1xuICAgIGVtaXQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhIHJlc2VydmVkIGV2ZW50LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgYHByb3RlY3RlZGAsIHNvIHRoYXQgb25seSBhIGNsYXNzIGV4dGVuZGluZ1xuICAgICAqIGBTdHJpY3RFdmVudEVtaXR0ZXJgIGNhbiBlbWl0IGl0cyBvd24gcmVzZXJ2ZWQgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2IFJlc2VydmVkIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0gYXJncyBBcmd1bWVudHMgdG8gZW1pdCBhbG9uZyB3aXRoIHRoZSBldmVudFxuICAgICAqL1xuICAgIGVtaXRSZXNlcnZlZChldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldiwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgYHByb3RlY3RlZGAsIHNvIHRoYXQgb25seSBhIGNsYXNzIGV4dGVuZGluZ1xuICAgICAqIGBTdHJpY3RFdmVudEVtaXR0ZXJgIGNhbiBnZXQgYXJvdW5kIHRoZSBzdHJpY3QgdHlwaW5nLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICAgKiBjYWxsaW5nIGBlbWl0LmFwcGx5YCwgd2hpY2ggY2FuIGJlIGNhbGxlZCBhcyBgZW1pdFVudHlwZWQuYXBwbHlgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2IEV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0gYXJncyBBcmd1bWVudHMgdG8gZW1pdCBhbG9uZyB3aXRoIHRoZSBldmVudFxuICAgICAqL1xuICAgIGVtaXRVbnR5cGVkKGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCBFdmVudCBuYW1lXG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgbGlzdGVuZXJzIHN1YnNjcmliZWQgdG8gYGV2ZW50YFxuICAgICAqL1xuICAgIGxpc3RlbmVycyhldmVudCkge1xuICAgICAgICByZXR1cm4gc3VwZXIubGlzdGVuZXJzKGV2ZW50KTtcbiAgICB9XG59XG5leHBvcnRzLlN0cmljdEV2ZW50RW1pdHRlciA9IFN0cmljdEV2ZW50RW1pdHRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/typed-events.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/uws.js":
/*!********************************************!*\
  !*** ./node_modules/socket.io/dist/uws.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.patchAdapter = patchAdapter;\nexports.restoreAdapter = restoreAdapter;\nexports.serveFile = serveFile;\nconst socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/index.js\");\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst debug = (0, debug_1.default)(\"socket.io:adapter-uws\");\nconst SEPARATOR = \"\\x1f\"; // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nconst { addAll, del, broadcast } = socket_io_adapter_1.Adapter.prototype;\nfunction patchAdapter(app /* : TemplatedApp */) {\n    socket_io_adapter_1.Adapter.prototype.addAll = function (id, rooms) {\n        const isNew = !this.sids.has(id);\n        addAll.call(this, id, rooms);\n        const socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);\n        if (!socket) {\n            return;\n        }\n        if (socket.conn.transport.name === \"websocket\") {\n            subscribe(this.nsp.name, socket, isNew, rooms);\n            return;\n        }\n        if (isNew) {\n            socket.conn.on(\"upgrade\", () => {\n                const rooms = this.sids.get(id);\n                if (rooms) {\n                    subscribe(this.nsp.name, socket, isNew, rooms);\n                }\n            });\n        }\n    };\n    socket_io_adapter_1.Adapter.prototype.del = function (id, room) {\n        del.call(this, id, room);\n        const socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);\n        if (socket && socket.conn.transport.name === \"websocket\") {\n            // @ts-ignore\n            const sessionId = socket.conn.id;\n            // @ts-ignore\n            const websocket = socket.conn.transport.socket;\n            const topic = `${this.nsp.name}${SEPARATOR}${room}`;\n            debug(\"unsubscribe connection %s from topic %s\", sessionId, topic);\n            websocket.unsubscribe(topic);\n        }\n    };\n    socket_io_adapter_1.Adapter.prototype.broadcast = function (packet, opts) {\n        const useFastPublish = opts.rooms.size <= 1 && opts.except.size === 0;\n        if (!useFastPublish) {\n            broadcast.call(this, packet, opts);\n            return;\n        }\n        const flags = opts.flags || {};\n        const basePacketOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress,\n        };\n        packet.nsp = this.nsp.name;\n        const encodedPackets = this.encoder.encode(packet);\n        const topic = opts.rooms.size === 0\n            ? this.nsp.name\n            : `${this.nsp.name}${SEPARATOR}${opts.rooms.keys().next().value}`;\n        debug(\"fast publish to %s\", topic);\n        // fast publish for clients connected with WebSocket\n        encodedPackets.forEach((encodedPacket) => {\n            const isBinary = typeof encodedPacket !== \"string\";\n            // \"4\" being the message type in the Engine.IO protocol, see https://github.com/socketio/engine.io-protocol\n            app.publish(topic, isBinary ? encodedPacket : \"4\" + encodedPacket, isBinary);\n        });\n        this.apply(opts, (socket) => {\n            if (socket.conn.transport.name !== \"websocket\") {\n                // classic publish for clients connected with HTTP long-polling\n                socket.client.writeToEngine(encodedPackets, basePacketOpts);\n            }\n        });\n    };\n}\nfunction subscribe(namespaceName, socket, isNew, rooms) {\n    // @ts-ignore\n    const sessionId = socket.conn.id;\n    // @ts-ignore\n    const websocket = socket.conn.transport.socket;\n    if (isNew) {\n        debug(\"subscribe connection %s to topic %s\", sessionId, namespaceName);\n        websocket.subscribe(namespaceName);\n    }\n    rooms.forEach((room) => {\n        const topic = `${namespaceName}${SEPARATOR}${room}`; // '#' can be used as wildcard\n        debug(\"subscribe connection %s to topic %s\", sessionId, topic);\n        websocket.subscribe(topic);\n    });\n}\nfunction restoreAdapter() {\n    socket_io_adapter_1.Adapter.prototype.addAll = addAll;\n    socket_io_adapter_1.Adapter.prototype.del = del;\n    socket_io_adapter_1.Adapter.prototype.broadcast = broadcast;\n}\nconst toArrayBuffer = (buffer) => {\n    const { buffer: arrayBuffer, byteOffset, byteLength } = buffer;\n    return arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n};\n// imported from https://github.com/kolodziejczak-sz/uwebsocket-serve\nfunction serveFile(res /* : HttpResponse */, filepath) {\n    const { size } = (0, fs_1.statSync)(filepath);\n    const readStream = (0, fs_1.createReadStream)(filepath);\n    const destroyReadStream = () => !readStream.destroyed && readStream.destroy();\n    const onError = (error) => {\n        destroyReadStream();\n        throw error;\n    };\n    const onDataChunk = (chunk) => {\n        const arrayBufferChunk = toArrayBuffer(chunk);\n        res.cork(() => {\n            const lastOffset = res.getWriteOffset();\n            const [ok, done] = res.tryEnd(arrayBufferChunk, size);\n            if (!done && !ok) {\n                readStream.pause();\n                res.onWritable((offset) => {\n                    const [ok, done] = res.tryEnd(arrayBufferChunk.slice(offset - lastOffset), size);\n                    if (!done && ok) {\n                        readStream.resume();\n                    }\n                    return ok;\n                });\n            }\n        });\n    };\n    res.onAborted(destroyReadStream);\n    readStream\n        .on(\"data\", onDataChunk)\n        .on(\"error\", onError)\n        .on(\"end\", destroyReadStream);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvdXdzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLHNCQUFzQjtBQUN0QixpQkFBaUI7QUFDakIsNEJBQTRCLG1CQUFPLENBQUMsK0VBQW1CO0FBQ3ZELGFBQWEsbUJBQU8sQ0FBQyxjQUFJO0FBQ3pCLGdDQUFnQyxtQkFBTyxDQUFDLDZFQUFPO0FBQy9DO0FBQ0EsMEJBQTBCO0FBQzFCLFFBQVEseUJBQXlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjLEVBQUUsVUFBVSxFQUFFLEtBQUs7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjLEVBQUUsVUFBVSxFQUFFLCtCQUErQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYyxFQUFFLFVBQVUsRUFBRSxLQUFLLEdBQUc7QUFDN0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yc29sZS9Eb2N1bWVudHMvR2l0SHViL21hc3NpbWluby9tYXNzaW1pbm8vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9kaXN0L3V3cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGF0Y2hBZGFwdGVyID0gcGF0Y2hBZGFwdGVyO1xuZXhwb3J0cy5yZXN0b3JlQWRhcHRlciA9IHJlc3RvcmVBZGFwdGVyO1xuZXhwb3J0cy5zZXJ2ZUZpbGUgPSBzZXJ2ZUZpbGU7XG5jb25zdCBzb2NrZXRfaW9fYWRhcHRlcl8xID0gcmVxdWlyZShcInNvY2tldC5pby1hZGFwdGVyXCIpO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJzb2NrZXQuaW86YWRhcHRlci11d3NcIik7XG5jb25zdCBTRVBBUkFUT1IgPSBcIlxceDFmXCI7IC8vIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EZWxpbWl0ZXIjQVNDSUlfZGVsaW1pdGVkX3RleHRcbmNvbnN0IHsgYWRkQWxsLCBkZWwsIGJyb2FkY2FzdCB9ID0gc29ja2V0X2lvX2FkYXB0ZXJfMS5BZGFwdGVyLnByb3RvdHlwZTtcbmZ1bmN0aW9uIHBhdGNoQWRhcHRlcihhcHAgLyogOiBUZW1wbGF0ZWRBcHAgKi8pIHtcbiAgICBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIucHJvdG90eXBlLmFkZEFsbCA9IGZ1bmN0aW9uIChpZCwgcm9vbXMpIHtcbiAgICAgICAgY29uc3QgaXNOZXcgPSAhdGhpcy5zaWRzLmhhcyhpZCk7XG4gICAgICAgIGFkZEFsbC5jYWxsKHRoaXMsIGlkLCByb29tcyk7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubnNwLnNvY2tldHMuZ2V0KGlkKSB8fCB0aGlzLm5zcC5fcHJlQ29ubmVjdFNvY2tldHMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKCFzb2NrZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc29ja2V0LmNvbm4udHJhbnNwb3J0Lm5hbWUgPT09IFwid2Vic29ja2V0XCIpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZSh0aGlzLm5zcC5uYW1lLCBzb2NrZXQsIGlzTmV3LCByb29tcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmV3KSB7XG4gICAgICAgICAgICBzb2NrZXQuY29ubi5vbihcInVwZ3JhZGVcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvb21zID0gdGhpcy5zaWRzLmdldChpZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJvb21zKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZSh0aGlzLm5zcC5uYW1lLCBzb2NrZXQsIGlzTmV3LCByb29tcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlci5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24gKGlkLCByb29tKSB7XG4gICAgICAgIGRlbC5jYWxsKHRoaXMsIGlkLCByb29tKTtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5uc3Auc29ja2V0cy5nZXQoaWQpIHx8IHRoaXMubnNwLl9wcmVDb25uZWN0U29ja2V0cy5nZXQoaWQpO1xuICAgICAgICBpZiAoc29ja2V0ICYmIHNvY2tldC5jb25uLnRyYW5zcG9ydC5uYW1lID09PSBcIndlYnNvY2tldFwiKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSBzb2NrZXQuY29ubi5pZDtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHdlYnNvY2tldCA9IHNvY2tldC5jb25uLnRyYW5zcG9ydC5zb2NrZXQ7XG4gICAgICAgICAgICBjb25zdCB0b3BpYyA9IGAke3RoaXMubnNwLm5hbWV9JHtTRVBBUkFUT1J9JHtyb29tfWA7XG4gICAgICAgICAgICBkZWJ1ZyhcInVuc3Vic2NyaWJlIGNvbm5lY3Rpb24gJXMgZnJvbSB0b3BpYyAlc1wiLCBzZXNzaW9uSWQsIHRvcGljKTtcbiAgICAgICAgICAgIHdlYnNvY2tldC51bnN1YnNjcmliZSh0b3BpYyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlci5wcm90b3R5cGUuYnJvYWRjYXN0ID0gZnVuY3Rpb24gKHBhY2tldCwgb3B0cykge1xuICAgICAgICBjb25zdCB1c2VGYXN0UHVibGlzaCA9IG9wdHMucm9vbXMuc2l6ZSA8PSAxICYmIG9wdHMuZXhjZXB0LnNpemUgPT09IDA7XG4gICAgICAgIGlmICghdXNlRmFzdFB1Ymxpc2gpIHtcbiAgICAgICAgICAgIGJyb2FkY2FzdC5jYWxsKHRoaXMsIHBhY2tldCwgb3B0cyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmxhZ3MgPSBvcHRzLmZsYWdzIHx8IHt9O1xuICAgICAgICBjb25zdCBiYXNlUGFja2V0T3B0cyA9IHtcbiAgICAgICAgICAgIHByZUVuY29kZWQ6IHRydWUsXG4gICAgICAgICAgICB2b2xhdGlsZTogZmxhZ3Mudm9sYXRpbGUsXG4gICAgICAgICAgICBjb21wcmVzczogZmxhZ3MuY29tcHJlc3MsXG4gICAgICAgIH07XG4gICAgICAgIHBhY2tldC5uc3AgPSB0aGlzLm5zcC5uYW1lO1xuICAgICAgICBjb25zdCBlbmNvZGVkUGFja2V0cyA9IHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0KTtcbiAgICAgICAgY29uc3QgdG9waWMgPSBvcHRzLnJvb21zLnNpemUgPT09IDBcbiAgICAgICAgICAgID8gdGhpcy5uc3AubmFtZVxuICAgICAgICAgICAgOiBgJHt0aGlzLm5zcC5uYW1lfSR7U0VQQVJBVE9SfSR7b3B0cy5yb29tcy5rZXlzKCkubmV4dCgpLnZhbHVlfWA7XG4gICAgICAgIGRlYnVnKFwiZmFzdCBwdWJsaXNoIHRvICVzXCIsIHRvcGljKTtcbiAgICAgICAgLy8gZmFzdCBwdWJsaXNoIGZvciBjbGllbnRzIGNvbm5lY3RlZCB3aXRoIFdlYlNvY2tldFxuICAgICAgICBlbmNvZGVkUGFja2V0cy5mb3JFYWNoKChlbmNvZGVkUGFja2V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0JpbmFyeSA9IHR5cGVvZiBlbmNvZGVkUGFja2V0ICE9PSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgLy8gXCI0XCIgYmVpbmcgdGhlIG1lc3NhZ2UgdHlwZSBpbiB0aGUgRW5naW5lLklPIHByb3RvY29sLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3NvY2tldGlvL2VuZ2luZS5pby1wcm90b2NvbFxuICAgICAgICAgICAgYXBwLnB1Ymxpc2godG9waWMsIGlzQmluYXJ5ID8gZW5jb2RlZFBhY2tldCA6IFwiNFwiICsgZW5jb2RlZFBhY2tldCwgaXNCaW5hcnkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcHBseShvcHRzLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICBpZiAoc29ja2V0LmNvbm4udHJhbnNwb3J0Lm5hbWUgIT09IFwid2Vic29ja2V0XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBjbGFzc2ljIHB1Ymxpc2ggZm9yIGNsaWVudHMgY29ubmVjdGVkIHdpdGggSFRUUCBsb25nLXBvbGxpbmdcbiAgICAgICAgICAgICAgICBzb2NrZXQuY2xpZW50LndyaXRlVG9FbmdpbmUoZW5jb2RlZFBhY2tldHMsIGJhc2VQYWNrZXRPcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN1YnNjcmliZShuYW1lc3BhY2VOYW1lLCBzb2NrZXQsIGlzTmV3LCByb29tcykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBzZXNzaW9uSWQgPSBzb2NrZXQuY29ubi5pZDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgd2Vic29ja2V0ID0gc29ja2V0LmNvbm4udHJhbnNwb3J0LnNvY2tldDtcbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgZGVidWcoXCJzdWJzY3JpYmUgY29ubmVjdGlvbiAlcyB0byB0b3BpYyAlc1wiLCBzZXNzaW9uSWQsIG5hbWVzcGFjZU5hbWUpO1xuICAgICAgICB3ZWJzb2NrZXQuc3Vic2NyaWJlKG5hbWVzcGFjZU5hbWUpO1xuICAgIH1cbiAgICByb29tcy5mb3JFYWNoKChyb29tKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvcGljID0gYCR7bmFtZXNwYWNlTmFtZX0ke1NFUEFSQVRPUn0ke3Jvb219YDsgLy8gJyMnIGNhbiBiZSB1c2VkIGFzIHdpbGRjYXJkXG4gICAgICAgIGRlYnVnKFwic3Vic2NyaWJlIGNvbm5lY3Rpb24gJXMgdG8gdG9waWMgJXNcIiwgc2Vzc2lvbklkLCB0b3BpYyk7XG4gICAgICAgIHdlYnNvY2tldC5zdWJzY3JpYmUodG9waWMpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVzdG9yZUFkYXB0ZXIoKSB7XG4gICAgc29ja2V0X2lvX2FkYXB0ZXJfMS5BZGFwdGVyLnByb3RvdHlwZS5hZGRBbGwgPSBhZGRBbGw7XG4gICAgc29ja2V0X2lvX2FkYXB0ZXJfMS5BZGFwdGVyLnByb3RvdHlwZS5kZWwgPSBkZWw7XG4gICAgc29ja2V0X2lvX2FkYXB0ZXJfMS5BZGFwdGVyLnByb3RvdHlwZS5icm9hZGNhc3QgPSBicm9hZGNhc3Q7XG59XG5jb25zdCB0b0FycmF5QnVmZmVyID0gKGJ1ZmZlcikgPT4ge1xuICAgIGNvbnN0IHsgYnVmZmVyOiBhcnJheUJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCB9ID0gYnVmZmVyO1xuICAgIHJldHVybiBhcnJheUJ1ZmZlci5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XG59O1xuLy8gaW1wb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20va29sb2R6aWVqY3phay1zei91d2Vic29ja2V0LXNlcnZlXG5mdW5jdGlvbiBzZXJ2ZUZpbGUocmVzIC8qIDogSHR0cFJlc3BvbnNlICovLCBmaWxlcGF0aCkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gKDAsIGZzXzEuc3RhdFN5bmMpKGZpbGVwYXRoKTtcbiAgICBjb25zdCByZWFkU3RyZWFtID0gKDAsIGZzXzEuY3JlYXRlUmVhZFN0cmVhbSkoZmlsZXBhdGgpO1xuICAgIGNvbnN0IGRlc3Ryb3lSZWFkU3RyZWFtID0gKCkgPT4gIXJlYWRTdHJlYW0uZGVzdHJveWVkICYmIHJlYWRTdHJlYW0uZGVzdHJveSgpO1xuICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgZGVzdHJveVJlYWRTdHJlYW0oKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfTtcbiAgICBjb25zdCBvbkRhdGFDaHVuayA9IChjaHVuaykgPT4ge1xuICAgICAgICBjb25zdCBhcnJheUJ1ZmZlckNodW5rID0gdG9BcnJheUJ1ZmZlcihjaHVuayk7XG4gICAgICAgIHJlcy5jb3JrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RPZmZzZXQgPSByZXMuZ2V0V3JpdGVPZmZzZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IFtvaywgZG9uZV0gPSByZXMudHJ5RW5kKGFycmF5QnVmZmVyQ2h1bmssIHNpemUpO1xuICAgICAgICAgICAgaWYgKCFkb25lICYmICFvaykge1xuICAgICAgICAgICAgICAgIHJlYWRTdHJlYW0ucGF1c2UoKTtcbiAgICAgICAgICAgICAgICByZXMub25Xcml0YWJsZSgob2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtvaywgZG9uZV0gPSByZXMudHJ5RW5kKGFycmF5QnVmZmVyQ2h1bmsuc2xpY2Uob2Zmc2V0IC0gbGFzdE9mZnNldCksIHNpemUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRvbmUgJiYgb2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRTdHJlYW0ucmVzdW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9rO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJlcy5vbkFib3J0ZWQoZGVzdHJveVJlYWRTdHJlYW0pO1xuICAgIHJlYWRTdHJlYW1cbiAgICAgICAgLm9uKFwiZGF0YVwiLCBvbkRhdGFDaHVuaylcbiAgICAgICAgLm9uKFwiZXJyb3JcIiwgb25FcnJvcilcbiAgICAgICAgLm9uKFwiZW5kXCIsIGRlc3Ryb3lSZWFkU3RyZWFtKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/uws.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/node_modules/debug/src/browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/browser.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWixZQUFZO0FBQ1osaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRDQUE0Qzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLGlGQUFVOztBQUVuQyxPQUFPLFlBQVk7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yc29sZS9Eb2N1bWVudHMvR2l0SHViL21hc3NpbWluby9tYXNzaW1pbm8vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5leHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuXHRsZXQgd2FybmVkID0gZmFsc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGxldCBtO1xuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIChtID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykpICYmIHBhcnNlSW50KG1bMV0sIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/node_modules/debug/src/common.js":
/*!*****************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/common.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"(rsc)/./node_modules/ms/index.js\");\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLDRDQUFJO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yc29sZS9Eb2N1bWVudHMvR2l0SHViL21hc3NpbWluby9tYXNzaW1pbm8vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblx0XHRsZXQgbmFtZXNwYWNlc0NhY2hlO1xuXHRcdGxldCBlbmFibGVkQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5hYmxlT3ZlcnJpZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcykge1xuXHRcdFx0XHRcdG5hbWVzcGFjZXNDYWNoZSA9IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXM7XG5cdFx0XHRcdFx0ZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVuYWJsZWRDYWNoZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cdFx0Y3JlYXRlRGVidWcubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zbGljZSgxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || false === true || process.__nwjs) {\n\tmodule.exports = __webpack_require__(/*! ./browser.js */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/browser.js\");\n} else {\n\tmodule.exports = __webpack_require__(/*! ./node.js */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUVBQXFFLEtBQWU7QUFDcEYsQ0FBQyw0SEFBd0M7QUFDekMsRUFBRTtBQUNGLENBQUMsc0hBQXFDO0FBQ3RDIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yc29sZS9Eb2N1bWVudHMvR2l0SHViL21hc3NpbWluby9tYXNzaW1pbm8vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGV0ZWN0IEVsZWN0cm9uIHJlbmRlcmVyIC8gbndqcyBwcm9jZXNzLCB3aGljaCBpcyBub2RlLCBidXQgd2Ugc2hvdWxkXG4gKiB0cmVhdCBhcyBhIGJyb3dzZXIuXG4gKi9cblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCBwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgcHJvY2Vzcy5icm93c2VyID09PSB0cnVlIHx8IHByb2Nlc3MuX19ud2pzKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9icm93c2VyLmpzJyk7XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbm9kZS5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/node_modules/debug/src/node.js":
/*!***************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/node.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */\n\nconst tty = __webpack_require__(/*! tty */ \"tty\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(\n\t() => {},\n\t'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'\n);\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = __webpack_require__(/*! supports-color */ \"(rsc)/./node_modules/supports-color/index.js\");\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.split('\\n')\n\t\t.map(str => str.trim())\n\t\t.join(' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0I7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWixXQUFXO0FBQ1gsa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWixZQUFZO0FBQ1osaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyxvRUFBZ0I7O0FBRS9DO0FBQ0EsRUFBRSxjQUFjO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRiw2REFBNkQ7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsNEJBQTRCOztBQUVwQztBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQsc0JBQXNCLFdBQVcsSUFBSSxNQUFNOztBQUUzQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLGlGQUFVOztBQUVuQyxPQUFPLFlBQVk7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3Jzb2xlL0RvY3VtZW50cy9HaXRIdWIvbWFzc2ltaW5vL21hc3NpbWluby9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIE5vZGUuanMgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5kZXN0cm95ID0gdXRpbC5kZXByZWNhdGUoXG5cdCgpID0+IHt9LFxuXHQnSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLidcbik7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWzYsIDIsIDMsIDQsIDUsIDFdO1xuXG50cnkge1xuXHQvLyBPcHRpb25hbCBkZXBlbmRlbmN5IChhcyBpbiwgZG9lc24ndCBuZWVkIHRvIGJlIGluc3RhbGxlZCwgTk9UIGxpa2Ugb3B0aW9uYWxEZXBlbmRlbmNpZXMgaW4gcGFja2FnZS5qc29uKVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5cdGNvbnN0IHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xuXG5cdGlmIChzdXBwb3J0c0NvbG9yICYmIChzdXBwb3J0c0NvbG9yLnN0ZGVyciB8fCBzdXBwb3J0c0NvbG9yKS5sZXZlbCA+PSAyKSB7XG5cdFx0ZXhwb3J0cy5jb2xvcnMgPSBbXG5cdFx0XHQyMCxcblx0XHRcdDIxLFxuXHRcdFx0MjYsXG5cdFx0XHQyNyxcblx0XHRcdDMyLFxuXHRcdFx0MzMsXG5cdFx0XHQzOCxcblx0XHRcdDM5LFxuXHRcdFx0NDAsXG5cdFx0XHQ0MSxcblx0XHRcdDQyLFxuXHRcdFx0NDMsXG5cdFx0XHQ0NCxcblx0XHRcdDQ1LFxuXHRcdFx0NTYsXG5cdFx0XHQ1Nyxcblx0XHRcdDYyLFxuXHRcdFx0NjMsXG5cdFx0XHQ2OCxcblx0XHRcdDY5LFxuXHRcdFx0NzQsXG5cdFx0XHQ3NSxcblx0XHRcdDc2LFxuXHRcdFx0NzcsXG5cdFx0XHQ3OCxcblx0XHRcdDc5LFxuXHRcdFx0ODAsXG5cdFx0XHQ4MSxcblx0XHRcdDkyLFxuXHRcdFx0OTMsXG5cdFx0XHQ5OCxcblx0XHRcdDk5LFxuXHRcdFx0MTEyLFxuXHRcdFx0MTEzLFxuXHRcdFx0MTI4LFxuXHRcdFx0MTI5LFxuXHRcdFx0MTM0LFxuXHRcdFx0MTM1LFxuXHRcdFx0MTQ4LFxuXHRcdFx0MTQ5LFxuXHRcdFx0MTYwLFxuXHRcdFx0MTYxLFxuXHRcdFx0MTYyLFxuXHRcdFx0MTYzLFxuXHRcdFx0MTY0LFxuXHRcdFx0MTY1LFxuXHRcdFx0MTY2LFxuXHRcdFx0MTY3LFxuXHRcdFx0MTY4LFxuXHRcdFx0MTY5LFxuXHRcdFx0MTcwLFxuXHRcdFx0MTcxLFxuXHRcdFx0MTcyLFxuXHRcdFx0MTczLFxuXHRcdFx0MTc4LFxuXHRcdFx0MTc5LFxuXHRcdFx0MTg0LFxuXHRcdFx0MTg1LFxuXHRcdFx0MTk2LFxuXHRcdFx0MTk3LFxuXHRcdFx0MTk4LFxuXHRcdFx0MTk5LFxuXHRcdFx0MjAwLFxuXHRcdFx0MjAxLFxuXHRcdFx0MjAyLFxuXHRcdFx0MjAzLFxuXHRcdFx0MjA0LFxuXHRcdFx0MjA1LFxuXHRcdFx0MjA2LFxuXHRcdFx0MjA3LFxuXHRcdFx0MjA4LFxuXHRcdFx0MjA5LFxuXHRcdFx0MjE0LFxuXHRcdFx0MjE1LFxuXHRcdFx0MjIwLFxuXHRcdFx0MjIxXG5cdFx0XTtcblx0fVxufSBjYXRjaCAoZXJyb3IpIHtcblx0Ly8gU3dhbGxvdyAtIHdlIG9ubHkgY2FyZSBpZiBgc3VwcG9ydHMtY29sb3JgIGlzIGF2YWlsYWJsZTsgaXQgZG9lc24ndCBoYXZlIHRvIGJlLlxufVxuXG4vKipcbiAqIEJ1aWxkIHVwIHRoZSBkZWZhdWx0IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiAgICQgREVCVUdfQ09MT1JTPW5vIERFQlVHX0RFUFRIPTEwIERFQlVHX1NIT1dfSElEREVOPWVuYWJsZWQgbm9kZSBzY3JpcHQuanNcbiAqL1xuXG5leHBvcnRzLmluc3BlY3RPcHRzID0gT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZpbHRlcihrZXkgPT4ge1xuXHRyZXR1cm4gL15kZWJ1Z18vaS50ZXN0KGtleSk7XG59KS5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG5cdC8vIENhbWVsLWNhc2Vcblx0Y29uc3QgcHJvcCA9IGtleVxuXHRcdC5zdWJzdHJpbmcoNilcblx0XHQudG9Mb3dlckNhc2UoKVxuXHRcdC5yZXBsYWNlKC9fKFthLXpdKS9nLCAoXywgaykgPT4ge1xuXHRcdFx0cmV0dXJuIGsudG9VcHBlckNhc2UoKTtcblx0XHR9KTtcblxuXHQvLyBDb2VyY2Ugc3RyaW5nIHZhbHVlIGludG8gSlMgdmFsdWVcblx0bGV0IHZhbCA9IHByb2Nlc3MuZW52W2tleV07XG5cdGlmICgvXih5ZXN8b258dHJ1ZXxlbmFibGVkKSQvaS50ZXN0KHZhbCkpIHtcblx0XHR2YWwgPSB0cnVlO1xuXHR9IGVsc2UgaWYgKC9eKG5vfG9mZnxmYWxzZXxkaXNhYmxlZCkkL2kudGVzdCh2YWwpKSB7XG5cdFx0dmFsID0gZmFsc2U7XG5cdH0gZWxzZSBpZiAodmFsID09PSAnbnVsbCcpIHtcblx0XHR2YWwgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdHZhbCA9IE51bWJlcih2YWwpO1xuXHR9XG5cblx0b2JqW3Byb3BdID0gdmFsO1xuXHRyZXR1cm4gb2JqO1xufSwge30pO1xuXG4vKipcbiAqIElzIHN0ZG91dCBhIFRUWT8gQ29sb3JlZCBvdXRwdXQgaXMgZW5hYmxlZCB3aGVuIGB0cnVlYC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdHJldHVybiAnY29sb3JzJyBpbiBleHBvcnRzLmluc3BlY3RPcHRzID9cblx0XHRCb29sZWFuKGV4cG9ydHMuaW5zcGVjdE9wdHMuY29sb3JzKSA6XG5cdFx0dHR5LmlzYXR0eShwcm9jZXNzLnN0ZGVyci5mZCk7XG59XG5cbi8qKlxuICogQWRkcyBBTlNJIGNvbG9yIGVzY2FwZSBjb2RlcyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGNvbnN0IHtuYW1lc3BhY2U6IG5hbWUsIHVzZUNvbG9yc30gPSB0aGlzO1xuXG5cdGlmICh1c2VDb2xvcnMpIHtcblx0XHRjb25zdCBjID0gdGhpcy5jb2xvcjtcblx0XHRjb25zdCBjb2xvckNvZGUgPSAnXFx1MDAxQlszJyArIChjIDwgOCA/IGMgOiAnODs1OycgKyBjKTtcblx0XHRjb25zdCBwcmVmaXggPSBgICAke2NvbG9yQ29kZX07MW0ke25hbWV9IFxcdTAwMUJbMG1gO1xuXG5cdFx0YXJnc1swXSA9IHByZWZpeCArIGFyZ3NbMF0uc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbicgKyBwcmVmaXgpO1xuXHRcdGFyZ3MucHVzaChjb2xvckNvZGUgKyAnbSsnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKSArICdcXHUwMDFCWzBtJyk7XG5cdH0gZWxzZSB7XG5cdFx0YXJnc1swXSA9IGdldERhdGUoKSArIG5hbWUgKyAnICcgKyBhcmdzWzBdO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldERhdGUoKSB7XG5cdGlmIChleHBvcnRzLmluc3BlY3RPcHRzLmhpZGVEYXRlKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cdHJldHVybiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyAnICc7XG59XG5cbi8qKlxuICogSW52b2tlcyBgdXRpbC5mb3JtYXRXaXRoT3B0aW9ucygpYCB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzIGFuZCB3cml0ZXMgdG8gc3RkZXJyLlxuICovXG5cbmZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG5cdHJldHVybiBwcm9jZXNzLnN0ZGVyci53cml0ZSh1dGlsLmZvcm1hdFdpdGhPcHRpb25zKGV4cG9ydHMuaW5zcGVjdE9wdHMsIC4uLmFyZ3MpICsgJ1xcbicpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0cHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHlvdSBzZXQgYSBwcm9jZXNzLmVudiBmaWVsZCB0byBudWxsIG9yIHVuZGVmaW5lZCwgaXQgZ2V0cyBjYXN0IHRvIHRoZVxuXHRcdC8vIHN0cmluZyAnbnVsbCcgb3IgJ3VuZGVmaW5lZCcuIEp1c3QgZGVsZXRlIGluc3RlYWQuXG5cdFx0ZGVsZXRlIHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcblx0cmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xufVxuXG4vKipcbiAqIEluaXQgbG9naWMgZm9yIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICpcbiAqIENyZWF0ZSBhIG5ldyBgaW5zcGVjdE9wdHNgIG9iamVjdCBpbiBjYXNlIGB1c2VDb2xvcnNgIGlzIHNldFxuICogZGlmZmVyZW50bHkgZm9yIGEgcGFydGljdWxhciBgZGVidWdgIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGluaXQoZGVidWcpIHtcblx0ZGVidWcuaW5zcGVjdE9wdHMgPSB7fTtcblxuXHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5pbnNwZWN0T3B0cyk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdGRlYnVnLmluc3BlY3RPcHRzW2tleXNbaV1dID0gZXhwb3J0cy5pbnNwZWN0T3B0c1trZXlzW2ldXTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlbyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGwgb24gYSBzaW5nbGUgbGluZS5cbiAqL1xuXG5mb3JtYXR0ZXJzLm8gPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXHRyZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpXG5cdFx0LnNwbGl0KCdcXG4nKVxuXHRcdC5tYXAoc3RyID0+IHN0ci50cmltKCkpXG5cdFx0LmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogTWFwICVPIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbG93aW5nIG11bHRpcGxlIGxpbmVzIGlmIG5lZWRlZC5cbiAqL1xuXG5mb3JtYXR0ZXJzLk8gPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXHRyZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/node_modules/debug/src/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/package.json":
/*!*********************************************!*\
  !*** ./node_modules/socket.io/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"socket.io","version":"4.8.1","description":"node.js realtime framework server","keywords":["realtime","framework","websocket","tcp","events","socket","io"],"files":["dist/","client-dist/","wrapper.mjs","!**/*.tsbuildinfo"],"directories":{"doc":"docs/","example":"example/","lib":"lib/","test":"test/"},"type":"commonjs","main":"./dist/index.js","exports":{"types":"./dist/index.d.ts","import":"./wrapper.mjs","require":"./dist/index.js"},"types":"./dist/index.d.ts","license":"MIT","homepage":"https://github.com/socketio/socket.io/tree/main/packages/socket.io#readme","repository":{"type":"git","url":"git+https://github.com/socketio/socket.io.git"},"bugs":{"url":"https://github.com/socketio/socket.io/issues"},"scripts":{"compile":"rimraf ./dist && tsc","test":"npm run format:check && npm run compile && npm run test:types && npm run test:unit","test:types":"tsd","test:unit":"nyc mocha --require ts-node/register --reporter spec --slow 200 --bail --timeout 10000 test/index.ts","format:check":"prettier --check \\"lib/**/*.ts\\" \\"test/**/*.ts\\"","format:fix":"prettier --write \\"lib/**/*.ts\\" \\"test/**/*.ts\\"","prepack":"npm run compile"},"dependencies":{"accepts":"~1.3.4","base64id":"~2.0.0","cors":"~2.8.5","debug":"~4.3.2","engine.io":"~6.6.0","socket.io-adapter":"~2.5.2","socket.io-parser":"~4.2.4"},"contributors":[{"name":"Guillermo Rauch","email":"rauchg@gmail.com"},{"name":"Arnout Kazemier","email":"info@3rd-eden.com"},{"name":"Vladimir Dronnikov","email":"dronnikov@gmail.com"},{"name":"Einar Otto Stangvik","email":"einaros@gmail.com"}],"engines":{"node":">=10.2.0"},"tsd":{"directory":"test"}}');

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/wrapper.mjs":
/*!********************************************!*\
  !*** ./node_modules/socket.io/wrapper.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Namespace: () => (/* binding */ Namespace),\n/* harmony export */   Server: () => (/* binding */ Server),\n/* harmony export */   Socket: () => (/* binding */ Socket)\n/* harmony export */ });\n/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ \"(rsc)/./node_modules/socket.io/dist/index.js\");\n\n\nconst {Server, Namespace, Socket} = _dist_index_js__WEBPACK_IMPORTED_MODULE_0__;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL3dyYXBwZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUM7O0FBRTFCLE9BQU8sMkJBQTJCLEVBQUUsMkNBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3Jzb2xlL0RvY3VtZW50cy9HaXRIdWIvbWFzc2ltaW5vL21hc3NpbWluby9ub2RlX21vZHVsZXMvc29ja2V0LmlvL3dyYXBwZXIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBpbyBmcm9tIFwiLi9kaXN0L2luZGV4LmpzXCI7XG5cbmV4cG9ydCBjb25zdCB7U2VydmVyLCBOYW1lc3BhY2UsIFNvY2tldH0gPSBpbztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/wrapper.mjs\n");

/***/ })

};
;